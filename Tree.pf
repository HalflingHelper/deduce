import Option
import List

union Direction {
  left
  right
}

union Tree<E> {
  empty_tree
  tree_node(Tree<E>, E, Tree<E>)
}

function tree_data<E>(Tree<E>) -> Option<E> {
  tree_data(empty_tree) = none
  tree_data(tree_node(L, x, R)) = just(x)
}

function locate<E>(List<Direction>, Tree<E>) -> Tree<E> {
  locate(empty, T) = T
  locate(node(d, ds), T) =
    switch d {
      case left {
	switch T {
	  case empty_tree {
	    empty_tree
	  }
	  case tree_node(L, x, R) {
	    locate(ds, L)
	  }
	}
      }
      case right {
	switch T {
	  case empty_tree {
	    empty_tree
	  }
	  case tree_node(L, x, R) {
	    locate(ds, R)
	  }
	}
      }
    }
}

function pre_order<E>(Tree<E>) -> List<E> {
  pre_order(empty_tree) = empty
  pre_order(tree_node(L, x, R)) =
    node(x, append(pre_order(L), pre_order(R)))
}

function in_order<E>(Tree<E>) -> List<E> {
  in_order(empty_tree) = empty
  in_order(tree_node(L, x, R)) =
    append(in_order(L), node(x, in_order(R)))
}

function post_order<E>(Tree<E>) -> List<E> {
  post_order(empty_tree) = empty
  post_order(tree_node(L, x, R)) =
    append(post_order(L), append(post_order(R), node(x, empty)))
}

function tree_take<E>(List<Direction>, Tree<E>) -> Tree<E> {
  tree_take(empty, T) =
    switch T {
      case empty_tree {
	empty_tree
      }
      case tree_node(L, x, R) {
	L
      }
    }
  tree_take(node(d, ds), T) =
    switch d {
      case left {
        switch T {
	  case empty_tree {
	    empty_tree
	  }
	  case tree_node(L, x, R) {
	    tree_take(ds, L)
	  }
	}
      }
      case right {
        switch T {
	  case empty_tree {
	    empty_tree
	  }
	  case tree_node(L, x, R) {
	    tree_node(L, x, tree_take(ds, R))
	  }
	}
      }
    }
}

function tree_drop<E>(List<Direction>, Tree<E>) -> Tree<E> {
  tree_drop(empty, T) =
    switch T {
      case empty_tree {
	empty_tree
      }
      case tree_node(L, x, R) {
	R
      }
    }
  tree_drop(node(d, ds), T) =
    switch d {
      case left {
        switch T {
	  case empty_tree {
	    empty_tree
	  }
	  case tree_node(L, x, R) {
	    tree_node(tree_drop(ds, L), x, R)
	  }
	}
      }
      case right {
        switch T {
	  case empty_tree {
	    empty_tree
	  }
	  case tree_node(L, x, R) {
	    tree_drop(ds, R)
	  }
	}
      }
    }
}

function locate_first<E>(Tree<E>) -> List<Direction> {
  locate_first(empty_tree) = empty
  locate_first(tree_node(L, x, R)) =
    switch L {
      case empty_tree {
        empty
      }
      case tree_node(LL, y, LR) {
        node(left, locate_first(L))
      }
    }
}

define T1 = tree_node(empty_tree, 1, empty_tree)
define T3 = tree_node(empty_tree, 3, empty_tree)
define T123 = tree_node(T1, 2, T3)
define T1234 = tree_node(T123, 4, empty_tree)

assert tree_data(locate(locate_first(T1), T1)) = head(in_order(T1))
assert tree_data(locate(locate_first(T123), T123)) = head(in_order(T123))
assert tree_data(locate(locate_first(T1234), T1234)) = head(in_order(T1234))

theorem locate_first_head_in_order:
  all E:type. all T:Tree<E>.
  tree_data(locate(locate_first(T), T)) = head(in_order(T))
proof
  arbitrary E:type
  induction Tree<E>
  case empty_tree {
    equations
          tree_data(locate(locate_first(empty_tree),empty_tree))
        = none
           by definition {locate_first, locate, tree_data}.
    ... = head(in_order(empty_tree))
           by definition {head, in_order}.
  }
  case tree_node(L, x, R) suppose IH {
    definition {locate_first}
    switch L {
      case empty_tree {
        equations
              tree_data(locate(empty,tree_node(empty_tree,x,R)))
            = just(x)
                by definition {locate, tree_data}.
        ... = head(in_order(tree_node(empty_tree,x,R)))
                by definition {in_order,head,in_order,append}.
      }
      case tree_node(LL, y, LR) suppose Ldef {
        rewrite symmetric Ldef
	have pos_len: 0 < length(in_order(L))
	  by rewrite Ldef definition {in_order}
	     rewrite length_append[E][in_order(LL)][node(y, in_order(LR))]
	     definition {length, operator <}
	     rewrite add_suc[length(in_order(LL))][length(in_order(LR))]
	     definition {operator ≤,operator ≤}.
        equations
  	      tree_data(locate(node(left,locate_first(L)),tree_node(L,x,R)))
	    = tree_data(locate(locate_first(L),L))
	      by definition locate.
	... = head(in_order(L))
	      by IH
	... = head(append(in_order(L),node(x,in_order(R))))
              by symmetric
	         apply head_append[E][in_order(L)][node(x,in_order(R))]
	         to pos_len
	... = head(in_order(tree_node(L,x,R)))
	      by definition {in_order}.
      }
    }
  }
end

theorem take_locate_drop_in_order:
  all E:type. all l:List<Direction>. all T:Tree<E>, x:E.
  if tree_data(locate(l,T)) = just(x)
  then append(in_order(tree_take(l, T)),
              node(x, in_order(tree_drop(l, T))))
     = in_order(T)
proof
  arbitrary E:type
  induction List<Direction>
  case empty {
    arbitrary T:Tree<E>, x:E
    switch T {
      case empty_tree {
        definition {locate, tree_data}.
      }
      case tree_node(L, y, R) {
        definition {locate,tree_data, tree_take, tree_drop, in_order}
	suppose jy_jx
	have xy: x = y
	  by injective just symmetric jy_jx
        rewrite xy.
      }
    }
  }
  case node(d, ds) suppose IH {
    arbitrary T:Tree<E>, x:E
    switch d {
      case left {
        switch T {
	  case empty_tree {
	    definition {locate, tree_data, tree_take, tree_drop, in_order}.
	  }
	  case tree_node(L, y, R) {
	    definition {locate,tree_take,tree_drop, in_order}
	    suppose locL_x: tree_data(locate(ds,L)) = just(x)
	    define take_L = in_order(tree_take(ds,L))
	    define drop_L = in_order(tree_drop(ds,L))
	    have IH_L: append(take_L, node(x, drop_L)) = in_order(L)
	      by definition {take_L, drop_L} apply IH[L,x] to locL_x
	    definition {take_L, drop_L} in
	    conclude append(take_L, node(x, append(drop_L, node(y, in_order(R)))))
	      = append(in_order(L), node(y, in_order(R))) by
            equations
	      append(take_L, node(x, append(drop_L, node(y, in_order(R)))))
	        = append(append(take_L, node(x, drop_L)), node(y, in_order(R)))
  	            by enable append symmetric append_assoc[E][take_L][node(x,drop_L),node(y, in_order(R))]
	    ... = append(in_order(L), node(y, in_order(R)))
	            by rewrite IH_L.
	  }
	}
      }
      case right {
        switch T {
	  case empty_tree {
	    definition {locate, tree_data, tree_take, tree_drop, in_order}.
	  }
	  case tree_node(L, y, R) {
	    definition {locate,tree_take,tree_drop, in_order}
	    suppose locR_x: tree_data(locate(ds,R)) = just(x)
	    define take_R = in_order(tree_take(ds,R))
	    define drop_R = in_order(tree_drop(ds,R))
	    have IH_R: append(take_R, node(x, drop_R)) = in_order(R)
	      by definition {take_R, drop_R} apply IH[R,x] to locR_x
	    ?
	  }
	}
      }
    }
  }
end

function prev_ancester(List<Direction>) -> List<Direction> {
  prev_ancester(empty) = empty
  prev_ancester(node(d, ds)) =
    switch d {
      case left {
        ds
      }
      case right {
        prev_ancester(ds)
      }
    }
}

define next : < E > fn Tree<E>, List<Direction> -> List<Direction> =
  generic E { λ T, ds {
    switch locate(ds, T) {
      case empty_tree {
        empty
      }
      case tree_node(L, x, R) {
        switch R {
	  case empty_tree {
	    reverse(prev_ancester(reverse(ds)))
	  }
	  case tree_node(RL, y, RR) {
	    append(ds, node(right, locate_first(R)))
	  }
	}
      }
    }
    }
  }

assert locate(next(T123, node(left, empty)), T123) = T123
assert locate(next(T123, empty), T123) = T3

/*
theorem next_correct: all E:type. all i:Nat, T:Tree<E>.
  nth(in_order(T), empty)(i)
       = iterate(i, locate_first(T), λ ds { next(T, ds) })
proof
  ?
end
*/