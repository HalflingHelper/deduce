import Option
import List

union Direction {
  left
  right
}

union Tree<E> {
  empty_tree
  tree_node(Tree<E>, E, Tree<E>)
}

function tree_data<E>(Tree<E>) -> Option<E> {
  tree_data(empty_tree) = none
  tree_data(tree_node(L, x, R)) = just(x)
}

function locate<E>(List<Direction>, Tree<E>) -> Tree<E> {
  locate(empty, T) = T
  locate(node(d, ds), T) =
    switch d {
      case left {
	switch T {
	  case empty_tree {
	    empty_tree
	  }
	  case tree_node(L, x, R) {
	    locate(ds, L)
	  }
	}
      }
      case right {
	switch T {
	  case empty_tree {
	    empty_tree
	  }
	  case tree_node(L, x, R) {
	    locate(ds, R)
	  }
	}
      }
    }
}

function pre_order<E>(Tree<E>) -> List<E> {
  pre_order(empty_tree) = empty
  pre_order(tree_node(L, x, R)) =
    node(x, append(pre_order(L), pre_order(R)))
}

function in_order<E>(Tree<E>) -> List<E> {
  in_order(empty_tree) = empty
  in_order(tree_node(L, x, R)) =
    append(in_order(L), node(x, in_order(R)))
}

function post_order<E>(Tree<E>) -> List<E> {
  post_order(empty_tree) = empty
  post_order(tree_node(L, x, R)) =
    append(post_order(L), append(post_order(R), node(x, empty)))
}

function locate_first<E>(Tree<E>) -> List<Direction> {
  locate_first(empty_tree) = empty
  locate_first(tree_node(L, x, R)) =
    switch L {
      case empty_tree {
        empty
      }
      case tree_node(LL, y, LR) {
        node(left, locate_first(L))
      }
    }
}

define T1 = tree_node(empty_tree, 1, empty_tree)
define T3 = tree_node(empty_tree, 3, empty_tree)
define T123 = tree_node(T1, 2, T3)

assert tree_data(locate(locate_first(T123), T123)) = head(in_order(T123))

theorem locate_first_head_in_order:
  all E:type. all T:Tree<E>.
  tree_data(locate(locate_first(T), T)) = head(in_order(T))
proof
  arbitrary E:type
  induction Tree<E>
  case empty_tree {
    equations
          tree_data(locate(locate_first(empty_tree),empty_tree))
        = none
           by definition {locate_first, locate, tree_data}.
    ... = head(in_order(empty_tree))
           by definition {head, in_order}.
  }
  case tree_node(L, x, R) suppose IH {
    definition {locate_first}
    switch L {
      case empty_tree {
        equations
              tree_data(locate(empty,tree_node(empty_tree,x,R)))
            = just(x)
                by definition {locate, tree_data}.
        ... = head(in_order(tree_node(empty_tree,x,R)))
                by definition {in_order,head,in_order,append}.
      }
      case tree_node(LL, y, LR) suppose Ldef {
        rewrite symmetric Ldef
	have pos_len: 0 < length(in_order(L))
	  by rewrite Ldef definition {in_order}
	     rewrite length_append[E][in_order(LL)][node(y, in_order(LR))]
	     definition {length, operator <}
	     rewrite add_suc[length(in_order(LL))][length(in_order(LR))]
	     definition {operator ≤,operator ≤}.
        equations
  	      tree_data(locate(node(left,locate_first(L)),tree_node(L,x,R)))
	    = tree_data(locate(locate_first(L),L))
	      by definition locate.
	... = head(in_order(L))
	      by IH
	... = head(append(in_order(L),node(x,in_order(R))))
              by symmetric
	         apply head_append[E][in_order(L)][node(x,in_order(R))]
	         to pos_len
	... = head(in_order(tree_node(L,x,R)))
	      by definition {in_order}.
      }
    }
  }
end

function prev_ancester(List<Direction>) -> List<Direction> {
  prev_ancester(empty) = empty
  prev_ancester(node(d, ds)) =
    switch d {
      case left {
        ds
      }
      case right {
        prev_ancester(ds)
      }
    }
}

define next : < E > fn Tree<E>, List<Direction> -> List<Direction> =
  generic E { λ T, ds {
    switch locate(ds, T) {
      case empty_tree {
        empty
      }
      case tree_node(L, x, R) {
        switch R {
	  case empty_tree {
	    reverse(prev_ancester(reverse(ds)))
	  }
	  case tree_node(RL, y, RR) {
	    append(ds, node(right, locate_first(R)))
	  }
	}
      }
    }
    }
  }

assert locate(next(T123, node(left, empty)), T123) = T123
assert locate(next(T123, empty), T123) = T3

/*
theorem next_correct: all E:type. all i:Nat, T:Tree<E>.
  nth(in_order(T), empty)(i)
       = iterate(i, locate_first(T), λ ds { next(T, ds) })
proof
  ?
end
*/