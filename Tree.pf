import Option
import Nat
import List


union Tree<E> {
  empty_tree
  tree_node(Tree<E>, E, Tree<E>)
}

function tree_data<E>(Tree<E>) -> Option<E> {
  tree_data(empty_tree) = none
  tree_data(tree_node(L, x, R)) = just(x)
}

function left_child<E>(Tree<E>) -> Tree<E> {
  left_child(empty_tree) = empty_tree
  left_child(tree_node(L, x, R)) = L
}

function right_child<E>(Tree<E>) -> Tree<E> {
  right_child(empty_tree) = empty_tree
  right_child(tree_node(L, x, R)) = R
}

function tree_nodes<E>(Tree<E>) -> Nat {
  tree_nodes(empty_tree) = 0
  tree_nodes(tree_node(L, x, R)) = suc(tree_nodes(L) + tree_nodes(R))
}

function height<E>(Tree<E>) -> Nat {
  height(empty_tree) = 0
  height(tree_node(L, x, R)) = suc(max(height(L), height(R)))
}

function pre_order<E>(Tree<E>) -> List<E> {
  pre_order(empty_tree) = empty
  pre_order(tree_node(L, x, R)) =
    node(x, append(pre_order(L), pre_order(R)))
}

function in_order<E>(Tree<E>) -> List<E> {
  in_order(empty_tree) = empty
  in_order(tree_node(L, x, R)) =
    append(in_order(L), node(x, in_order(R)))
}

function post_order<E>(Tree<E>) -> List<E> {
  post_order(empty_tree) = empty
  post_order(tree_node(L, x, R)) =
    append(post_order(L), append(post_order(R), node(x, empty)))
}

theorem in_order_assoc: all E:type. all A:Tree<E>. all x:E, B:Tree<E>, y:E, C:Tree<E>.
    in_order(tree_node(tree_node(A, x, B), y, C))
  = in_order(tree_node(A, x, tree_node(B, y, C)))
proof
  arbitrary E:type
  induction Tree<E>
  case empty_tree {
    arbitrary x:E, B:Tree<E>, y:E, C:Tree<E>
    definition {in_order, in_order, in_order, append}.
  }
  case tree_node(L, z, R) {
    arbitrary x:E, B:Tree<E>, y:E, C:Tree<E>
    definition {in_order, in_order, in_order}
    equations
          append(append( append(in_order(L), node(z,in_order(R))), node(x,in_order(B))), node(y,in_order(C)))
        = append( append(in_order(L), node(z,in_order(R))),  append( node(x,in_order(B)), node(y,in_order(C))))
          by rewrite append_assoc[E][append(in_order(L), node(z,in_order(R)))][node(x,in_order(B)), node(y,in_order(C))].
    ... = append( append(in_order(L), node(z,in_order(R))),  node(x, append(in_order(B), node(y,in_order(C)))))
          by definition append.
  }
end


union Frame<E> {
  leftF(Tree<E>, E)
  rightF(E,Tree<E>)
}

union TreeZipper<E> {
  treeZip(List<Frame<E>>, Tree<E>, E, Tree<E>)
}

function zip_get<E>(TreeZipper<E>) -> E {
  zip_get(treeZip(ctx, L, x, R)) = x
}

function context<E>(TreeZipper<E>) -> List<Frame<E>> {
  context(treeZip(ctx, L, x, R)) = ctx
}

function focus<E>(TreeZipper<E>) -> Tree<E> {
  focus(treeZip(ctx, L, x, R)) = tree_node(L, x, R)
}

function plug_tree<E>(List<Frame<E>>, Tree<E>) -> Tree<E> {
  plug_tree(empty, t) = t
  plug_tree(node(f, ctx'), t) =
    switch f {
      case leftF(L, x) {
        plug_tree(ctx', tree_node(L, x, t))
      }
      case rightF(x, R) {
        plug_tree(ctx', tree_node(t, x, R))
      }
    }
}

function zip2tree<E>(TreeZipper<E>) -> Tree<E> {
  zip2tree(treeZip(ctx, L, x, R)) = plug_tree(ctx, tree_node(L, x, R))
}

function next_up<E>(List<Frame<E>>, Tree<E>, E, Tree<E>) -> TreeZipper<E> {
  next_up(empty, A, z, B) = treeZip(empty, A, z, B)
  next_up(node(f, ctx'), A, z, B) =
    switch f {
      case leftF(L, x) {
        next_up(ctx', L, x, tree_node(A, z, B))
      }
      case rightF(x, R) {
        treeZip(ctx', tree_node(A, z, B), x, R)
      }
    }
}

function first_ctx<E>(Tree<E>, E, Tree<E>, List<Frame<E>>) -> TreeZipper<E> {
  first_ctx(empty_tree, x, R, ctx) = treeZip(ctx, empty_tree, x, R)
  first_ctx(tree_node(LL, y, LR), x, R, ctx) = first_ctx(LL, y, LR, node(rightF(x, R), ctx))
}

function zip_next<E>(TreeZipper<E>) -> TreeZipper<E> {
  zip_next(treeZip(ctx, L, x, R)) =
    switch R {
      case empty_tree {
        next_up(ctx, L, x, R)
      }
      case tree_node(RL, y, RR) {
        first_ctx(RL, y, RR, node(leftF(L, x), ctx))
      }
    }
}

function take_ctx<E>(List<Frame<E>>) -> List<Frame<E>> {
  take_ctx(empty) = empty
  take_ctx(node(f, ctx')) =
    switch f {
      case leftF(L, x) {
        node(leftF(L,x), take_ctx(ctx'))
      }
      case rightF(x, R) {
        take_ctx(ctx')
      }
    }
}

function drop_ctx<E>(List<Frame<E>>) -> List<Frame<E>> {
  drop_ctx(empty) = empty
  drop_ctx(node(f, ctx')) =
    switch f {
      case leftF(L, x) {
        drop_ctx(ctx')
      }
      case rightF(x, R) {
        node(rightF(x, R), drop_ctx(ctx'))
      }
    }
}

function zip_index<E>(TreeZipper<E>) -> Nat {
  zip_index(treeZip(ctx, L, x, R)) = tree_nodes(plug_tree(take_ctx(ctx), empty_tree)) + tree_nodes(L)
}

lemma in_order_plug_take: all E:type. all ctx:List<Frame<E>>. all t:Tree<E>.
  in_order(plug_tree(take_ctx(ctx), t)) = append( in_order(plug_tree(take_ctx(ctx),empty_tree)), in_order(t))
proof
  arbitrary E:type
  induction List<Frame<E>>
  case empty {
    arbitrary t:Tree<E>
    definition {take_ctx, plug_tree, in_order, append}.
  }
  case node(f, ctx') suppose IH {
    arbitrary t:Tree<E>
    switch f {
      case leftF(L, x) {
        definition {take_ctx, plug_tree}
        equations
              in_order(plug_tree(take_ctx(ctx'),tree_node(L,x,t)))
            = append(in_order(plug_tree(take_ctx(ctx'),empty_tree)), in_order(tree_node(L,x,t)))
                  by IH[tree_node(L,x,t)]
        ... = append( in_order(plug_tree(take_ctx(ctx'),empty_tree)), append(in_order(L), node(x, in_order(t))))
                  by definition in_order.
        ... = append( in_order(plug_tree(take_ctx(ctx'),empty_tree)), append(append(in_order(L), node(x, empty)), in_order(t)))
                  by rewrite append_assoc[E][in_order(L)][node(x,empty), in_order(t)] definition {append, append}.
        ... = append(append( in_order(plug_tree(take_ctx(ctx'),empty_tree)), append(in_order(L), node(x, empty))), in_order(t))
                  by rewrite append_assoc[E][in_order(plug_tree(take_ctx(ctx'),empty_tree))][append(in_order(L), node(x, empty)), in_order(t)].
        ... = append(append( in_order(plug_tree(take_ctx(ctx'),empty_tree)), append(in_order(L), node(x, in_order(empty_tree)))), in_order(t))
                  by definition in_order.
        ... = append(append( in_order(plug_tree(take_ctx(ctx'),empty_tree)), in_order(tree_node(L,x,empty_tree))), in_order(t))
                  by definition {in_order, in_order}.
        ... = append(in_order(plug_tree(take_ctx(ctx'), tree_node(L,x,empty_tree))),in_order(t))
                  by rewrite IH[tree_node(L,x,empty_tree)].
      }
      case rightF(x, R) {
        definition {take_ctx}
        conclude in_order(plug_tree(take_ctx(ctx'),t))
               = append(in_order(plug_tree(take_ctx(ctx'),empty_tree)),in_order(t))
            by IH[t]
      }
    }
  }
end

lemma in_order_plug_drop: all E:type. all ctx:List<Frame<E>>. all t:Tree<E>.
  in_order(plug_tree(drop_ctx(ctx), t)) = append( in_order(t), in_order(plug_tree(drop_ctx(ctx),empty_tree)))
proof
  arbitrary E:type
  induction List<Frame<E>>
  case empty {
    arbitrary t:Tree<E>
    definition {drop_ctx, plug_tree, in_order}
    rewrite append_empty[E][in_order(t)].
  }
  case node(f, ctx') suppose IH {
    arbitrary t:Tree<E>
    switch f {
      case leftF(L, x) {
        definition {drop_ctx}
        conclude in_order(plug_tree(drop_ctx(ctx'),t))
               = append(in_order(t),in_order(plug_tree(drop_ctx(ctx'),empty_tree)))
            by IH[t]
      }
      case rightF(x, R) {
        definition {drop_ctx, plug_tree}
        have IH2: in_order(plug_tree(drop_ctx(ctx'),tree_node(t,x,R)))
                = append(in_order(tree_node(t,x,R)),in_order(plug_tree(drop_ctx(ctx'),empty_tree)))
                by IH[tree_node(t,x,R)]
        equations
          in_order(plug_tree(drop_ctx(ctx'),tree_node(t,x,R)))
              = append(in_order(tree_node(t,x,R)), in_order(plug_tree(drop_ctx(ctx'),empty_tree)))
                   by IH2
          ... = append( append(in_order(t), node(x, in_order(R))), in_order(plug_tree(drop_ctx(ctx'), empty_tree)))
                   by definition in_order.
          ... = append( append(in_order(t), in_order(tree_node(empty_tree,x,R))), in_order(plug_tree(drop_ctx(ctx'), empty_tree)))
                   by definition {in_order,in_order,append}.
          ... = append(in_order(t), in_order(plug_tree(drop_ctx(ctx'), tree_node(empty_tree,x,R))))
                   by rewrite IH[tree_node(empty_tree,x,R)]
                      rewrite append_assoc[E][in_order(t)][in_order(tree_node(empty_tree,x,R)), in_order(plug_tree(drop_ctx(ctx'),empty_tree))].
      }
    }      
  }
end

/*
take_ctx(ctx)[empty_tree], A, x, B, drop_ctx(ctx)[empty_tree]

next_up(ctx, tree_node(A, x, B)) = treeZip(ctx', tree_node(C, y, D))

take_ctx(ctx')[empty_tree], C, y, D, drop_ctx(ctx')


take_ctx(ctx)[empty_tree], A, x, B
  = take_ctx(ctx')[empty_tree], C

drop_ctx(ctx)[empty_tree]
  = y, D, drop_ctx(ctx')[empty_tree]

*/
/*
theorem next_up_correct: all E:type. all ctx:List<Frame<E>>. all A:Tree<E>, x:E, B:Tree<E>.
  if 0 < tree_nodes(plug_tree(drop_ctx(ctx), empty_tree))
  then some ctx':List<Frame<E>>, C:Tree<E>, y:E, D:Tree<E>.
       next_up(ctx, tree_node(A, x, B)) = treeZip(ctx', tree_node(C, y, D))
  and append(in_order(plug_tree(take_ctx(ctx), empty_tree)), append(in_order(A), node(x, in_order(B))))
    = append(in_order(plug_tree(take_ctx(ctx'), empty_tree)), in_order(C))
  and in_order(plug_tree(drop_ctx(ctx), empty_tree))
    = node(y, append(in_order(D), in_order(plug_tree(drop_ctx(ctx'), empty_tree))))
proof
  arbitrary E:type
  induction List<Frame<E>>
  case empty {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    definition {plug_tree, drop_ctx, tree_nodes}
    suppose prem
    conclude false  by apply less_irreflexive[0] to prem
  }
  case node(f, next_ctx) suppose IH {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    switch f {
      case leftF(L, z) {
        suppose prem
        have prem2: 0 < tree_nodes(plug_tree(drop_ctx(next_ctx),empty_tree))
          by definition {drop_ctx} in prem
        obtain ctx', C, y, D where eqs from (apply IH[L, z, tree_node(A, x, B)] to prem2)
        choose ctx', C, y, D
        have part1: next_up(node(leftF(L,z),next_ctx), tree_node(A,x,B))
                  = treeZip(ctx',tree_node(C,y,D))
                  by definition {next_up}
                     conjunct 0 of eqs
        have eqn2: append(in_order(plug_tree(take_ctx(next_ctx),empty_tree)), append(in_order(L),node(z,in_order(tree_node(A,x,B)))))
                 = append(in_order(plug_tree(take_ctx(ctx'),empty_tree)), in_order(C))
          by conjunct 1 of eqs
        have part2: append(in_order(plug_tree(take_ctx(node(leftF(L,z),next_ctx)),empty_tree)),append(in_order(A),node(x,in_order(B))))
                  = append(in_order(plug_tree(take_ctx(ctx'),empty_tree)),in_order(C)) by
          equations
                append(in_order(plug_tree(take_ctx(node(leftF(L,z),next_ctx)),empty_tree)),append(in_order(A),node(x,in_order(B))))
              = append(in_order(plug_tree(take_ctx(next_ctx),tree_node(L,z,empty_tree))),append(in_order(A),node(x,in_order(B))))
                 by definition {take_ctx, plug_tree}.
          ... = append(append( in_order(plug_tree(take_ctx(next_ctx),empty_tree)), in_order(tree_node(L,z,empty_tree))),
                       append(in_order(A),node(x,in_order(B))))
                 by rewrite in_order_plug_take[E][next_ctx][tree_node(L,z,empty_tree)].
          ... = append(append( in_order(plug_tree(take_ctx(next_ctx),empty_tree)), append(in_order(L), node(z,empty))),
                       append(in_order(A),node(x,in_order(B))))
                by definition {in_order, in_order}.
          ... = append(in_order(plug_tree(take_ctx(next_ctx),empty_tree)),
                       append( append(in_order(L), node(z,empty)), append(in_order(A),node(x,in_order(B)))))
                by rewrite append_assoc[E][in_order(plug_tree(take_ctx(next_ctx),empty_tree))]
                           [append(in_order(L), node(z,empty)), append(in_order(A),node(x,in_order(B)))].
          ... = append(in_order(plug_tree(take_ctx(next_ctx),empty_tree)),
                       append( in_order(L), node(z, append(in_order(A),node(x,in_order(B))))))
                by rewrite append_assoc[E][in_order(L)][node(z, empty), append(in_order(A),node(x,in_order(B)))] definition {append, append}.
          ... = append(in_order(plug_tree(take_ctx(ctx'),empty_tree)), in_order(C))
                 by rewrite (definition {in_order} in eqn2).
        have eqn3: in_order(plug_tree(drop_ctx(next_ctx),empty_tree))
                 = node(y,append(in_order(D),in_order(plug_tree(drop_ctx(ctx'),empty_tree))))
          by conjunct 2 of eqs
        have part3: in_order(plug_tree(drop_ctx(node(leftF(L,z),next_ctx)),empty_tree))
                  = node(y,append(in_order(D),in_order(plug_tree(drop_ctx(ctx'),empty_tree))))
                  by definition {drop_ctx}
                     rewrite eqn3.
        part1, part2, part3       
      }
      case rightF(z, R) {
        suppose prem
        definition {next_up}
        choose next_ctx, tree_node(A,x,B), z, R
        have aa: treeZip(next_ctx,tree_node(tree_node(A,x,B),z,R)) = treeZip(next_ctx,tree_node(tree_node(A,x,B),z,R))
          by .
        have bb: append(in_order(plug_tree(take_ctx(node(rightF(z,R),next_ctx)),empty_tree)),append(in_order(A),node(x,in_order(B))))
               = append(in_order(plug_tree(take_ctx(next_ctx),empty_tree)),in_order(tree_node(A,x,B)))
                 by definition {take_ctx, in_order}.
        have cc: in_order(plug_tree(drop_ctx(node(rightF(z,R),next_ctx)),empty_tree))
               = node(z,append(in_order(R),in_order(plug_tree(drop_ctx(next_ctx),empty_tree))))
               by definition {drop_ctx, plug_tree}
                  definition {in_order, in_order, append} in
                  in_order_plug_drop[E][next_ctx][tree_node(empty_tree,z,R)]
        (aa, bb, cc)
      }
    }
  }
end
*/

theorem next_up_stable: all E:type. all ctx:List<Frame<E>>. all A:Tree<E>, y:E, B:Tree<E>.
  plug_tree(ctx, tree_node(A,y,B)) = zip2tree(next_up(ctx, A, y, B))
proof
  arbitrary E:type
  induction List<Frame<E>>
  case empty {
    arbitrary A:Tree<E>, y:E, B:Tree<E>
    definition {plug_tree, next_up, zip2tree}.
  }
  case node(f, ctx') suppose IH {
    arbitrary A:Tree<E>, y:E, B:Tree<E>
    definition {plug_tree, next_up}
    switch f {
      case leftF(L, x) {
        IH[L,x,tree_node(A,y,B)]
      }
      case rightF(x, R) {
        definition zip2tree.
      }
    }
  }
end

lemma tree_nodes_plug: all E:type. all ctx:List<Frame<E>>. all t:Tree<E>.
  tree_nodes(plug_tree(ctx, t)) = tree_nodes(plug_tree(ctx, empty_tree)) + tree_nodes(t)
proof  
  arbitrary E:type
  induction List<Frame<E>>
  case empty {
    arbitrary t:Tree<E>
    conclude tree_nodes(plug_tree(empty,t)) = tree_nodes(plug_tree(empty,empty_tree)) + tree_nodes(t)
        by definition {plug_tree, tree_nodes, operator+}.
  }
  case node(f, ctx') suppose IH {
    arbitrary t:Tree<E>
    switch f {
      case leftF(L, x) {
        definition {plug_tree, tree_nodes}
        rewrite IH[tree_node(L,x,t)]
        rewrite IH[tree_node(L,x,empty_tree)]
        definition {tree_nodes, tree_nodes}
        rewrite add_zero[tree_nodes(L)]
        rewrite add_assoc[tree_nodes(plug_tree(ctx',empty_tree))][suc(tree_nodes(L)), tree_nodes(t)]
        definition {operator+}.
      }
      case rightF(x, R) {
        definition {plug_tree, tree_nodes}
        rewrite IH[tree_node(t,x,R)]
        rewrite IH[tree_node(empty_tree,x,R)]
        definition {tree_nodes, tree_nodes, operator+}
        rewrite add_assoc[tree_nodes(plug_tree(ctx',empty_tree))][suc(tree_nodes(R)), tree_nodes(t)]
        definition {operator+}
        rewrite add_commute[tree_nodes(R)][tree_nodes(t)].
      }
    }
  }
end

lemma next_up_index: all E:type. all ctx:List<Frame<E>>. all A:Tree<E>, x:E, B:Tree<E>.
  if suc(zip_index(treeZip(ctx, A,x,B)) + tree_nodes(B)) < tree_nodes(zip2tree(treeZip(ctx, A,x,B)))
  then zip_index(next_up(ctx, A, x, B)) = suc(zip_index(treeZip(ctx, A,x,B)) + tree_nodes(B))
proof
  arbitrary E:type
  induction List<Frame<E>>
  case empty {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    suppose prem
    conclude false
      by apply less_irreflexive
         to definition {zip_index, take_ctx, plug_tree, tree_nodes, operator+, zip2tree} in prem
  }
  case node(f, ctx') suppose IH {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    suppose prem
    switch f {
      case leftF(L, y) suppose f_eq {
        definition {next_up, zip_index, take_ctx, plug_tree}
        have prem2: suc(zip_index(treeZip(ctx',L,y,tree_node(A,x,B))) + tree_nodes(tree_node(A,x,B)))
                    < tree_nodes(zip2tree(treeZip(ctx',L,y,tree_node(A,x,B))))
          by  definition {zip_index, tree_nodes, zip2tree}
              rewrite tree_nodes_plug[E][ctx'][tree_node(L,y,tree_node(A,x,B))]
              definition {tree_nodes, tree_nodes}
              rewrite symmetric add_suc[(tree_nodes(plug_tree(take_ctx(ctx'),empty_tree)) + tree_nodes(L))]
                                       [(tree_nodes(A) + tree_nodes(B))] in
              definition operator+ in                                      
              rewrite add_assoc[suc(tree_nodes(plug_tree(take_ctx(ctx'),empty_tree)) + tree_nodes(L))]
                               [tree_nodes(A), tree_nodes(B)] in
              rewrite add_suc[tree_nodes(plug_tree(take_ctx(ctx'),empty_tree))][tree_nodes(L)] in
              rewrite add_zero[tree_nodes(L)] in
              definition {tree_nodes, tree_nodes} in
              rewrite tree_nodes_plug[E][ctx'][tree_node(L,y,tree_node(A,x,B))] in
              definition {tree_nodes, tree_nodes} in
              rewrite tree_nodes_plug[E][take_ctx(ctx')][tree_node(L, y, empty_tree)] in
              definition {zip_index, take_ctx, plug_tree, zip_index, zip2tree} in rewrite f_eq in prem
        rewrite apply IH[L,y,tree_node(A,x,B)] to prem2
        definition {zip_index, tree_nodes}
        rewrite tree_nodes_plug[E][take_ctx(ctx')][tree_node(L,y,empty_tree)]
        definition {tree_nodes, tree_nodes}
        rewrite add_zero[tree_nodes(L)]
        define X = tree_nodes(plug_tree(take_ctx(ctx'),empty_tree))
        define Y = tree_nodes(L)
        define Z = tree_nodes(A)
        define W = tree_nodes(B)
        have eq: suc((X + Y) + suc(Z + W)) = suc(((X + suc(Y)) + Z) + W) by
          equations
                suc((X + Y) + suc(Z + W))
              = suc(suc(X + Y) + (Z + W))      by rewrite add_suc[X+Y][Z+W] definition operator+.
          ... = suc(suc((X + Y) + (Z + W)))    by definition operator+.
          ... = suc(suc(((X + Y) + Z) + W))    by rewrite add_assoc[X+Y][Z,W].
          ... = suc(suc((X + Y) + Z) + W)      by definition operator+.
          ... = suc((suc(X + Y) + Z) + W)      by definition operator+.
          ... = suc(((X + suc(Y)) + Z) + W)    by rewrite add_suc[X][Y].
        rewrite (definition {X,Y,Z,W} in eq).
      }
      case rightF(y, R) {
      definition {next_up, zip_index, tree_nodes, take_ctx}
      define X = tree_nodes(plug_tree(take_ctx(ctx'),empty_tree))
      define Y = tree_nodes(A)
      define Z = tree_nodes(B)
      have eq: X + suc(Y + Z) = suc((X + Y) + Z)
          by rewrite add_suc[X][Y+Z] rewrite add_assoc[X][Y,Z].
      rewrite (definition {X,Y,Z} in eq).
      }
    }
  }
end

lemma first_ctx_index: all E:type. all A:Tree<E>. all y:E, B:Tree<E>, ctx:List<Frame<E>>.
  zip_index(first_ctx(A,y,B, ctx)) = tree_nodes(plug_tree(take_ctx(ctx), empty_tree))
proof
  arbitrary E:type
  induction Tree<E>
  case empty_tree {
    arbitrary y:E, B:Tree<E>, ctx:List<Frame<E>>
    definition {first_ctx, tree_nodes, zip_index}
    rewrite add_zero[tree_nodes(plug_tree(take_ctx(ctx),empty_tree))].
  }
  case tree_node(L, x, R) suppose IH {
    arbitrary y:E, B:Tree<E>, ctx:List<Frame<E>>
    definition {first_ctx}
    switch L {
      case empty_tree suppose L_eq {
        definition {zip_index, tree_nodes, first_ctx}
        rewrite add_zero[tree_nodes(plug_tree(take_ctx(ctx),empty_tree))]
        rewrite add_zero[tree_nodes(plug_tree(take_ctx(node(rightF(y,B),ctx)),empty_tree))]
        definition {take_ctx}.
      }
      case tree_node(LL, z, LR) suppose L_eq {
        rewrite symmetric L_eq
        have IH2: zip_index(first_ctx(L,x,R,node(rightF(y,B),ctx)))
                = tree_nodes(plug_tree(take_ctx(node(rightF(y,B),ctx)),empty_tree))
            by IH[x, R, node(rightF(y,B),ctx)]
        definition {first_ctx}
        rewrite IH2
        definition take_ctx.
      }
    }
  }
end

theorem zip_next_index: all E:type, z : TreeZipper<E>.
  if suc(zip_index(z)) < tree_nodes(zip2tree(z)) and 0 < tree_nodes(focus(z))
  then zip_index(zip_next(z)) = suc(zip_index(z))
proof
  arbitrary E:type, z : TreeZipper<E>
  suppose prem
  switch z {
    case treeZip(ctx, L, x, R) suppose z_eq {
      definition {zip_next}
      switch R {
        case empty_tree suppose R_eq {
          have prem2: suc(zip_index(treeZip(ctx,L,x,empty_tree)) + tree_nodes(empty_tree))
                < tree_nodes(zip2tree(treeZip(ctx,L,x,empty_tree)))
            by definition {tree_nodes} rewrite add_zero[zip_index(treeZip(ctx,L,x,empty_tree))]
               definition {tree_nodes} in rewrite z_eq | R_eq in prem
          rewrite add_zero[zip_index(treeZip(ctx,L,x,empty_tree))] in
          definition tree_nodes in
          apply next_up_index[E][ctx][L, x, empty_tree] to prem2
        }
        case tree_node(RL, y, RR) suppose R_eq {
          definition{zip_index}
          rewrite first_ctx_index[E][RL][y,RR,node(leftF(L,x),ctx)]
          definition {take_ctx, plug_tree}
          rewrite tree_nodes_plug[E][take_ctx(ctx)][tree_node(L,x,empty_tree)]
          definition {tree_nodes, tree_nodes}
          rewrite add_zero[tree_nodes(L)]
          rewrite add_suc[tree_nodes(plug_tree(take_ctx(ctx),empty_tree))][tree_nodes(L)].
        }
      }
    }
  }
end

theorem length_in_order: all E:type. all t:Tree<E>.
  length(in_order(t)) = tree_nodes(t)
proof
  sorry
end

lemma nth_in_order_plug: all E:type. all ctx:List<Frame<E>>. all L:Tree<E>, x:E, R:Tree<E>, a:E.
  nth(in_order(plug_tree(ctx,tree_node(L,x,R))),a)(tree_nodes(plug_tree(take_ctx(ctx),empty_tree)) + tree_nodes(L)) = x
proof
  arbitrary E:type
  induction List<Frame<E>>
  case empty {
    arbitrary L:Tree<E>, x:E, R:Tree<E>, a:E
    definition {plug_tree, in_order, take_ctx, tree_nodes, operator+}
    have eq: nth(append(in_order(L),node(x,in_order(R))),a)(tree_nodes(L)) = nth(node(x,in_order(R)),a)(0)
      by rewrite length_in_order[E][L] in
         rewrite add_zero[length(in_order(L))] in nth_append_back[E][in_order(L)][node(x, in_order(R)), 0, a]
    rewrite eq
    definition nth.
  }
  case node(f, ctx') suppose IH {
    ?
  }
end

theorem zip_index_get_in_order: all E:type, z:TreeZipper<E>, a:E.
  zip_get(z) = nth(in_order(zip2tree(z)), a)(zip_index(z))
proof
  arbitrary E:type, z:TreeZipper<E>, a:E
  switch z {
    case treeZip(ctx, L, x, R) {
      definition {zip2tree, zip_get, zip_index}
      ?
    }
  }
end