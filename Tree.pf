import Option
import Nat
import List

union Tree<E> {
  EmptyTree
  TreeNode(Tree<E>, E, Tree<E>)
}

function num_nodes<E>(Tree<E>) -> Nat {
  num_nodes(EmptyTree) = 0
  num_nodes(TreeNode(L, x, R)) = suc(num_nodes(L) + num_nodes(R))
}

function height<E>(Tree<E>) -> Nat {
  height(EmptyTree) = 0
  height(TreeNode(L, x, R)) = suc(max(height(L), height(R)))
}

function in_order<E>(Tree<E>) -> List<E> {
  in_order(EmptyTree) = empty
  in_order(TreeNode(L, x, R)) =
    append(in_order(L), node(x, in_order(R)))
}

union Direction<E> {
  RightD(Tree<E>, E)
  LeftD(E,Tree<E>)
}

union TreeIter<E> {
  TrItr(List<Direction<E>>, Tree<E>, E, Tree<E>)
}

function ti2tree<E>(TreeIter<E>) -> Tree<E> {
  ti2tree(TrItr(ctx, L, x, R)) = plug_tree(ctx, TreeNode(L, x, R))
}

function ti_get<E>(TreeIter<E>) -> E {
  ti_get(TrItr(ctx, L, x, R)) = x
}

function first_ctx<E>(Tree<E>, E, Tree<E>, List<Direction<E>>) -> TreeIter<E> {
  first_ctx(EmptyTree, x, R, ctx) = TrItr(ctx, EmptyTree, x, R)
  first_ctx(TreeNode(LL, y, LR), x, R, ctx) = first_ctx(LL, y, LR, node(LeftD(x, R), ctx))
}

define ti_first : < E > fn Tree<E>,E,Tree<E> -> TreeIter<E>
    = λ L,x,R { first_ctx(L, x, R, empty) }

function next_up<E>(List<Direction<E>>, Tree<E>, E, Tree<E>) -> TreeIter<E> {
  next_up(empty, A, z, B) = TrItr(empty, A, z, B)
  next_up(node(f, ctx'), A, z, B) =
    switch f {
      case RightD(L, x) {
        next_up(ctx', L, x, TreeNode(A, z, B))
      }
      case LeftD(x, R) {
        TrItr(ctx', TreeNode(A, z, B), x, R)
      }
    }
}

function ti_next<E>(TreeIter<E>) -> TreeIter<E> {
  ti_next(TrItr(ctx, L, x, R)) =
    switch R {
      case EmptyTree {
        next_up(ctx, L, x, R)
      }
      case TreeNode(RL, y, RR) {
        first_ctx(RL, y, RR, node(RightD(L, x), ctx))
      }
    }
}

function plug_tree<E>(List<Direction<E>>, Tree<E>) -> Tree<E> {
  plug_tree(empty, t) = t
  plug_tree(node(f, ctx'), t) =
    switch f {
      case RightD(L, x) {
        plug_tree(ctx', TreeNode(L, x, t))
      }
      case LeftD(x, R) {
        plug_tree(ctx', TreeNode(t, x, R))
      }
    }
}

function take_ctx<E>(List<Direction<E>>) -> List<Direction<E>> {
  take_ctx(empty) = empty
  take_ctx(node(f, ctx')) =
    switch f {
      case RightD(L, x) {
        node(RightD(L,x), take_ctx(ctx'))
      }
      case LeftD(x, R) {
        take_ctx(ctx')
      }
    }
}

function drop_ctx<E>(List<Direction<E>>) -> List<Direction<E>> {
  drop_ctx(empty) = empty
  drop_ctx(node(f, ctx')) =
    switch f {
      case RightD(L, x) {
        drop_ctx(ctx')
      }
      case LeftD(x, R) {
        node(LeftD(x, R), drop_ctx(ctx'))
      }
    }
}

function ti_take<E>(TreeIter<E>) -> Tree<E> {
  ti_take(TrItr(ctx, L, x, R)) = plug_tree(take_ctx(ctx), L)
}

define ti_index : < E > fn(TreeIter<E>) -> Nat = λ z { num_nodes(ti_take(z))}
