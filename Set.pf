/*
Represent sets as predicates, that is, functions to bool.
*/

import Base

union Set<T> {
  char_fun(fn(T) -> bool)
}

/*
  The Deduce parser translates
  ∅
  into
  char_fun(λx{false})
*/

function rep<T>(Set<T>) -> fn(T)->bool {
  rep(char_fun(f)) = f
}

define single : < T > fn T -> Set<T>
         = generic T { λx { char_fun(λy{x = y}) } }

define operator ∪ : < T > fn Set<T>, Set<T> -> Set<T>
         = generic T { λP,Q{ char_fun(λx{ rep(P)(x) or rep(Q)(x) }) } }

define operator ∩ : < T > fn Set<T>, Set<T> -> Set<T>
         = generic T { λP,Q{ char_fun(λx{ rep(P)(x) and rep(Q)(x) }) } }

define operator ∈ : < T > fn T, Set<T> -> bool
         = generic T { λx,S{ rep(S)(x) } }

define operator ⊆ : < T > fn Set<T>, Set<T> -> bool
         = generic T { λP,Q{all x:T. if x ∈ P then x ∈ Q} }

theorem single_member: all T:type, x:T.  x ∈ single(x)
proof
  arbitrary T:type, x:T
  definition {single, operator ∈, rep}.
end

theorem single_equal: all T:type, x:T, y:T.
    if y ∈ single(x) then x = y
proof
  arbitrary T:type, x:T, y:T
  suppose y_in_x: y ∈ single(x)
  enable {operator ∈, single, rep}
  y_in_x
end

theorem empty_no_members: all T:type, x:T.
  not (x ∈ char_fun(λx{false}))
proof
  arbitrary T:type, x:T
  suppose x_in_empty: x ∈ char_fun(λx{false})
  enable {operator ∈, rep}
  x_in_empty
end

theorem member_union: all T:type, x:T, A:Set<T>, B:Set<T>.
  if x ∈ (A ∪ B)
  then x ∈ A or x ∈ B
proof
  arbitrary T:type, x:T, A:Set<T>, B:Set<T>
  suppose x_AB: x ∈ (A ∪ B)
  enable {operator ∈, operator ∪, rep}
  x_AB
end

theorem union_empty: all T:type, A:Set<T>.
  A ∪ ∅ = A
proof
  arbitrary T:type, A:Set<T>
  definition {operator ∪, rep, char_fun}
  switch A {
    case char_fun(f) {
      have eq: (λx{f(x) or false} : fn T->bool) = f
        by extensionality arbitrary x:T
	   definition {}.
      rewrite eq.
    }
  }
end

theorem empty_union: all T:type, A:Set<T>.
  char_fun(λx{false} : fn T->bool) ∪ A = A
proof
  arbitrary T:type, A:Set<T>
  definition {operator ∪, rep, char_fun}
  switch A {
    case char_fun(f) {
      have eq: (λx{f(x) or false} : fn T->bool) = f
        by extensionality arbitrary x:T
	   definition {}.
      rewrite eq.
    }
  }
end

theorem union_sym: all T:type, A:Set<T>, B:Set<T>.
  A ∪ B = B ∪ A
proof
  arbitrary T:type, A:Set<T>, B:Set<T>
  definition {operator ∪}
  switch A {
    case char_fun(f) {
      switch B {
	case char_fun(g) {
	  definition rep
	  have fg_gf: (λx{(f(x) or g(x))} : fn T->bool) = λx{(g(x) or f(x))}
	    by extensionality arbitrary x:T definition{}
	       rewrite or_sym[f(x),g(x)].
	  rewrite fg_gf.
	}
      }
    }
  }
end

theorem union_assoc: all T:type, A:Set<T>, B:Set<T>, C:Set<T>.
  (A ∪ B) ∪ C = A ∪ (B ∪ C)
proof
  arbitrary T:type, A:Set<T>, B:Set<T>, C:Set<T>
  definition {operator ∪}
  switch A {
    case char_fun(f) {
      switch B {
	case char_fun(g) {
	  switch C {
	    case char_fun(h) {
	      definition rep
	      have fgh_eq: (λx{(f(x) or g(x)) or h(x)} : fn T->bool)
	                 = λx{f(x) or (g(x) or h(x))}
	        by extensionality arbitrary x:T
		   definition {}.
              rewrite fgh_eq.
	    }
	  }
	}
      }
    }
  }
end

theorem in_left_union:
  all T:type, x:T, A: Set<T>, B:Set<T>.
  if x ∈ A then x ∈ (A ∪ B)
proof
  arbitrary T:type, x:T, A: Set<T>, B:Set<T>
  suppose x_A: x ∈ A
  definition {operator ∈, operator ∪, rep}
  definition operator ∈ in x_A
end

theorem in_right_union:
  all T:type, x:T, A: Set<T>, B:Set<T>.
  if x ∈ B then x ∈ (A ∪ B)
proof
  arbitrary T:type, x:T, A: Set<T>, B:Set<T>
  suppose x_B: x ∈ B
  definition {operator ∈, operator ∪, rep}
  definition operator ∈ in x_B
end

/*
  UNDER CONSTRUCTION
  need to fix generics, implement type passing
theorem subset_equal:
  all T:type, A:Set<T>, B:Set<T>.
  if A ⊆ B and B ⊆ A
  then A = B
proof
  arbitrary U:type, A:Set<U>, B:Set<U>
  suppose prem
  switch A {
    case char_fun(f) suppose A_f {
      switch B {
        case char_fun(g) suppose B_g {
          have f_g: f = g
	    by extensionality
	       arbitrary x:U
               have fx_to_gx: if f(x) then g(x)
                  by (definition operator ⊆ in (conjunct 0 of prem))
               apply iff_equal[f(x),g(x)]
               to ?
          rewrite f_g.
	}
      }
    }
  }
end
*/
