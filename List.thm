This file was automatically generated by Deduce.
This file summarizes the theorems proved in the file:
	./List.pf

length_one_nat: (all x:Nat. length(node(x, empty)) = 1)

length_one: (all U:type. (all x:U. length(node(x, empty)) = 1))

length_zero_empty: (all T:type. (all xs:List<T>. (if length(xs) = 0 then xs = empty)))

length_append: (all U:type. (all xs:List<U>. (all ys:List<U>. length(xs ++ ys) = length(xs) + length(ys))))

append_assoc: (all U:type. (all xs:List<U>. (all ys:List<U>, zs:List<U>. (xs ++ ys) ++ zs = xs ++ (ys ++ zs))))

append_empty: (all U:type. (all xs:List<U>. xs ++ empty = xs))

length_reverse: (all U:type. (all xs:List<U>. length(reverse(xs)) = length(xs)))

length_map: (all T:type. (all f:(fn T -> T). (all xs:List<T>. length(map(xs, f)) = length(xs))))

map_id: (all T:type. (all f:(fn T -> T). (if (all x:T. f(x) = x) then (all xs:List<T>. map(xs, f) = xs))))

map_append: (all T:type. (all f:(fn T -> T), ys:List<T>. (all xs:List<T>. map(xs ++ ys, f) = map(xs, f) ++ map(ys, f))))

map_compose: (all T:type, U:type, V:type. (all f:(fn T -> U), g:(fn U -> V). (all ls:List<T>. map(map(ls, f), g) = map(ls, g ∘ f))))

zip_id_right: (all T:type, U:type. (all xs:List<T>. zip(xs, empty) = empty))

zip_map: (all T1:type, T2:type, U1:type, U2:type. (all f:(fn T1 -> T2), g:(fn U1 -> U2). (all xs:List<T1>. (all ys:List<U1>. zip(map(xs, f), map(ys, g)) = map(zip(xs, ys), pairfun(f, g))))))

filter_all: (all T:type. (all P:(fn T -> bool). (all xs:List<T>. (if all_elements(xs, P) then filter(xs, P) = xs))))

all_elements_implies_member: (all T:type. (all xs:List<T>. (all P:(fn T -> bool). (if all_elements(xs, P) then (all x:T. (if x ∈ set_of(xs) then P(x)))))))

member_implies_all_elements: (all T:type. (all xs:List<T>. (all P:(fn T -> bool). (if (all x:T. (if x ∈ set_of(xs) then P(x))) then all_elements(xs, P)))))

all_elements_eq_member: (all T:type. (all xs:List<T>, P:(fn T -> bool). all_elements(xs, P) = (all x:T. (if x ∈ set_of(xs) then P(x)))))

all_elements_implies: (all T:type. (all xs:List<T>. (all P:(fn T -> bool), Q:(fn T -> bool). (if (all_elements(xs, P) and (all z:T. (if P(z) then Q(z)))) then all_elements(xs, Q)))))

set_of_empty: (all T:type. (all xs:List<T>. (if set_of(xs) = char_fun(λ_{false}) then xs = empty)))

mset_of_empty: (all T:type. (all xs:List<T>. (if mset_of(xs) = m_fun(λx{0}) then xs = empty)))

som_mset_eq_set: (all T:type. (all xs:List<T>. set_of_mset(mset_of(xs)) = set_of(xs)))

remove_all_absent: (all T:type. (all xs:List<T>. (all y:T. not (y ∈ set_of(remove_all(xs, y))))))

all_elements_member: (all T:type. (all ys:List<T>. (all x:T, P:(fn T -> bool). (if (all_elements(ys, P) and x ∈ set_of(ys)) then P(x)))))

all_elements_set_of: (all T:type. (all xs:List<T>, ys:List<T>, P:(fn T -> bool). (if set_of(xs) = set_of(ys) then all_elements(xs, P) = all_elements(ys, P))))

set_of_append: (all T:type. (all xs:List<T>. (all ys:List<T>. set_of(xs ++ ys) = set_of(xs) ∪ set_of(ys))))

all_elements_append: (all T:type. (all xs:List<T>. (all ys:List<T>, P:(fn T -> bool). (if (all_elements(xs, P) and all_elements(ys, P)) then all_elements(xs ++ ys, P)))))

take_append: (all E:type. (all xs:List<E>. (all ys:List<E>. take(length(xs), xs ++ ys) = xs)))

nth_drop: (all T:type. (all n:Nat. (all xs:List<T>, i:Nat, d:T. nth(drop(n, xs), d)(i) = nth(xs, d)(n + i))))

nth_append_front: (all T:type. (all xs:List<T>. (all ys:List<T>, i:Nat, d:T. (if i < length(xs) then nth(xs ++ ys, d)(i) = nth(xs, d)(i)))))

nth_append_back: (all T:type. (all xs:List<T>. (all ys:List<T>, i:Nat, d:T. nth(xs ++ ys, d)(length(xs) + i) = nth(ys, d)(i))))

rev_app_reverse_append: (all T:type. (all xs:List<T>. (all ys:List<T>. rev_app(xs, ys) = reverse(xs) ++ ys)))

foldr_rev_app_foldl: (all T:type. (all xs:List<T>. (all ys:List<T>, b:T, f:(fn T, T -> T). foldr(rev_app(xs, ys), b, f) = foldl(xs, foldr(ys, b, f), flip(f)))))

flip_flip: (all T:type. (all f:(fn T, T -> T). flip(flip(f)) = f))

foldl_foldr: (all T:type. (all xs:List<T>, b:T, f:(fn T, T -> T). foldl(xs, b, f) = foldr(reverse(xs), b, flip(f))))

mset_equal_implies_set_equal: (all T:type. (all xs:List<T>, ys:List<T>. (if mset_of(xs) = mset_of(ys) then set_of(xs) = set_of(ys))))

head_append: (all E:type. (all L:List<E>. (all R:List<E>. (if 0 < length(L) then head(L ++ R) = head(L)))))

tail_append: (all E:type. (all L:List<E>. (all R:List<E>. (if 0 < length(L) then tail(L ++ R) = tail(L) ++ R))))

left_2list_identity: (all T:type. (all z:ListZipper<T>. zip2list(z) = zip2list(zip_left(z))))

right_2list_identity: (all T:type. (all z:ListZipper<T>. zip2list(z) = zip2list(zip_right(z))))

