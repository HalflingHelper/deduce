import Option
import Nat
import List
import Tree

theorem length_in_order: all E:type. all t:Tree<E>.
  length(in_order(t)) = num_nodes(t)
proof
  arbitrary E:type
  induction Tree<E>
  case EmptyTree {
    _definition {in_order, length, num_nodes}.
  }
  case TreeNode(L, x, R) suppose IH_L, IH_R {
    _definition {in_order, length, num_nodes}
    _rewrite length_append[E][in_order(L)][node(x, in_order(R))]
    _definition {length}
    _rewrite IH_L | IH_R
    _rewrite add_commute[1][num_nodes(R)]
    _rewrite add_commute[1][num_nodes(L) + num_nodes(R)]
    _rewrite add_assoc[num_nodes(L)][num_nodes(R), 1].
  }
end

/* ----------------------------------------------------------
   Theorems about ti_first:

   ti_first_stable: all E:type, A:Tree<E>, x:E, B:Tree<E>.
       ti2tree(ti_first(A, x, B)) = TreeNode(A, x, B)
       
   ti_first_index: all E:type, A:Tree<E>, x:E, B:Tree<E>.
       ti_index(ti_first(A, x, B)) = 0
       
   --------------------------------------------------------- */

lemma first_path_stable:
  all E:type. all A:Tree<E>. all y:E, B:Tree<E>, path:List<Direction<E>>.
  ti2tree(first_path(A, y, B, path)) = plug_tree(path, TreeNode(A, y, B))
proof
  arbitrary E:type
  induction Tree<E>
  case EmptyTree {
    arbitrary y:E, B:Tree<E>, path:List<Direction<E>>
    equations  ti2tree(first_path(EmptyTree,y,B,path))
             = ti2tree(TrItr(path,EmptyTree,y,B))       by _definition first_path.
         ... = plug_tree(path,TreeNode(EmptyTree,y,B))  by _definition ti2tree.
  }
  case TreeNode(L, x, R) suppose IH_L, IH_R {
    arbitrary y:E, B:Tree<E>, path:List<Direction<E>>
    equations
          ti2tree(first_path(TreeNode(L,x,R),y,B,path))
        = ti2tree(first_path(L,x,R,node(LeftD(y,B),path)))
             by _definition first_path.
    ... = plug_tree(node(LeftD(y,B),path),TreeNode(L,x,R))
             by IH_L[x,R,node(LeftD(y,B),path)]
    ... = plug_tree(path,TreeNode(TreeNode(L,x,R),y,B))
             by _definition plug_tree.
  }
end

theorem ti_first_stable: all E:type, A:Tree<E>, x:E, B:Tree<E>.
  ti2tree(ti_first(A, x, B)) = TreeNode(A, x, B)
proof
  arbitrary E:type, A:Tree<E>, x:E, B:Tree<E>
  _definition ti_first
  equations  ti2tree(first_path(A,x,B,empty))
           = plug_tree(empty,TreeNode(A,x,B))  by first_path_stable[E][A][x,B,empty]
       ... = TreeNode(A,x,B)                   by _definition plug_tree.
end

lemma first_path_index: all E:type. all A:Tree<E>. all y:E, B:Tree<E>, path:List<Direction<E>>.
  ti_index(first_path(A,y,B, path)) = num_nodes(plug_tree(take_path(path), EmptyTree))
proof
  arbitrary E:type
  induction Tree<E>
  case EmptyTree {
    arbitrary y:E, B:Tree<E>, path:List<Direction<E>>
    conclude ti_index(first_path(EmptyTree,y,B,path))
           = num_nodes(plug_tree(take_path(path),EmptyTree))
                by _definition {first_path, ti_index, ti_take}.
  }
  case TreeNode(L, x, R) suppose IH {
    arbitrary y:E, B:Tree<E>, path:List<Direction<E>>
    _definition {first_path}
    equations
          ti_index(first_path(L,x,R,node(LeftD(y,B),path)))
        = num_nodes(plug_tree(take_path(node(LeftD(y,B),path)),EmptyTree))
                by IH[x, R, node(LeftD(y,B), path)]
    ... = num_nodes(plug_tree(take_path(path),EmptyTree))
                by _definition take_path.
  }
end

theorem ti_first_index: all E:type, A:Tree<E>, x:E, B:Tree<E>.
  ti_index(ti_first(A, x, B)) = 0
proof
  arbitrary E:type, A:Tree<E>, x:E, B:Tree<E>
  _definition ti_first
  equations  ti_index(first_path(A,x,B,empty))
           = num_nodes(plug_tree(take_path(empty : List<Direction<E>>),EmptyTree))
                       by first_path_index[E][A][x,B,empty]
       ... = 0      by _definition {take_path, plug_tree, num_nodes}.
end

/* ------------------------------------------------------
   Theorems about ti_next:

   ti_next_index: all E:type, z : TreeIter<E>.
       if suc(ti_index(z)) < num_nodes(ti2tree(z))
       then ti_index(ti_next(z)) = suc(ti_index(z))

   ti_next_stable: all E:type, z:TreeIter<E>.
       ti2tree(ti_next(z)) = ti2tree(z)

   ----------------------------------------------------- */

lemma next_up_stable: all E:type. all path:List<Direction<E>>. all A:Tree<E>, y:E, B:Tree<E>.
  plug_tree(path, TreeNode(A,y,B)) = ti2tree(next_up(path, A, y, B))
proof
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary A:Tree<E>, y:E, B:Tree<E>
    _definition {plug_tree, next_up, ti2tree, plug_tree}.
  }
  case node(f, path') suppose IH {
    arbitrary A:Tree<E>, y:E, B:Tree<E>
    _definition {plug_tree, next_up}
    switch f {
      case LeftD(x, R) {
        _definition ti2tree.
      }
      case RightD(L, x) {
        IH[L,x,TreeNode(A,y,B)]
      }
    }
  }
end

lemma num_nodes_plug: all E:type. all path:List<Direction<E>>. all t:Tree<E>.
  num_nodes(plug_tree(path, t)) = num_nodes(plug_tree(path, EmptyTree)) + num_nodes(t)
proof  
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary t:Tree<E>
    conclude num_nodes(plug_tree(empty,t)) = num_nodes(plug_tree(empty,EmptyTree : Tree<E>)) + num_nodes(t)
        by _definition {plug_tree, num_nodes, operator+}.
  }
  case node(f, path') suppose IH {
    arbitrary t:Tree<E>
    switch f {
      case LeftD(x, R) {
        _definition {plug_tree, num_nodes}
        _rewrite IH[TreeNode(t,x,R)]
        _rewrite IH[TreeNode(EmptyTree,x,R)]
        _definition {num_nodes, num_nodes}
        _rewrite zero_add[num_nodes(R)]
        _rewrite add_assoc[num_nodes(plug_tree(path',EmptyTree))][1 + num_nodes(R), num_nodes(t)]
        _rewrite add_assoc[1][num_nodes(R), num_nodes(t)]
        _rewrite add_commute[num_nodes(R)][num_nodes(t)].
      }
      case RightD(L, x) {
        _definition {plug_tree, num_nodes}
        _rewrite IH[TreeNode(L,x,t)]
        _rewrite IH[TreeNode(L,x,EmptyTree)]
        _definition {num_nodes, num_nodes}
        _rewrite add_zero[num_nodes(L)]
        _rewrite add_assoc[num_nodes(plug_tree(path',EmptyTree))][1 + num_nodes(L), num_nodes(t)]
        _rewrite add_assoc[1][num_nodes(L), num_nodes(t)].
      }
    }
  }
end

lemma XYZW_equal: all X:Nat, Y:Nat, Z:Nat, W:Nat.
  suc((X + Y) + suc(Z + W)) = suc((X + suc(Y + Z)) + W)
proof
  arbitrary X:Nat, Y:Nat, Z:Nat, W:Nat
  enable {operator+}
  equations
        suc((X + Y) + suc(Z + W))
      = suc(suc(X + Y) + (Z + W))      by rewrite add_suc[X+Y][Z+W]
  ... = suc(suc(((X + Y) + Z) + W))    by rewrite add_assoc[X+Y][Z,W]
  ... = suc(suc((X + (Y + Z)) + W))    by rewrite add_assoc[X][Y,Z]
  ... = suc((X + suc(Y + Z)) + W)      by rewrite add_suc[X][Y+Z]
end

lemma next_up_index: all E:type. all path:List<Direction<E>>. all A:Tree<E>, x:E, B:Tree<E>.
  if suc(ti_index(TrItr(path, A, x, B)) + num_nodes(B)) < num_nodes(ti2tree(TrItr(path, A, x, B)))
  then ti_index(next_up(path, A, x, B)) = suc(ti_index(TrItr(path, A,x,B)) + num_nodes(B))
proof
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    suppose prem: suc(ti_index(TrItr(empty,A,x,B)) + num_nodes(B)) 
                  < num_nodes(ti2tree(TrItr(empty,A,x,B)))
    have AB_l_AB: suc(num_nodes(A) + num_nodes(B)) < suc(num_nodes(A) + num_nodes(B))
      by definition {ti_index, ti_take, take_path, plug_tree, ti2tree, num_nodes, plug_tree, operator+, operator+} 
         in prem
    conclude false  by apply less_irreflexive to AB_l_AB
  }
  case node(f, path') suppose IH {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    suppose prem
    switch f {
      case LeftD(y, R) {
        suffices num_nodes(plug_tree(take_path(path'),TreeNode(A,x,B))) 
               = suc(num_nodes(plug_tree(take_path(path'),A)) + num_nodes(B))
            with definition {next_up, ti_index, ti_take, take_path}
        suffices num_nodes(plug_tree(take_path(path'),EmptyTree)) + num_nodes(TreeNode(A,x,B)) 
               = suc((num_nodes(plug_tree(take_path(path'),EmptyTree)) + num_nodes(A)) + num_nodes(B))
            with rewrite num_nodes_plug[E][take_path(path')][TreeNode(A,x,B)]
                     | num_nodes_plug[E][take_path(path')][A]
        suffices num_nodes(plug_tree(take_path(path'),EmptyTree)) + suc(num_nodes(A) + num_nodes(B)) 
               = suc((num_nodes(plug_tree(take_path(path'),EmptyTree)) + num_nodes(A)) + num_nodes(B))
            with definition num_nodes
        define_ X = num_nodes(plug_tree(take_path(path'),EmptyTree))
        define_ Y = num_nodes(A)
        define_ Z = num_nodes(B)
        conclude X + suc(Y + Z) = suc((X + Y) + Z)
            by rewrite add_suc[X][Y+Z] | add_assoc[X][Y,Z]
      }
      case RightD(L, y) suppose f_eq {
        suffices ti_index(next_up(path',L,y,TreeNode(A,x,B))) 
               = suc(ti_index(TrItr(node(RightD(L,y),path'),A,x,B)) + num_nodes(B))
            with definition next_up
        have IH_prem: suc(num_nodes(plug_tree(take_path(path'),L)) 
                          + suc(num_nodes(A) + num_nodes(B))) 
                      < num_nodes(plug_tree(path',TreeNode(L,y,TreeNode(A,x,B))))
          by suffices suc((num_nodes(plug_tree(take_path(path'),EmptyTree)) + num_nodes(L)) 
                          + suc(num_nodes(A) + num_nodes(B))) 
                      < num_nodes(plug_tree(path',EmptyTree)) + num_nodes(TreeNode(L,y,TreeNode(A,x,B)))
                 with rewrite num_nodes_plug[E][take_path(path')][L]
                          | num_nodes_plug[E][path'][TreeNode(L,y,TreeNode(A,x,B))]
             suffices suc((num_nodes(plug_tree(take_path(path'),EmptyTree)) + num_nodes(L)) 
                          + suc(num_nodes(A) + num_nodes(B))) 
                      < num_nodes(plug_tree(path',EmptyTree)) + suc(num_nodes(L) + suc(num_nodes(A) + num_nodes(B)))
                 with definition {num_nodes, num_nodes}
             define_ X = num_nodes(plug_tree(take_path(path'),EmptyTree))
             define_ Y = num_nodes(L) define_ Z = num_nodes(A) define_ W = num_nodes(B)
             define_ P = num_nodes(plug_tree(path',EmptyTree))
             suffices suc((X + Y) + suc(Z + W)) < P + suc(Y + suc(Z + W))  by .
             have prem2: suc((X + suc(Y + Z)) + W) < P + suc(Y + suc(Z + W))
               by enable {X,Y,Z,W,P}
                  definition {num_nodes, num_nodes} in
                  rewrite num_nodes_plug[E][take_path(path')][TreeNode(L,y,A)]
                        | num_nodes_plug[E][path'][TreeNode(L,y,TreeNode(A,x,B))] in
                  definition {ti_index, ti_take, take_path, ti2tree, plug_tree} in
                  rewrite f_eq in prem
             suffices suc((X + suc(Y + Z)) + W) < P + suc(Y + suc(Z + W))
                 with rewrite XYZW_equal[X,Y,Z,W]
             prem2
        equations
              ti_index(next_up(path',L,y,TreeNode(A,x,B))) 
            = suc(ti_index(TrItr(path',L,y,TreeNode(A,x,B))) + num_nodes(TreeNode(A,x,B)))
                by apply IH[L,y,TreeNode(A,x,B)] 
                   to _definition {ti_index, ti_take, num_nodes, ti2tree} IH_prem
        ... = suc(num_nodes(plug_tree(take_path(path'),L)) + suc(num_nodes(A) + num_nodes(B)))
              by definition {ti_index, ti_take, num_nodes}
        ... = suc((num_nodes(plug_tree(take_path(path'),EmptyTree)) + num_nodes(L))
                  + suc(num_nodes(A) + num_nodes(B)))
              by rewrite num_nodes_plug[E][take_path(path')][L]
        ... = suc((num_nodes(plug_tree(take_path(path'),EmptyTree)) 
                  + suc(num_nodes(L) + num_nodes(A))) + num_nodes(B))
              by define_ X = num_nodes(plug_tree(take_path(path'),EmptyTree))
                 define_ Y = num_nodes(L) define_ Z = num_nodes(A) define_ W = num_nodes(B)
                 define_ P = num_nodes(plug_tree(path',EmptyTree))
                 conclude suc((X + Y) + suc(Z + W)) = suc((X + suc(Y + Z)) + W)
                     by XYZW_equal[X,Y,Z,W]
        ... = suc(num_nodes(plug_tree(take_path(path'),TreeNode(L,y,A))) + num_nodes(B))
              by _rewrite num_nodes_plug[E][take_path(path')][TreeNode(L,y,A)]
                 definition {num_nodes, num_nodes}
        ... = suc(ti_index(TrItr(node(RightD(L,y),path'),A,x,B)) + num_nodes(B))
              by definition {ti_index, ti_take, take_path, plug_tree}
      }
    }
  }
end

theorem ti_next_index: all E:type, iter : TreeIter<E>.
  if suc(ti_index(iter)) < num_nodes(ti2tree(iter))
  then ti_index(ti_next(iter)) = suc(ti_index(iter))
proof
  arbitrary E:type, iter : TreeIter<E>
  suppose prem: suc(ti_index(iter)) < num_nodes(ti2tree(iter))
  switch iter {
    case TrItr(path, L, x, R) suppose iter_eq {
      _definition ti_next
      switch R {
        case EmptyTree suppose R_eq {
          have next_up_index_prem:
              suc(ti_index(TrItr(path,L,x,EmptyTree)) + num_nodes(EmptyTree : Tree<E>))
              < num_nodes(ti2tree(TrItr(path,L,x,EmptyTree)))
            by enable num_nodes
               _rewrite add_zero[ti_index(TrItr(path,L,x,EmptyTree))]
               rewrite iter_eq | R_eq in prem
          equations
                ti_index(next_up(path,L,x,EmptyTree))
              = suc(ti_index(TrItr(path,L,x,EmptyTree)) + num_nodes(EmptyTree : Tree<E>))
                by apply next_up_index[E][path][L, x, EmptyTree] to next_up_index_prem
          ... = suc(ti_index(TrItr(path,L,x,EmptyTree)))
                by _definition num_nodes
                   rewrite add_zero[ti_index(TrItr(path,L,x,EmptyTree))]
        }
        case TreeNode(RL, y, RR) suppose R_eq {
          _rewrite first_path_index[E][RL][y,RR,node(RightD(L,x),path)]
          _definition {take_path, plug_tree, ti_index, ti_take}
          _rewrite num_nodes_plug[E][take_path(path)][TreeNode(L,x,EmptyTree)]
          _definition {num_nodes, num_nodes}
          _rewrite num_nodes_plug[E][take_path(path)][L]
          _rewrite add_zero[num_nodes(L)]
          _definition {operator+, operator+}
          _rewrite add_suc[num_nodes(plug_tree(take_path(path),EmptyTree))][num_nodes(L)].
        }
      }
    }
  }
end

theorem ti_next_stable: all E:type, iter:TreeIter<E>.
  ti2tree(ti_next(iter)) = ti2tree(iter)
proof
  arbitrary E:type, iter:TreeIter<E>
  switch iter {
    case TrItr(path, L, x, R) {
      switch R {
        case EmptyTree {
          _definition {ti2tree, ti_next}
          conclude ti2tree(next_up(path,L,x,EmptyTree))
             = plug_tree(path,TreeNode(L,x,EmptyTree))
            by symmetric next_up_stable[E][path][L,x,EmptyTree]
        }
        case TreeNode(RL, y, RR) {
          _definition {ti2tree, ti_next}
          conclude ti2tree(first_path(RL,y,RR,node(RightD(L,x),path))) 
                 = plug_tree(path,TreeNode(L,x,TreeNode(RL,y,RR)))
            by _rewrite first_path_stable[E][RL][y,RR,node(RightD(L,x),path)]
               _definition {plug_tree}.
        }
      }
    }
  }
end

/* --------------------------------------------------------
   Theorem about ti_get and ti_index:
   
   ti_index_get_in_order: all E:type, iter:TreeIter<E>, a:E.
       ti_get(iter) = nth(in_order(ti2tree(iter)), a)(ti_index(iter))
   
   -------------------------------------------------------- */

lemma in_order_plug_take: all E:type. all path:List<Direction<E>>. all t:Tree<E>.
  in_order(plug_tree(take_path(path), t))
  = in_order(plug_tree(take_path(path),EmptyTree)) ++ in_order(t)
proof
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary t:Tree<E>
    _definition {take_path, plug_tree, in_order, operator++}.
  }
  case node(f, path') suppose IH {
    arbitrary t:Tree<E>
    switch f {
      case RightD(L, x) {
        _definition {take_path, plug_tree}
        equations
              in_order(plug_tree(take_path(path'),TreeNode(L,x,t)))
            = in_order(plug_tree(take_path(path'),EmptyTree)) ++ in_order(TreeNode(L,x,t))
                  by IH[TreeNode(L,x,t)]
        ... = in_order(plug_tree(take_path(path'),EmptyTree)) ++ (in_order(L) ++ node(x, in_order(t)))
                  by _definition in_order.
        ... = in_order(plug_tree(take_path(path'),EmptyTree))
              ++ ((in_order(L) ++ node(x, empty)) ++ in_order(t))
                  by _rewrite append_assoc[E][in_order(L)][node(x,empty), in_order(t)] _definition {operator++, operator++}.
        ... = (in_order(plug_tree(take_path(path'),EmptyTree)) ++ (in_order(L) ++ node(x, empty)))
               ++ in_order(t)
                  by _rewrite append_assoc[E][in_order(plug_tree(take_path(path'),EmptyTree))][in_order(L) ++ node(x, empty), in_order(t)].
        ... = (in_order(plug_tree(take_path(path'),EmptyTree))
               ++ (in_order(L) ++ node(x, in_order(EmptyTree)))) ++ in_order(t)
                  by _definition in_order.
        ... = (in_order(plug_tree(take_path(path'),EmptyTree)) ++ in_order(TreeNode(L,x,EmptyTree)))
              ++ in_order(t)
                  by _definition {in_order, in_order}.
        ... = in_order(plug_tree(take_path(path'), TreeNode(L,x,EmptyTree))) ++ in_order(t)
                  by _rewrite IH[TreeNode(L,x,EmptyTree)].
      }
      case LeftD(x, R) {
        _definition {take_path}
        conclude in_order(plug_tree(take_path(path'),t))
               = in_order(plug_tree(take_path(path'),EmptyTree)) ++ in_order(t)
            by IH[t]
      }
    }
  }
end

lemma in_order_plug_drop: all E:type. all path:List<Direction<E>>. all t:Tree<E>.
  in_order(plug_tree(drop_path(path), t)) = in_order(t) ++ in_order(plug_tree(drop_path(path),EmptyTree))
proof
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary t:Tree<E>
    _definition {drop_path, plug_tree, in_order}
    _rewrite append_empty[E][in_order(t)].
  }
  case node(f, path') suppose IH {
    arbitrary t:Tree<E>
    switch f {
      case RightD(L, x) {
        _definition {drop_path}
        conclude in_order(plug_tree(drop_path(path'),t))
               = in_order(t) ++ in_order(plug_tree(drop_path(path'),EmptyTree))
            by IH[t]
      }
      case LeftD(x, R) {
        _definition {drop_path, plug_tree}
        have IH2: in_order(plug_tree(drop_path(path'),TreeNode(t,x,R)))
                = in_order(TreeNode(t,x,R)) ++ in_order(plug_tree(drop_path(path'),EmptyTree))
                by IH[TreeNode(t,x,R)]
        equations
          in_order(plug_tree(drop_path(path'),TreeNode(t,x,R)))
              = in_order(TreeNode(t,x,R)) ++ in_order(plug_tree(drop_path(path'),EmptyTree))
                   by IH2
          ... = (in_order(t) ++ node(x, in_order(R))) ++ in_order(plug_tree(drop_path(path'), EmptyTree))
                   by _definition in_order.
          ... = (in_order(t) ++ in_order(TreeNode(EmptyTree,x,R)))
                ++ in_order(plug_tree(drop_path(path'), EmptyTree))
                   by _definition {in_order,in_order,operator++}.
          ... = in_order(t) ++ in_order(plug_tree(drop_path(path'), TreeNode(EmptyTree,x,R)))
                   by _rewrite IH[TreeNode(EmptyTree,x,R)]
                      _rewrite append_assoc[E][in_order(t)]
                    [in_order(TreeNode(EmptyTree,x,R)), in_order(plug_tree(drop_path(path'),EmptyTree))].
      }
    }      
  }
end

lemma in_order_plug_take_drop: all E:type. all path:List<Direction<E>>. all A:Tree<E>, x:E, B:Tree<E>.
  in_order(plug_tree(path, TreeNode(A, x, B)))
  = in_order(plug_tree(take_path(path), A)) ++ node(x, in_order(plug_tree(drop_path(path), B)))
proof
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    _definition {plug_tree, take_path, drop_path, in_order}.
  }
  case node(f, path') suppose IH {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    define_ X = in_order(plug_tree(take_path(path'),EmptyTree))
    define_ Z = in_order(A)
    define_ W = in_order(B)
    define_ Q = in_order(plug_tree(drop_path(path'), EmptyTree))
    switch f {
      case RightD(L, y) {
        _definition {plug_tree, take_path, drop_path, in_order}
        define_ Y = in_order(L)
        equations
              in_order(plug_tree(path',TreeNode(L,y,TreeNode(A,x,B))))
            = in_order(plug_tree(take_path(path'),L))
                ++ node(y, in_order(plug_tree(drop_path(path'), TreeNode(A,x,B))))
                 by IH[L,y,TreeNode(A,x,B)]
        ... = (X ++ Y) ++ node(y, in_order(plug_tree(drop_path(path'), TreeNode(A,x,B))))
                 by _definition {X,Y} _rewrite in_order_plug_take[E][path'][L].
        ... = (X ++ Y) ++ node(y, (in_order(TreeNode(A,x,B)) ++ Q))
                 by _definition {Q} _rewrite in_order_plug_drop[E][path'][TreeNode(A,x,B)].
        ... = (X ++ Y) ++ node(y, ((Z ++ node(x, W)) ++ Q))
                 by _definition {in_order, Z, W}.
        ... = X ++ (Y ++ node(y, (Z ++ (node(x, W) ++ Q))))
                 by _rewrite append_assoc[E][X][Y, node(y, ((Z ++ node(x, W)) ++ Q))]
                    _rewrite append_assoc[E][Z][node(x,W), Q].
        ... = (X ++ (Y ++ (node(y, Z) ++ node(x, W ++ Q))))
                 by _definition operator++.
        ... = (X ++ (Y ++ node(y, Z))) ++ node(x, W ++ Q)
                 by _rewrite append_assoc[E][X][(Y ++ node(y, Z)), node(x, W ++ Q)]
                    _rewrite append_assoc[E][Y][node(y, Z), node(x, W ++ Q)].
        ... = (X ++ (Y ++ node(y, Z))) ++ node(x, in_order(plug_tree(drop_path(path'), B)))
                 by _definition {Q,W} _rewrite in_order_plug_drop[E][path'][B].
        ... = in_order(plug_tree(take_path(path'), TreeNode(L,y,A)))
              ++ node(x,in_order(plug_tree(drop_path(path'),B)))
                 by _definition {X,Y,Z} _rewrite in_order_plug_take[E][path'][TreeNode(L,y,A)]
                    _definition in_order.
      }
      case LeftD(y, R) {
        _definition {plug_tree, take_path, drop_path, in_order}
        define_ Y = in_order(R)
        equations
              in_order(plug_tree(path',TreeNode(TreeNode(A,x,B),y,R)))
            = in_order(plug_tree(take_path(path'),TreeNode(A,x,B)))
                ++ node(y,in_order(plug_tree(drop_path(path'),R)))
              by IH[TreeNode(A,x,B), y, R]
        ... = in_order(plug_tree(take_path(path'),TreeNode(A,x,B))) ++ node(y, Y ++ Q)
              by _definition {Y,Q} _rewrite in_order_plug_drop[E][path'][R].
        ... = (X ++ (Z ++ node(x, W))) ++ node(y, Y ++ Q)
              by _definition {X, Z, W} _rewrite in_order_plug_take[E][path'][TreeNode(A,x,B)]
                 _definition in_order.
        ... = X ++ (Z ++ node(x, (W ++ node(y, Y ++ Q))))
              by _rewrite append_assoc[E][X][(Z ++ node(x, W)), node(y, Y ++ Q)]
                 _rewrite append_assoc[E][Z][node(x, W), node(y, Y ++ Q)]
                 _definition operator++.
        ... = (X ++ Z) ++ node(x, ((W ++ node(y, Y)) ++ Q))
              by _rewrite append_assoc[E][W][node(y, Y), Q]
                 _rewrite append_assoc[E][X][Z, node(x, W ++ (node(y, Y) ++ Q))]
                 _definition operator++.
        ... = in_order(plug_tree(take_path(path'),A)) ++ node(x, ((W ++ node(y, Y)) ++ Q))
              by _definition {X,Z} _rewrite in_order_plug_take[E][path'][A].
        ... = in_order(plug_tree(take_path(path'),A))
              ++ node(x,in_order(plug_tree(drop_path(path'), TreeNode(B,y,R))))
              by _definition {W,Y,Q}
                 _rewrite in_order_plug_drop[E][path'][TreeNode(B,y,R)]
                 _definition in_order.
      }
    }
  }
end

lemma nth_in_order_plug_take:
  all E:type, path:List<Direction<E>>, L:Tree<E>, x:E, R:Tree<E>, a:E.
  nth(in_order(plug_tree(path,TreeNode(L,x,R))),a)
     (num_nodes(plug_tree(take_path(path),EmptyTree)) + num_nodes(L)) = x
proof
  arbitrary E:type, path:List<Direction<E>>, L:Tree<E>, x:E, R:Tree<E>, a:E
  suffices nth((in_order(plug_tree(take_path(path), EmptyTree)) ++ in_order(L))
                ++ node(x, in_order(plug_tree(drop_path(path), R))), a)
              (length(in_order(plug_tree(take_path(path), EmptyTree))) + length(in_order(L)))
           = x
      with rewrite in_order_plug_take_drop[E][path][L,x,R]
                 | in_order_plug_take[E][path][L]
                 | symmetric length_in_order[E][L]
                 | symmetric length_in_order[E][plug_tree(take_path(path),EmptyTree)]
  define_ X = in_order(plug_tree(take_path(path),EmptyTree))
  define_ Y = in_order(L)
  define_ Z = in_order(plug_tree(drop_path(path),R))
  suffices nth((X ++ Y) ++ node(x,Z),a)(length(X ++ Y)) = x
      with rewrite symmetric length_append[E][X][Y]
  suffices nth(node(x, Z), a)(0) = x
      with rewrite (rewrite add_zero[length(X ++ Y)] in
           nth_append_back[E][X ++ Y][node(x,Z), 0, a])
  definition nth
end

theorem ti_index_get_in_order: all E:type, z:TreeIter<E>, a:E.
  ti_get(z) = nth(in_order(ti2tree(z)), a)(ti_index(z))
proof
  arbitrary E:type, z:TreeIter<E>, a:E
  switch z {
    case TrItr(path, L, x, R) {
      _definition {ti2tree, ti_get, ti_index, ti_take}
      _rewrite num_nodes_plug[E][take_path(path)][L]
      
      suffices x = nth(in_order(plug_tree(path,TreeNode(L,x,R))),a)
                      (num_nodes(plug_tree(take_path(path),EmptyTree)) + num_nodes(L))  by .
      _rewrite in_order_plug_take_drop[E][path][L,x,R]
            | in_order_plug_take[E][path][L]
      suffices x = nth(((in_order(plug_tree(take_path(path),EmptyTree)) ++ in_order(L))
                        ++ node(x, in_order(plug_tree(drop_path(path),R)))), a)
                      (num_nodes(plug_tree(take_path(path),EmptyTree)) + num_nodes(L))  by .
      _rewrite symmetric length_in_order[E][L]
            | symmetric length_in_order[E][plug_tree(take_path(path),EmptyTree)]
      define_ X = in_order(plug_tree(take_path(path),EmptyTree))
      define_ Y = in_order(L)
      define_ Z = in_order(plug_tree(drop_path(path),R))
      _rewrite symmetric length_append[E][X][Y]
      
      suffices x = nth((X ++ Y) ++ node(x,Z), a)(length(X ++ Y))  by .
      _rewrite (rewrite add_zero[length(X ++ Y)] in
               nth_append_back[E][X ++ Y][node(x,Z), 0, a])
      definition nth
    }
  }
end


/***********************************************************
  Extra Stuff
 ***********************************************************/

function pre_order<E>(Tree<E>) -> List<E> {
  pre_order(EmptyTree) = empty
  pre_order(TreeNode(L, x, R)) =
    node(x, (pre_order(L) ++ pre_order(R)))
}

function post_order<E>(Tree<E>) -> List<E> {
  post_order(EmptyTree) = empty
  post_order(TreeNode(L, x, R)) =
    post_order(L) ++ (post_order(R) ++ node(x, empty))
}

function focus<E>(TreeIter<E>) -> Tree<E> {
  focus(TrItr(path, L, x, R)) = TreeNode(L, x, R)
}

function context<E>(TreeIter<E>) -> List<Direction<E>> {
  context(TrItr(path, L, x, R)) = path
}

function tree_data<E>(Tree<E>) -> Option<E> {
  tree_data(EmptyTree) = none
  tree_data(TreeNode(L, x, R)) = just(x)
}

function left_child<E>(Tree<E>) -> Tree<E> {
  left_child(EmptyTree) = EmptyTree
  left_child(TreeNode(L, x, R)) = L
}

function right_child<E>(Tree<E>) -> Tree<E> {
  right_child(EmptyTree) = EmptyTree
  right_child(TreeNode(L, x, R)) = R
}

theorem in_order_plug: all E:type. all path:List<Direction<E>>. all A:Tree<E>, B:Tree<E>.
  if in_order(A) = in_order(B)
  then in_order(plug_tree(path, A)) = in_order(plug_tree(path, B))
proof
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary A:Tree<E>, B:Tree<E>
    suppose A_B
    _definition plug_tree
    A_B
  }
  case node(f, path') suppose IH {
    arbitrary A:Tree<E>, B:Tree<E>
    switch f {
      case RightD(L, x) {
        suppose A_B
        _definition plug_tree
        have LA_LB: in_order(TreeNode(L,x,A)) = in_order(TreeNode(L,x,B))
           by _definition in_order _rewrite A_B.
        conclude in_order(plug_tree(path',TreeNode(L,x,A)))
               = in_order(plug_tree(path',TreeNode(L,x,B)))
            by apply IH[TreeNode(L, x, A), TreeNode(L, x, B)] to LA_LB
      }
      case LeftD(x, R) {
        suppose A_B
        _definition plug_tree
        have AR_BR: in_order(TreeNode(A,x,R)) = in_order(TreeNode(B,x,R))
           by _definition in_order _rewrite A_B.
        conclude in_order(plug_tree(path',TreeNode(A,x,R)))
               = in_order(plug_tree(path',TreeNode(B,x,R)))
            by apply IH[TreeNode(A, x, R), TreeNode(B, x, R)] to AR_BR
      }
    }
  }
end

theorem in_order_assoc: all E:type. all A:Tree<E>. all x:E, B:Tree<E>, y:E, C:Tree<E>.
    in_order(TreeNode(TreeNode(A, x, B), y, C))
  = in_order(TreeNode(A, x, TreeNode(B, y, C)))
proof
  arbitrary E:type
  induction Tree<E>
  case EmptyTree {
    arbitrary x:E, B:Tree<E>, y:E, C:Tree<E>
    _definition {in_order, in_order, in_order, operator++}.
  }
  case TreeNode(L, z, R) {
    arbitrary x:E, B:Tree<E>, y:E, C:Tree<E>
    _definition {in_order, in_order, in_order}
    equations
          (( (in_order(L) ++ node(z,in_order(R))) ++ node(x,in_order(B))) ++ node(y,in_order(C)))
        = (in_order(L) ++ node(z,in_order(R))) ++  (node(x,in_order(B)) ++ node(y,in_order(C)))
          by _rewrite append_assoc[E][in_order(L) ++ node(z,in_order(R))]
                        [node(x,in_order(B)), node(y,in_order(C))].
    ... = (in_order(L) ++ node(z,in_order(R))) ++ node(x, in_order(B) ++ node(y,in_order(C)))
          by _definition operator++.
  }
end

theorem in_order_plug_take2: all E:type. all path:List<Direction<E>>. all A:Tree<E>, x:E, B:Tree<E>.
  in_order(plug_tree(take_path(path),A))
  = take(num_nodes(plug_tree(take_path(path),A)), in_order(ti2tree(TrItr(path,A,x,B))))
proof
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    _definition {take_path, ti2tree, plug_tree, in_order}
    _rewrite symmetric length_in_order[E][A]
    _rewrite take_append[E][in_order(A)][node(x, in_order(B))].
  }
  case node(f, path') suppose IH {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    switch f {
      case RightD(L, z) {  // TreeNode(L, z, TreeNode(A,x,B))
        _definition {take_path, ti2tree, plug_tree, in_order}
        _rewrite num_nodes_plug[E][take_path(path')][TreeNode(L,z,A)]
        _definition {num_nodes, operator+, operator+}
        suffices in_order(plug_tree(take_path(path'),TreeNode(L,z,A)))
               = take(num_nodes(plug_tree(take_path(path'),EmptyTree)) + suc(num_nodes(L) + num_nodes(A)),
                      in_order(plug_tree(path', TreeNode(L,z,TreeNode(A,x,B)))))  by .
        have IH2: in_order(plug_tree(take_path(path'),TreeNode(L,z,A)))
                = take(num_nodes(plug_tree(take_path(path'),TreeNode(L,z,A))),in_order(ti2tree(TrItr(path',TreeNode(L,z,A),x,B))))
          by IH[TreeNode(L, z, A), x, B]
        have IH3: in_order(plug_tree(take_path(path'),TreeNode(L,z,A)))
                = take(num_nodes(plug_tree(take_path(path'),TreeNode(L,z,A))),in_order(plug_tree(path',TreeNode(TreeNode(L,z,A),x,B))))
          by definition ti2tree in IH2
        _rewrite IH3
        _rewrite num_nodes_plug[E][take_path(path')][TreeNode(L,z,A)]
        _definition {num_nodes, operator+, operator+}
        have LA_B_L_AB: in_order(TreeNode(TreeNode(L,z,A),x,B)) = in_order(TreeNode(L,z,TreeNode(A,x,B)))
          by in_order_assoc[E][L][z,A,x,B]
        _rewrite (apply in_order_plug[E][path'][TreeNode(TreeNode(L,z,A),x,B), TreeNode(L,z,TreeNode(A,x,B))]
                 to LA_B_L_AB).
      }
      case LeftD(z, R) { // TreeNode(TreeNode(A, x, b), z, R)
        _definition {take_path, ti2tree, plug_tree, in_order}
        _rewrite IH[A,x,TreeNode(B, z, R)]
        _definition {ti2tree}
        have eq: in_order(TreeNode(A,x,TreeNode(B,z,R))) = in_order(TreeNode(TreeNode(A,x,B),z,R))
          by symmetric in_order_assoc[E][A][x,B,z,R]
        _rewrite (apply in_order_plug[E][path'][TreeNode(A,x,TreeNode(B,z,R)), TreeNode(TreeNode(A,x,B),z,R)]
                 to eq).
      }
    }
  }
end

theorem in_order_take_path: all E:type, z:TreeIter<E>.
  in_order(ti_take(z)) = take(ti_index(z), in_order(ti2tree(z)))
proof
  arbitrary E:type, z:TreeIter<E>
  switch z {
    case TrItr(path, A, x, B) {
      _definition {ti_index, ti_take}
      in_order_plug_take2[E][path][A,x,B]
    }
  }
end

