import Option
import Nat
import List
import Tree

theorem length_in_order: all E:type. all t:Tree<E>.
  length(in_order(t)) = num_nodes(t)
proof
  arbitrary E:type
  induction Tree<E>
  case EmptyTree {
    definition {in_order, length, num_nodes}.
  }
  case TreeNode(L, x, R) suppose IH_L, IH_R {
    definition {in_order, length, num_nodes}
    rewrite length_append[E][in_order(L)][node(x, in_order(R))]
    definition {length}
    rewrite IH_L | IH_R
    rewrite add_suc[num_nodes(L)][num_nodes(R)].
  }
end

/* ----------------------------------------------------------
   Theorems about ti_first:

   ti_first_stable: all E:type, A:Tree<E>, x:E, B:Tree<E>.
       ti2tree(ti_first(A, x, B)) = TreeNode(A, x, B)
       
   ti_first_index: all E:type, A:Tree<E>, x:E, B:Tree<E>.
       ti_index(ti_first(A, x, B)) = 0
       
   --------------------------------------------------------- */

lemma first_path_stable:
  all E:type. all A:Tree<E>. all y:E, B:Tree<E>, path:List<Direction<E>>.
  ti2tree(first_path(A, y, B, path)) = plug_tree(path, TreeNode(A, y, B))
proof
  arbitrary E:type
  induction Tree<E>
  case EmptyTree {
    arbitrary y:E, B:Tree<E>, path:List<Direction<E>>
    conclude ti2tree(first_path(EmptyTree,y,B,path))
           = plug_tree(path,TreeNode(EmptyTree,y,B))
        by definition {first_path, ti2tree}.
  }
  case TreeNode(L, x, R) suppose IH_L, IH_R {
    arbitrary y:E, B:Tree<E>, path:List<Direction<E>>
    definition {first_path, ti2tree}
    suffices ti2tree(first_path(L,x,R,node(LeftD(y,B),path)))
           = plug_tree(path,TreeNode(TreeNode(L,x,R),y,B))
    rewrite IH_L[x,R,node(LeftD(y,B),path)]
    definition {plug_tree}.
  }
end

theorem ti_first_stable: all E:type, A:Tree<E>, x:E, B:Tree<E>.
  ti2tree(ti_first(A, x, B)) = TreeNode(A, x, B)
proof
  arbitrary E:type, A:Tree<E>, x:E, B:Tree<E>
  definition {ti_first, ti2tree}
  rewrite first_path_stable[E][A][x,B,empty]
  definition {plug_tree}.
end

lemma first_path_index: all E:type. all A:Tree<E>. all y:E, B:Tree<E>, path:List<Direction<E>>.
  ti_index(first_path(A,y,B, path)) = num_nodes(plug_tree(take_path(path), EmptyTree))
proof
  arbitrary E:type
  induction Tree<E>
  case EmptyTree {
    arbitrary y:E, B:Tree<E>, path:List<Direction<E>>
    conclude ti_index(first_path(EmptyTree,y,B,path))
           = num_nodes(plug_tree(take_path(path),EmptyTree))
                by definition {first_path, ti_index, ti_take}.
  }
  case TreeNode(L, x, R) suppose IH {
    arbitrary y:E, B:Tree<E>, path:List<Direction<E>>
    definition {first_path}
    equations
          ti_index(first_path(L,x,R,node(LeftD(y,B),path)))
        = num_nodes(plug_tree(take_path(node(LeftD(y,B),path)),EmptyTree))
                by IH[x, R, node(LeftD(y,B), path)]
    ... = num_nodes(plug_tree(take_path(path),EmptyTree))
                by definition take_path.
  }
end

theorem ti_first_index: all E:type, A:Tree<E>, x:E, B:Tree<E>.
  ti_index(ti_first(A, x, B)) = 0
proof
  arbitrary E:type, A:Tree<E>, x:E, B:Tree<E>
  definition ti_first
  rewrite first_path_index[E][A][x,B,empty]
  suffices num_nodes(plug_tree(take_path(empty),EmptyTree)) = 0
  definition {take_path, plug_tree, num_nodes}.
end

/* ------------------------------------------------------
   Theorems about ti_next:

   ti_next_index: all E:type, z : TreeIter<E>.
       if suc(ti_index(z)) < num_nodes(ti2tree(z))
       then ti_index(ti_next(z)) = suc(ti_index(z))

   ti_next_stable: all E:type, z:TreeIter<E>.
       ti2tree(ti_next(z)) = ti2tree(z)

   ----------------------------------------------------- */

lemma next_up_stable: all E:type. all path:List<Direction<E>>. all A:Tree<E>, y:E, B:Tree<E>.
  plug_tree(path, TreeNode(A,y,B)) = ti2tree(next_up(path, A, y, B))
proof
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary A:Tree<E>, y:E, B:Tree<E>
    definition {plug_tree, next_up, ti2tree}.
  }
  case node(f, path') suppose IH {
    arbitrary A:Tree<E>, y:E, B:Tree<E>
    definition {plug_tree, next_up}
    switch f {
      case RightD(L, x) {
        IH[L,x,TreeNode(A,y,B)]
      }
      case LeftD(x, R) {
        definition ti2tree.
      }
    }
  }
end

lemma num_nodes_plug: all E:type. all path:List<Direction<E>>. all t:Tree<E>.
  num_nodes(plug_tree(path, t)) = num_nodes(plug_tree(path, EmptyTree)) + num_nodes(t)
proof  
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary t:Tree<E>
    conclude num_nodes(plug_tree(empty,t)) = num_nodes(plug_tree(empty,EmptyTree)) + num_nodes(t)
        by definition {plug_tree, num_nodes, operator+}.
  }
  case node(f, path') suppose IH {
    arbitrary t:Tree<E>
    switch f {
      case RightD(L, x) {
        definition {plug_tree, num_nodes}
        rewrite IH[TreeNode(L,x,t)]
        rewrite IH[TreeNode(L,x,EmptyTree)]
        definition {num_nodes, num_nodes}
        rewrite add_zero[num_nodes(L)]
        rewrite add_assoc[num_nodes(plug_tree(path',EmptyTree))][suc(num_nodes(L)), num_nodes(t)]
        definition {operator+}.
      }
      case LeftD(x, R) {
        definition {plug_tree, num_nodes}
        rewrite IH[TreeNode(t,x,R)]
        rewrite IH[TreeNode(EmptyTree,x,R)]
        definition {num_nodes, num_nodes, operator+}
        rewrite add_assoc[num_nodes(plug_tree(path',EmptyTree))][suc(num_nodes(R)), num_nodes(t)]
        definition {operator+}
        rewrite add_commute[num_nodes(R)][num_nodes(t)].
      }
    }
  }
end

lemma next_up_index: all E:type. all path:List<Direction<E>>. all A:Tree<E>, x:E, B:Tree<E>.
  if suc(ti_index(TrItr(path, A,x,B)) + num_nodes(B)) < num_nodes(ti2tree(TrItr(path, A,x,B)))
  then ti_index(next_up(path, A, x, B)) = suc(ti_index(TrItr(path, A,x,B)) + num_nodes(B))
proof
  arbitrary E:type
  definition ti_index
  induction List<Direction<E>>
  case empty {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    suppose prem
    conclude false
      by apply less_irreflexive
         to definition {ti_index, take_path, plug_tree, num_nodes, operator+, ti2tree, ti_take} in prem
  }
  case node(f, path') suppose IH {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    suppose prem
    switch f {
      case RightD(L, y) suppose f_eq {
        definition {next_up, ti_index, take_path, plug_tree, ti_take}
        define X = num_nodes(plug_tree(take_path(path'),EmptyTree))
        define Y = num_nodes(L)
        define Z = num_nodes(A)
        define W = num_nodes(B)
        define P = num_nodes(plug_tree(path',EmptyTree))
        have X_eq: X = num_nodes(plug_tree(take_path(path'),EmptyTree)) by definition X.
        have Y_eq: Y = num_nodes(L) by definition Y.
        have Z_eq: Z = num_nodes(A) by definition Z.
        have W_eq: W = num_nodes(B) by definition W.
        have P_eq: P = num_nodes(plug_tree(path',EmptyTree)) by definition P.
        
        have prem3: suc((X + suc(Y + Z)) + W) < P + suc(Y + suc(Z + W))
          by definition {X,Y,Z,W,P} definition {num_nodes, num_nodes} in
             rewrite num_nodes_plug[E][path'][TreeNode(L,y,TreeNode(A,x,B))] in
             rewrite num_nodes_plug[E][take_path(path')][TreeNode(L,y,A)] in 
             definition {take_path, ti_take, ti2tree, plug_tree} in rewrite f_eq in prem
        have prem_normal: suc(suc((X + Y) + (Z + W))) < suc(suc(P + (Y + (Z + W))))
          by  rewrite add_assoc[X][Y, Z+W]
              rewrite add_assoc[Y][Z, W] in
              rewrite add_assoc[X][Y+Z, W] in
              definition operator+ in
              rewrite add_suc[P][Y + (Z + W)] in          
              rewrite add_suc[P][suc(Y + (Z + W))] in          
              rewrite add_suc[X][Y+Z] in          
              rewrite add_suc[Y][Z+W] in
              prem3
        have prem2: suc(num_nodes(ti_take(TrItr(path',L,y,TreeNode(A,x,B)))) + num_nodes(TreeNode(A,x,B)))
                    < num_nodes(ti2tree(TrItr(path',L,y,TreeNode(A,x,B))))
             by  definition {ti2tree, num_nodes, ti_take}
                 rewrite num_nodes_plug[E][take_path(path')][L]
                 rewrite num_nodes_plug[E][path'][TreeNode(L,y,TreeNode(A,x,B))]
                 definition {num_nodes, num_nodes}
                 rewrite symmetric X_eq
                 rewrite symmetric Y_eq
                 rewrite symmetric Z_eq
                 rewrite symmetric W_eq
                 rewrite symmetric P_eq
                 rewrite add_suc[X+Y][Z+W]
                 rewrite add_suc[Y][Z+W]
                 rewrite add_suc[P][suc(Y + (Z + W))]
                 rewrite add_suc[P][Y + (Z + W)]
                 prem_normal
        rewrite apply IH[L,y,TreeNode(A,x,B)] to prem2
        definition {ti_take, num_nodes}
        rewrite num_nodes_plug[E][take_path(path')][L]
        rewrite num_nodes_plug[E][take_path(path')][TreeNode(L,y,A)]
        definition num_nodes
        have eq2: suc((X + Y) + suc(Z + W)) = suc((X + suc(Y + Z)) + W) by
          equations
                suc((X + Y) + suc(Z + W))
              = suc(suc(X + Y) + (Z + W))      by rewrite add_suc[X+Y][Z+W] definition operator+.
          ... = suc(suc((X + Y) + (Z + W)))    by definition operator+.
          ... = suc(suc(((X + Y) + Z) + W))    by rewrite add_assoc[X+Y][Z,W].
          ... = suc(suc((X + (Y + Z)) + W))    by rewrite add_assoc[X][Y,Z].
          ... = suc(suc(X + (Y + Z)) + W)      by definition operator+.
          ... = suc((X + suc(Y + Z)) + W)      by rewrite add_suc[X][Y+Z].
        rewrite (definition {X,Y,Z,W} in eq2).
      }
      case LeftD(y, R) {
        definition {next_up, ti_index, num_nodes, take_path, ti_take}
        rewrite num_nodes_plug[E][take_path(path')][TreeNode(A,x,B)]
        rewrite num_nodes_plug[E][take_path(path')][A]
        definition {num_nodes}
        define_ X = num_nodes(plug_tree(take_path(path'),EmptyTree))
        define_ Y = num_nodes(A)
        define_ Z = num_nodes(B)
        conclude X + suc(Y + Z) = suc((X + Y) + Z)
            by rewrite add_suc[X][Y+Z] rewrite add_assoc[X][Y,Z].
      }
    }
  }
end

theorem ti_next_index: all E:type, z : TreeIter<E>.
  if suc(ti_index(z)) < num_nodes(ti2tree(z))
  then ti_index(ti_next(z)) = suc(ti_index(z))
proof
  arbitrary E:type, z : TreeIter<E>
  suppose prem
  switch z {
    case TrItr(path, L, x, R) suppose z_eq {
      definition {ti_next}
      switch R {
        case EmptyTree suppose R_eq {
          have prem2: suc(ti_index(TrItr(path,L,x,EmptyTree)) + num_nodes(EmptyTree))
                < num_nodes(ti2tree(TrItr(path,L,x,EmptyTree)))
            by definition {num_nodes} rewrite add_zero[ti_index(TrItr(path,L,x,EmptyTree))]
               definition {num_nodes} in rewrite z_eq | R_eq in prem
          rewrite add_zero[ti_index(TrItr(path,L,x,EmptyTree))] in
          definition num_nodes in
          apply next_up_index[E][path][L, x, EmptyTree] to prem2
        }
        case TreeNode(RL, y, RR) suppose R_eq {
          rewrite first_path_index[E][RL][y,RR,node(RightD(L,x),path)]
          definition {take_path, plug_tree, ti_index, ti_take}
          rewrite num_nodes_plug[E][take_path(path)][TreeNode(L,x,EmptyTree)]
          definition {num_nodes, num_nodes}
          rewrite num_nodes_plug[E][take_path(path)][L]
          rewrite add_zero[num_nodes(L)]          
          rewrite add_suc[num_nodes(plug_tree(take_path(path),EmptyTree))][num_nodes(L)].
        }
      }
    }
  }
end

theorem ti_next_stable: all E:type, z:TreeIter<E>.
  ti2tree(ti_next(z)) = ti2tree(z)
proof
  arbitrary E:type, z:TreeIter<E>
  switch z {
    case TrItr(path, L, x, R) {
      switch R {
        case EmptyTree {
          definition {ti2tree, ti_next}
          rewrite symmetric next_up_stable[E][path][L,x,EmptyTree].
        }
        case TreeNode(RL, y, RR) {
          definition {ti2tree, ti_next}
          rewrite first_path_stable[E][RL][y,RR,node(RightD(L,x),path)]
          definition {plug_tree}.
        }
      }
    }
  }
end

/* --------------------------------------------------------
   Theorem about ti_get and ti_index:
   
   ti_index_get_in_order: all E:type, z:TreeIter<E>, a:E.
       ti_get(z) = nth(in_order(ti2tree(z)), a)(ti_index(z))
   
   -------------------------------------------------------- */

lemma in_order_plug_take: all E:type. all path:List<Direction<E>>. all t:Tree<E>.
  in_order(plug_tree(take_path(path), t)) = append( in_order(plug_tree(take_path(path),EmptyTree)), in_order(t))
proof
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary t:Tree<E>
    definition {take_path, plug_tree, in_order, append}.
  }
  case node(f, path') suppose IH {
    arbitrary t:Tree<E>
    switch f {
      case RightD(L, x) {
        definition {take_path, plug_tree}
        equations
              in_order(plug_tree(take_path(path'),TreeNode(L,x,t)))
            = append(in_order(plug_tree(take_path(path'),EmptyTree)), in_order(TreeNode(L,x,t)))
                  by IH[TreeNode(L,x,t)]
        ... = append( in_order(plug_tree(take_path(path'),EmptyTree)), append(in_order(L), node(x, in_order(t))))
                  by definition in_order.
        ... = append( in_order(plug_tree(take_path(path'),EmptyTree)), append(append(in_order(L), node(x, empty)), in_order(t)))
                  by rewrite append_assoc[E][in_order(L)][node(x,empty), in_order(t)] definition {append, append}.
        ... = append(append( in_order(plug_tree(take_path(path'),EmptyTree)), append(in_order(L), node(x, empty))), in_order(t))
                  by rewrite append_assoc[E][in_order(plug_tree(take_path(path'),EmptyTree))][append(in_order(L), node(x, empty)), in_order(t)].
        ... = append(append( in_order(plug_tree(take_path(path'),EmptyTree)), append(in_order(L), node(x, in_order(EmptyTree)))), in_order(t))
                  by definition in_order.
        ... = append(append( in_order(plug_tree(take_path(path'),EmptyTree)), in_order(TreeNode(L,x,EmptyTree))), in_order(t))
                  by definition {in_order, in_order}.
        ... = append(in_order(plug_tree(take_path(path'), TreeNode(L,x,EmptyTree))),in_order(t))
                  by rewrite IH[TreeNode(L,x,EmptyTree)].
      }
      case LeftD(x, R) {
        definition {take_path}
        conclude in_order(plug_tree(take_path(path'),t))
               = append(in_order(plug_tree(take_path(path'),EmptyTree)),in_order(t))
            by IH[t]
      }
    }
  }
end

lemma in_order_plug_drop: all E:type. all path:List<Direction<E>>. all t:Tree<E>.
  in_order(plug_tree(drop_path(path), t)) = append( in_order(t), in_order(plug_tree(drop_path(path),EmptyTree)))
proof
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary t:Tree<E>
    definition {drop_path, plug_tree, in_order}
    rewrite append_empty[E][in_order(t)].
  }
  case node(f, path') suppose IH {
    arbitrary t:Tree<E>
    switch f {
      case RightD(L, x) {
        definition {drop_path}
        conclude in_order(plug_tree(drop_path(path'),t))
               = append(in_order(t),in_order(plug_tree(drop_path(path'),EmptyTree)))
            by IH[t]
      }
      case LeftD(x, R) {
        definition {drop_path, plug_tree}
        have IH2: in_order(plug_tree(drop_path(path'),TreeNode(t,x,R)))
                = append(in_order(TreeNode(t,x,R)),in_order(plug_tree(drop_path(path'),EmptyTree)))
                by IH[TreeNode(t,x,R)]
        equations
          in_order(plug_tree(drop_path(path'),TreeNode(t,x,R)))
              = append(in_order(TreeNode(t,x,R)), in_order(plug_tree(drop_path(path'),EmptyTree)))
                   by IH2
          ... = append( append(in_order(t), node(x, in_order(R))), in_order(plug_tree(drop_path(path'), EmptyTree)))
                   by definition in_order.
          ... = append( append(in_order(t), in_order(TreeNode(EmptyTree,x,R))), in_order(plug_tree(drop_path(path'), EmptyTree)))
                   by definition {in_order,in_order,append}.
          ... = append(in_order(t), in_order(plug_tree(drop_path(path'), TreeNode(EmptyTree,x,R))))
                   by rewrite IH[TreeNode(EmptyTree,x,R)]
                      rewrite append_assoc[E][in_order(t)][in_order(TreeNode(EmptyTree,x,R)), in_order(plug_tree(drop_path(path'),EmptyTree))].
      }
    }      
  }
end

lemma in_order_plug_take_drop: all E:type. all path:List<Direction<E>>. all A:Tree<E>, x:E, B:Tree<E>.
  in_order(plug_tree(path, TreeNode(A, x, B)))
  = append(in_order(plug_tree(take_path(path), A)), node(x, in_order(plug_tree(drop_path(path), B))))
proof
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    definition {plug_tree, take_path, drop_path, in_order}.
  }
  case node(f, path') suppose IH {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    define X = in_order(plug_tree(take_path(path'),EmptyTree))
    define Z = in_order(A)
    define W = in_order(B)
    define Q = in_order(plug_tree(drop_path(path'), EmptyTree))
    switch f {
      case RightD(L, y) {
        definition {plug_tree, take_path, drop_path, in_order}
        define Y = in_order(L)
        equations
              in_order(plug_tree(path',TreeNode(L,y,TreeNode(A,x,B))))
            = append(in_order(plug_tree(take_path(path'),L)), node(y, in_order(plug_tree(drop_path(path'), TreeNode(A,x,B)))))
                 by IH[L,y,TreeNode(A,x,B)]
        ... = append(append(X, Y),  node(y, in_order(plug_tree(drop_path(path'), TreeNode(A,x,B)))))
                 by definition {X,Y} rewrite in_order_plug_take[E][path'][L].
        ... = append(append(X, Y),  node(y, append(in_order(TreeNode(A,x,B)), Q)))
                 by definition {Q} rewrite in_order_plug_drop[E][path'][TreeNode(A,x,B)].
        ... = append(append(X, Y),  node(y, append(append(Z, node(x, W)), Q)))
                 by definition {in_order, Z, W}.
        ... = append(X, append(Y, node(y, append(Z, append(node(x, W), Q)))))
                 by rewrite append_assoc[E][X][Y, node(y, append(append(Z, node(x, W)), Q))]
                    rewrite append_assoc[E][Z][node(x,W), Q].
        ... = append(X, append(Y, append(node(y, Z), node(x, append(W, Q)))))
                 by definition append.
        ... = append(append(X, append(Y, node(y, Z))),  node(x, append(W, Q)))
                 by rewrite append_assoc[E][X][append(Y, node(y, Z)), node(x, append(W, Q))]
                    rewrite append_assoc[E][Y][node(y, Z), node(x, append(W, Q))].
        ... = append(append(X, append(Y, node(y, Z))),  node(x, in_order(plug_tree(drop_path(path'), B))))
                 by definition {Q,W} rewrite in_order_plug_drop[E][path'][B].
        ... = append(in_order(plug_tree(take_path(path'), TreeNode(L,y,A))), node(x,in_order(plug_tree(drop_path(path'),B))))
                 by definition {X,Y,Z} rewrite in_order_plug_take[E][path'][TreeNode(L,y,A)] definition in_order.
      }
      case LeftD(y, R) {
        definition {plug_tree, take_path, drop_path, in_order}
        define Y = in_order(R)
        equations
              in_order(plug_tree(path',TreeNode(TreeNode(A,x,B),y,R)))
            = append(in_order(plug_tree(take_path(path'),TreeNode(A,x,B))), node(y,in_order(plug_tree(drop_path(path'),R))))
              by IH[TreeNode(A,x,B), y, R]
        ... = append(in_order(plug_tree(take_path(path'),TreeNode(A,x,B))), node(y, append(Y, Q)))
              by definition {Y,Q} rewrite in_order_plug_drop[E][path'][R].
        ... = append(append(X, append(Z, node(x, W))), node(y, append(Y, Q)))
              by definition {X, Z, W} rewrite in_order_plug_take[E][path'][TreeNode(A,x,B)] definition in_order.
        ... = append(X, append(Z, node(x, append(W, node(y, append(Y, Q))))))
              by rewrite append_assoc[E][X][append(Z, node(x, W)), node(y, append(Y, Q))]
                 rewrite append_assoc[E][Z][node(x, W), node(y, append(Y, Q))]
                 definition append.
        ... = append(append(X, Z), node(x, append(append(W, node(y, Y)), Q)))
              by rewrite append_assoc[E][W][node(y, Y), Q]
                 rewrite append_assoc[E][X][Z, node(x, append(W, append(node(y, Y), Q)))]
                 definition append.
        ... = append(in_order(plug_tree(take_path(path'),A)), node(x,append(append(W, node(y, Y)), Q)))
              by definition {X,Z} rewrite in_order_plug_take[E][path'][A].
        ... = append(in_order(plug_tree(take_path(path'),A)),node(x,in_order(plug_tree(drop_path(path'),TreeNode(B,y,R)))))
              by definition {W,Y,Q} rewrite in_order_plug_drop[E][path'][TreeNode(B,y,R)] definition in_order.
      }
    }
  }
end

lemma nth_in_order_plug_take:
  all E:type, path:List<Direction<E>>, L:Tree<E>, x:E, R:Tree<E>, a:E.
  nth(in_order(plug_tree(path,TreeNode(L,x,R))),a)
     (num_nodes(plug_tree(take_path(path),EmptyTree)) + num_nodes(L)) = x
proof
  arbitrary E:type, path:List<Direction<E>>, L:Tree<E>, x:E, R:Tree<E>, a:E
  rewrite in_order_plug_take_drop[E][path][L,x,R]
        | in_order_plug_take[E][path][L]
        | symmetric length_in_order[E][L]
        | symmetric length_in_order[E][plug_tree(take_path(path),EmptyTree)]
  define_ X = in_order(plug_tree(take_path(path),EmptyTree))
  define_ Y = in_order(L)
  define_ Z = in_order(plug_tree(drop_path(path),R))
  rewrite symmetric length_append[E][X][Y]
  suffices nth(append(append(X,Y), node(x,Z)), a)(length(append(X,Y))) = x
  rewrite (rewrite add_zero[length(append(X,Y))] in nth_append_back[E][append(X,Y)][node(x,Z), 0, a])
  definition nth.
end

theorem ti_index_get_in_order: all E:type, z:TreeIter<E>, a:E.
  ti_get(z) = nth(in_order(ti2tree(z)), a)(ti_index(z))
proof
  arbitrary E:type, z:TreeIter<E>, a:E
  switch z {
    case TrItr(path, L, x, R) {
      definition {ti2tree, ti_get, ti_index, ti_take}
      rewrite num_nodes_plug[E][take_path(path)][L]
      rewrite nth_in_order_plug_take[E, path, L,x,R,a].
    }
  }
end


/***********************************************************
  Extra Stuff
 ***********************************************************/

function pre_order<E>(Tree<E>) -> List<E> {
  pre_order(EmptyTree) = empty
  pre_order(TreeNode(L, x, R)) =
    node(x, append(pre_order(L), pre_order(R)))
}

function post_order<E>(Tree<E>) -> List<E> {
  post_order(EmptyTree) = empty
  post_order(TreeNode(L, x, R)) =
    append(post_order(L), append(post_order(R), node(x, empty)))
}

function focus<E>(TreeIter<E>) -> Tree<E> {
  focus(TrItr(path, L, x, R)) = TreeNode(L, x, R)
}

function context<E>(TreeIter<E>) -> List<Direction<E>> {
  context(TrItr(path, L, x, R)) = path
}

function tree_data<E>(Tree<E>) -> Option<E> {
  tree_data(EmptyTree) = none
  tree_data(TreeNode(L, x, R)) = just(x)
}

function left_child<E>(Tree<E>) -> Tree<E> {
  left_child(EmptyTree) = EmptyTree
  left_child(TreeNode(L, x, R)) = L
}

function right_child<E>(Tree<E>) -> Tree<E> {
  right_child(EmptyTree) = EmptyTree
  right_child(TreeNode(L, x, R)) = R
}

theorem in_order_plug: all E:type. all path:List<Direction<E>>. all A:Tree<E>, B:Tree<E>.
  if in_order(A) = in_order(B)
  then in_order(plug_tree(path, A)) = in_order(plug_tree(path, B))
proof
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary A:Tree<E>, B:Tree<E>
    suppose A_B
    definition plug_tree
    A_B
  }
  case node(f, path') suppose IH {
    arbitrary A:Tree<E>, B:Tree<E>
    switch f {
      case RightD(L, x) {
        suppose A_B
        definition plug_tree
        have LA_LB: in_order(TreeNode(L,x,A)) = in_order(TreeNode(L,x,B))
           by definition in_order rewrite A_B.
        conclude in_order(plug_tree(path',TreeNode(L,x,A)))
               = in_order(plug_tree(path',TreeNode(L,x,B)))
            by apply IH[TreeNode(L, x, A), TreeNode(L, x, B)] to LA_LB
      }
      case LeftD(x, R) {
        suppose A_B
        definition plug_tree
        have AR_BR: in_order(TreeNode(A,x,R)) = in_order(TreeNode(B,x,R))
           by definition in_order rewrite A_B.
        conclude in_order(plug_tree(path',TreeNode(A,x,R)))
               = in_order(plug_tree(path',TreeNode(B,x,R)))
            by apply IH[TreeNode(A, x, R), TreeNode(B, x, R)] to AR_BR
      }
    }
  }
end

theorem in_order_assoc: all E:type. all A:Tree<E>. all x:E, B:Tree<E>, y:E, C:Tree<E>.
    in_order(TreeNode(TreeNode(A, x, B), y, C))
  = in_order(TreeNode(A, x, TreeNode(B, y, C)))
proof
  arbitrary E:type
  induction Tree<E>
  case EmptyTree {
    arbitrary x:E, B:Tree<E>, y:E, C:Tree<E>
    definition {in_order, in_order, in_order, append}.
  }
  case TreeNode(L, z, R) {
    arbitrary x:E, B:Tree<E>, y:E, C:Tree<E>
    definition {in_order, in_order, in_order}
    equations
          append(append( append(in_order(L), node(z,in_order(R))), node(x,in_order(B))), node(y,in_order(C)))
        = append( append(in_order(L), node(z,in_order(R))),  append( node(x,in_order(B)), node(y,in_order(C))))
          by rewrite append_assoc[E][append(in_order(L), node(z,in_order(R)))][node(x,in_order(B)), node(y,in_order(C))].
    ... = append( append(in_order(L), node(z,in_order(R))),  node(x, append(in_order(B), node(y,in_order(C)))))
          by definition append.
  }
end

theorem in_order_plug_take2: all E:type. all path:List<Direction<E>>. all A:Tree<E>, x:E, B:Tree<E>.
  in_order(plug_tree(take_path(path),A))
  = take(num_nodes(plug_tree(take_path(path),A)), in_order(ti2tree(TrItr(path,A,x,B))))
proof
  arbitrary E:type
  induction List<Direction<E>>
  case empty {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    definition {take_path, plug_tree, ti2tree, in_order}
    rewrite symmetric length_in_order[E][A]
    rewrite take_append[E][in_order(A)][node(x, in_order(B))].
  }
  case node(f, path') suppose IH {
    arbitrary A:Tree<E>, x:E, B:Tree<E>
    switch f {
      case RightD(L, z) {  // TreeNode(L, z, TreeNode(A,x,B))
        definition {take_path, plug_tree, ti2tree, in_order}
        rewrite num_nodes_plug[E][take_path(path')][TreeNode(L,z,A)]
        definition {num_nodes}
        suffices in_order(plug_tree(take_path(path'),TreeNode(L,z,A)))
               = take(num_nodes(plug_tree(take_path(path'),EmptyTree)) + suc(num_nodes(L) + num_nodes(A)),
                      in_order(plug_tree(path', TreeNode(L,z,TreeNode(A,x,B)))))
        have IH2: in_order(plug_tree(take_path(path'),TreeNode(L,z,A)))
                = take(num_nodes(plug_tree(take_path(path'),TreeNode(L,z,A))),in_order(ti2tree(TrItr(path',TreeNode(L,z,A),x,B))))
          by IH[TreeNode(L, z, A), x, B]
        have IH3: in_order(plug_tree(take_path(path'),TreeNode(L,z,A)))
                = take(num_nodes(plug_tree(take_path(path'),TreeNode(L,z,A))),in_order(plug_tree(path',TreeNode(TreeNode(L,z,A),x,B))))
          by definition ti2tree in IH2
        rewrite IH3
        rewrite num_nodes_plug[E][take_path(path')][TreeNode(L,z,A)]
        definition {num_nodes}
        have LA_B_L_AB: in_order(TreeNode(TreeNode(L,z,A),x,B)) = in_order(TreeNode(L,z,TreeNode(A,x,B)))
          by in_order_assoc[E][L][z,A,x,B]
        rewrite (apply in_order_plug[E][path'][TreeNode(TreeNode(L,z,A),x,B), TreeNode(L,z,TreeNode(A,x,B))]
                 to LA_B_L_AB).
      }
      case LeftD(z, R) { // TreeNode(TreeNode(A, x, b), z, R)
        definition {take_path, plug_tree, ti2tree, in_order}
        rewrite IH[A,x,TreeNode(B, z, R)]
        definition {ti2tree}
        have eq: in_order(TreeNode(A,x,TreeNode(B,z,R))) = in_order(TreeNode(TreeNode(A,x,B),z,R))
          by symmetric in_order_assoc[E][A][x,B,z,R]
        rewrite (apply in_order_plug[E][path'][TreeNode(A,x,TreeNode(B,z,R)), TreeNode(TreeNode(A,x,B),z,R)]
                 to eq).
      }
    }
  }
end

theorem in_order_take_path: all E:type, z:TreeIter<E>.
  in_order(ti_take(z)) = take(ti_index(z), in_order(ti2tree(z)))
proof
  arbitrary E:type, z:TreeIter<E>
  switch z {
    case TrItr(path, A, x, B) {
      definition {ti_take, ti_index}
      in_order_plug_take2[E][path][A,x,B]
    }
  }
end

