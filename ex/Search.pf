import Nat
import List

function search(List<Nat>, Nat) -> Nat {
  search(empty, y) = 0
  search(node(x, xs), y) =
    if x = y then
      0
    else
      suc(search(xs, y))
}

define list_439 = node(4, node(3, node(9, empty)))
assert search(list_439, 4) = 0
assert search(list_439, 3) = 1
assert search(list_439, 9) = 2
assert search(list_439, 0) = 3


theorem search_present: all xs:List<Nat>. all y:Nat, d:Nat.
  if y ∈ set_of(xs)
  then let i = search(xs, y)
       nth(xs, d)(i) = y
proof
  induction List<Nat>
  case empty {
    arbitrary y:Nat, d:Nat
    suppose y_empty: y ∈ set_of(empty)
    conclude false   by definition {set_of, operator ∈} in y_empty
  }
  case node(x, xs') suppose IH {
    arbitrary y:Nat, d:Nat
    suppose y_xxs: y ∈ set_of(node(x,xs'))
    definition {nth, search}
    switch x = y {
      case true suppose xy_true {
        conclude x = y   by rewrite xy_true.
      }
      case false suppose xy_false {
        definition pred
	have x_y_or_y_xs: x = y or y ∈ set_of(xs')
	    by enable {set_of,operator ∪, operator ∈} y_xxs
	cases x_y_or_y_xs
	case x_y: x = y {
	  conclude false   by rewrite xy_false in x_y
	}
	case y_xs: y ∈ set_of(xs') {
	  conclude nth(xs',d)(search(xs',y)) = y
	      by apply IH[y,d] to y_xs
	}
      }
    }
  }
end

theorem search_absent: all xs:List<Nat>. all y:Nat, d:Nat.
  if not (y ∈ set_of(xs))
  then search(xs, y) = length(xs)
proof
  induction List<Nat>
  case empty {
    arbitrary y:Nat, d:Nat
    suppose _
    conclude search(empty,y) = length(empty)
        by definition {search, length}.
  }
  case node(x, xs) suppose IH {
    arbitrary y:Nat, d:Nat
    suppose y_not_xxs: not (y ∈ set_of(node(x,xs)))
    suffices search(node(x,xs),y) = length(node(x,xs))
    definition {search, length}
    switch x = y {
      case true suppose xy {
        conclude false
            by enable {set_of, operator ∪, operator ∈}
	       apply y_not_xxs to rewrite xy.
      }
      case false suppose not_xy {
        suffices suc(search(xs,y)) = suc(length(xs))
	have s_l: search(xs,y) = length(xs)
          by enable {set_of, operator ∈, operator ∪}
	     apply IH[y, d] to y_not_xxs
	rewrite s_l.
      }
    }
  }
end

theorem search_first: all xs:List<Nat>. all y:Nat, d:Nat, i:Nat.
  if i < length(xs) and nth(xs, d)(i) = y
  then search(xs, y) ≤ i
proof
  induction List<Nat>
  case empty {
    arbitrary y:Nat, d:Nat, i:Nat
    suppose prem
    definition search
    conclude 0 ≤ i   by definition operator ≤.
  }
  case node(x, xs') suppose IH {
    arbitrary y:Nat, d:Nat, i:Nat
    suppose prem
    suffices search(node(x,xs'),y) ≤ i
    definition search
    switch x = y {
      case true suppose xy {
        conclude 0 ≤ i   by definition operator ≤.
      }
      case false suppose not_xy {
        suffices suc(search(xs',y)) ≤ i
	switch i { 
          case 0 suppose i_z: i = 0 {
	    conclude false
	      by rewrite not_xy in definition nth in rewrite i_z in prem
	  }
	  case suc(i') suppose i_si: i = suc(i') {
	    suffices suc(search(xs',y)) ≤ suc(i')
	    definition operator ≤
	    conclude search(xs',y) ≤ i'
	        by enable {length, nth, pred, operator <, operator ≤}
		   apply IH[y,d,i'] to rewrite i_si in prem
	  }
	}
      }
    }
  }
end
