import Nat
import List
import Option

function summation(Nat, Nat, fn Nat->Nat) -> Nat {
  summation(0, begin, f) = 0
  summation(suc(k), begin, f) = f(begin) + summation(k, suc(begin), f)
}

function sum(List<Nat>) -> Nat {
  sum(empty) = 0
  sum(node(x, xs)) = x + sum(xs)
}

theorem summation_suc: all k:Nat. all f : fn Nat->Nat, g : fn Nat->Nat, s :Nat. 
  if (all i:Nat. f(i) = g(suc(i)))
  then summation(k, s, f) = summation(k, suc(s), g)
proof
  induction Nat
  case zero {
    arbitrary f : fn Nat->Nat, g : fn Nat->Nat, s :Nat
    assume _
    definition summation.
  }
  case suc(k') assume IH {
    arbitrary f : fn Nat->Nat, g : fn Nat->Nat, s :Nat
    assume f_g: all i:Nat. f(i) = g(suc(i))
    definition summation
    rewrite symmetric f_g[s]
    have IH': summation(k',suc(s),f) = summation(k',suc(suc(s)),g)
                 by apply IH[f,g,suc(s)] to f_g
    rewrite symmetric IH'.
  }
end

theorem sum_summation: all xs:List<Nat>.
  sum(xs) = summation(length(xs), 0, nth(xs,0))
proof
  induction List<Nat>
  case empty {
    definition {sum, length, nth, summation}.
  }
  case node(x, xs') assume IH: sum(xs') = summation(length(xs'),0,nth(xs',0)) {
    have nth_node: all i:Nat. nth(xs',0)(i) = nth(node(x,xs'),0)(suc(i))
      by arbitrary i:Nat definition {nth,pred}.
    have sum_01: summation(length(xs'), 0, nth(xs',0))
               = summation(length(xs'), 1, nth(node(x,xs'),0))
      by rewrite (apply summation_suc[length(xs')]
                    [nth(xs',0), nth(node(x,xs'), 0), 0] to nth_node).
    definition {sum, length, summation}
    have n_x: nth(node(x,xs'),0)(0) = x by definition nth.
    rewrite n_x
    equations
      x + sum(xs') = x + summation(length(xs'),0,nth(xs',0))     by rewrite IH.
               ... = x + summation(length(xs'),1,nth(node(x,xs'),0))
	                     by rewrite sum_01.
  }
end
