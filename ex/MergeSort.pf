import List
import Nat
import Pair
import Log

// first parameter is the sum of the lengths
function merge(Nat, List<Nat>, List<Nat>) -> List<Nat> {
  merge(0, xs, ys) = empty
  merge(suc(n), xs, ys) =
    switch xs {
      case empty { ys }
      case node(x, xs') {
        switch ys {
          case empty {
            node(x, xs')
          }
          case node(y, ys') {
            if x ≤ y then
              node(x, merge(n, xs', node(y, ys')))
            else
              node(y, merge(n, node(x, xs'), ys'))
          }
        }
     }
   }
}

function msort(Nat, List<Nat>) -> Pair< List<Nat>, List<Nat> > {
  msort(0, xs) =
    switch xs {
      case empty { pair(empty, empty) }
      case node(x, xs') { pair(node(x, empty), xs') }
    }
  msort(suc(n'), xs) =
    let p1 = msort(n', xs)
    let p2 = msort(n', second(p1))
    let ys = first(p1)
    let zs = first(p2)
    pair(merge(length(ys) + length(zs), ys, zs), second(p2))
}

define merge_sort : fn List<Nat> -> List<Nat>
  = λxs{ first(msort(log(length(xs)), xs)) }
  
assert merge_sort(empty) = empty
assert merge_sort(node(1, empty)) = node(1, empty)
assert merge_sort(node(2, node(1, empty))) = node(1, node(2, empty))
assert merge_sort(node(3, node(2, node(1, empty))))
       = node(1, node(2, node(3, empty)))
assert merge_sort(node(4, node(3, node(2, node(1, empty)))))
       = node(1, node(2, node(3, node(4, empty))))

function sorted(List<Nat>) -> bool {
  sorted(empty) = true
  sorted(node(a, next)) =
    sorted(next) and all_elements(next, λb{ a ≤ b })
}

theorem length_zero_empty: all T:type, xs:List<T>.
  if length(xs) = 0
  then xs = empty
proof
  arbitrary T:type, xs:List<T>
  suppose len_z
  switch xs {
    case empty { . }
    case node(x,xs') suppose xs_xxs {
        conclude false by definition length in
                          rewrite xs_xxs in len_z
    }
  }
end

theorem merge_contents: all n:Nat. all xs:List<Nat>, ys:List<Nat>.
  if length(xs) + length(ys) = n
  then mset_of(merge(n, xs, ys)) = mset_of(xs) ⨄ mset_of(ys)
proof
  induction Nat
  case 0 {
    arbitrary xs:List<Nat>, ys:List<Nat>
    suppose prem: length(xs) + length(ys) = 0
    have lxs_lys_z: length(xs) = 0 and length(ys) = 0
      by apply add_to_zero[length(xs)][length(ys)] to prem
    have xs_mt: xs = empty
      by apply length_zero_empty[Nat,xs] to lxs_lys_z
    have ys_mt: ys = empty
      by apply length_zero_empty[Nat,ys] to lxs_lys_z
    rewrite xs_mt | ys_mt
    definition {merge, mset_of}
    symmetric m_sum_empty[Nat, m_fun(λx{0}) :MultiSet<Nat>]
  }
  case suc(n') suppose IH {
    arbitrary xs:List<Nat>, ys:List<Nat>
    suppose prem: length(xs) + length(ys) = suc(n')
    switch xs {
      case empty {
        definition {merge, mset_of}
        conclude mset_of(ys) = m_fun(λx{0}) ⨄ mset_of(ys)
          by symmetric empty_m_sum[Nat, mset_of(ys)]
      }
      case node(x, xs') suppose xs_xxs {
        switch ys {
          case empty {
            definition {merge, mset_of}
            rewrite m_sum_empty[Nat, m_one(x) ⨄ mset_of(xs')].
          }
          case node(y, ys') suppose ys_yys {
            definition merge
            switch x ≤ y {
              case true suppose xy_true {
                definition mset_of
                have sxs_sys_sn: suc(length(xs')) + suc(length(ys')) = suc(n')
                  by enable length rewrite xs_xxs | ys_yys in prem
                have len_xs_yys: length(xs') + length(node(y,ys')) = n'
                  by enable {operator +,length}
                     injective suc sxs_sys_sn
                have IH': mset_of(merge(n',xs',node(y,ys')))
                        = mset_of(xs') ⨄ mset_of(node(y, ys'))
                  by apply IH[xs', node(y, ys')] to len_xs_yys
                rewrite IH'
                definition mset_of
                rewrite m_sum_assoc[Nat, m_one(x), mset_of(xs'),
                                    (m_one(y) ⨄ mset_of(ys'))].
              }
              case false suppose xy_false {
                definition mset_of
                have sxs_sys_sn: suc(length(xs')) + suc(length(ys')) = suc(n')
                  by enable length rewrite xs_xxs | ys_yys in prem
                have len_xxs_ys: length(node(x,xs')) + length(ys') = n'
                  by enable {operator +,length}
                     injective suc
                     rewrite add_suc[length(xs')][length(ys')] in
                     sxs_sys_sn
                have IH': mset_of(merge(n',node(x,xs'),ys'))
                        = mset_of(node(x,xs')) ⨄ mset_of(ys')
                  by apply IH[node(x,xs'), ys'] to len_xxs_ys
                rewrite IH'
                definition mset_of
                equations
                  m_one(y) ⨄ ((m_one(x) ⨄ mset_of(xs')) ⨄ mset_of(ys'))
                      = m_one(y) ⨄ (m_one(x) ⨄ (mset_of(xs') ⨄ mset_of(ys')))
                      by rewrite m_sum_assoc[Nat, m_one(x), mset_of(xs'),
                                             mset_of(ys')].
                  ... = (m_one(y) ⨄ m_one(x)) ⨄ (mset_of(xs') ⨄ mset_of(ys'))
                      by rewrite m_sum_assoc[Nat, m_one(y), m_one(x),
                               (mset_of(xs') ⨄ mset_of(ys'))].
                  ... = (m_one(x) ⨄ m_one(y)) ⨄ (mset_of(xs') ⨄ mset_of(ys'))
                      by rewrite m_sum_sym[Nat, m_one(x), m_one(y)].
                  ... = m_one(x) ⨄ (m_one(y) ⨄ (mset_of(xs') ⨄ mset_of(ys')))
                      by rewrite m_sum_assoc[Nat, m_one(x), m_one(y),
                          (mset_of(xs') ⨄ mset_of(ys'))].
                  ... = m_one(x) ⨄ ((m_one(y) ⨄ mset_of(xs')) ⨄ mset_of(ys'))
                      by rewrite m_sum_assoc[Nat, m_one(y), mset_of(xs'),
                          mset_of(ys')].
                  ... = m_one(x) ⨄ ((mset_of(xs') ⨄ m_one(y)) ⨄ mset_of(ys'))
                      by rewrite m_sum_sym[Nat, m_one(y), mset_of(xs')].
                  ... = m_one(x) ⨄ (mset_of(xs') ⨄ (m_one(y) ⨄ mset_of(ys')))
                      by rewrite m_sum_assoc[Nat, mset_of(xs'), m_one(y),
                         mset_of(ys')].
                  ... = (m_one(x) ⨄ mset_of(xs')) ⨄ (m_one(y) ⨄ mset_of(ys'))
                      by rewrite m_sum_assoc[Nat, m_one(x), mset_of(xs'),
                          (m_one(y) ⨄ mset_of(ys'))].
              }
            }
          }
        }
      }
    }
  }
end

theorem set_of_merge: all xs:List<Nat>, ys:List<Nat>.
  set_of(merge(length(xs) + length(ys), xs, ys)) = set_of(xs) ∪ set_of(ys)
proof
  arbitrary xs:List<Nat>, ys:List<Nat>
  have mset_of_merge: mset_of(merge(length(xs) + length(ys), xs, ys))
                    = mset_of(xs) ⨄ mset_of(ys)
    by apply merge_contents[length(xs) + length(ys)][xs, ys] to .
  equations
    set_of(merge(length(xs) + length(ys), xs, ys))
        = set_of_mset(mset_of(merge(length(xs) + length(ys), xs, ys)))
          by symmetric som_mset_eq_set[Nat]
                             [merge(length(xs) + length(ys), xs, ys)]
    ... = set_of_mset(mset_of(xs)) ∪ set_of_mset(mset_of(ys))
          by rewrite mset_of_merge  som_union[Nat,mset_of(xs),mset_of(ys)]
    ... = set_of(xs) ∪ set_of(ys)
          by rewrite som_mset_eq_set[Nat][xs] | som_mset_eq_set[Nat][ys].
end

theorem merge_sorted: all n:Nat. all xs:List<Nat>, ys:List<Nat>.
  if sorted(xs) and sorted(ys) and
     length(xs) + length(ys) = n
  then sorted(merge(n, xs, ys))
proof
  induction Nat
  case 0 {
    arbitrary xs:List<Nat>, ys:List<Nat>
    suppose _
    definition merge
    conclude sorted(empty) by definition sorted.
  }
  case suc(n') suppose IH {
    arbitrary xs:List<Nat>, ys:List<Nat>
    suppose prem
    definition merge
    switch xs {
      case empty {
        conclude sorted(ys) by prem
      }
      case node(x, xs') suppose xs_xxs {
        switch ys {
          case empty {
            conclude sorted(node(x,xs'))  by rewrite xs_xxs in prem
          }
          case node(y, ys') suppose ys_yys {
            /* Apply the induction hypothesis
	     * to prove sorted(merge(n',xs',node(y,ys')))
	     */
            have s_xs: sorted(xs')
              by enable sorted rewrite xs_xxs in prem
            have s_yys: sorted(node(y,ys'))
              by rewrite ys_yys in prem
            have len_xs_yys: length(xs') + length(node(y,ys')) = n'
              by enable {operator +,length}
                 have sxs: suc(length(xs')) + suc(length(ys')) = suc(n')
                    by rewrite xs_xxs | ys_yys in prem
                 injective suc sxs
            have IH_xs_yys: sorted(merge(n',xs',node(y,ys')))
              by apply IH[xs',node(y,ys')]
                 to s_xs, s_yys, len_xs_yys

            /* Apply the induction hypothesis
	     * to prove sorted(merge(n',node(x,xs'),ys'))
	     */
            have len_xxs_ys: length(node(x,xs')) + length(ys') = n'
              by definition {operator +,length}
                 rewrite symmetric len_xs_yys
                 definition length
                 rewrite add_suc[length(xs')][length(ys')].
            have s_xxs: sorted(node(x, xs'))
              by enable sorted rewrite xs_xxs in prem
            have s_ys: sorted(ys')
              by definition sorted in rewrite ys_yys in prem
            have IH_xxs_ys: sorted(merge(n',node(x,xs'),ys'))
              by apply IH[node(x,xs'),ys']
                 to s_xxs, s_ys, len_xxs_ys

            have x_le_xs: all_elements(xs', λb{x ≤ b})
              by definition sorted in rewrite xs_xxs in prem
            have y_le_ys: all_elements(ys', λb{y ≤ b})
              by definition sorted in rewrite ys_yys in prem
            
            switch x ≤ y {
              case true suppose xy_true {
                definition sorted
                suffices sorted(merge(n',xs',node(y,ys'))) and
                         all_elements(merge(n',xs',node(y,ys')), λb{x ≤ b})
	      
                have x_y: x ≤ y by rewrite xy_true.
                have x_le_ys: all_elements(ys', λb{x ≤ b})
                  by have yz_xz: all z:Nat. if y ≤ z then x ≤ z
                       by arbitrary z:Nat suppose y_z
                          apply less_equal_trans[x][y,z] to x_y, y_z
                     apply all_elements_implies[Nat][ys']
                       [λb{y ≤ b} : fn Nat -> bool, λb{x ≤ b} : fn Nat -> bool]
                     to y_le_ys, yz_xz
                have x_le_yys: all_elements(node(y,ys'), λb{x ≤ b})
                  by definition all_elements  (x_y, x_le_ys)
                have x_le_m_xs_yys:
                  all_elements(merge(n',xs',node(y,ys')),λb{x ≤ b})
		  by apply member_implies_all_elements[Nat]
		              [merge(n',xs',node(y,ys'))]
		              [λb{x ≤ b}:fn Nat->bool]
	             to arbitrary z:Nat
		        suppose z_in_merge
			have z_in_xs_yys: z ∈ set_of(xs') ∪ set_of(node(y,ys'))
			  by rewrite set_of_merge[xs',node(y,ys')] in
			     rewrite symmetric len_xs_yys in z_in_merge
			cases apply member_union
			             [Nat,z,set_of(xs'),set_of(node(y,ys'))]
			      to z_in_xs_yys
			case z_in_xs {
			  apply all_elements_member[Nat][xs']
			                [z,λb{x ≤ b}:fn Nat->bool]
			  to x_le_xs, z_in_xs
			}
			case z_in_ys {
			  apply all_elements_member[Nat][node(y,ys')]
			      [z,λb{x ≤ b}:fn Nat->bool]
			  to x_le_yys, z_in_ys
			}
                IH_xs_yys, x_le_m_xs_yys
              }
              case false suppose xy_false {
                definition sorted
                suffices sorted(merge(n',node(x,xs'),ys')) and
                         all_elements(merge(n',node(x,xs'),ys'),λb{y ≤ b})
                have not_x_y: not (x ≤ y)
                  by suppose xs rewrite xy_false in xs
                have y_x: y ≤ x
                  by apply less_implies_less_equal[y][x] to
                     (apply not_less_equal_greater[x,y] to not_x_y)
                have x_le_implies_y_le: all z:Nat. if x ≤ z then y ≤ z
                  by arbitrary z:Nat suppose x_z
                     apply less_equal_trans[y][x,z] to y_x, x_z
                have y_le_xs: all_elements(xs', λb{y ≤ b})
                  by apply all_elements_implies[Nat][xs']
                       [λb{x ≤ b} : fn Nat -> bool, λb{y ≤ b} : fn Nat -> bool]
                     to x_le_xs, x_le_implies_y_le
                have y_le_xxs: all_elements(node(x,xs'), λb{y ≤ b})
                  by definition all_elements
                     y_x, y_le_xs
                have y_le_m_xxs_ys:
                  all_elements(merge(n',node(x,xs'),ys'),λb{y ≤ b})
		  by apply member_implies_all_elements[Nat]
		              [merge(n',node(x,xs'),ys')]
		              [λb{y ≤ b}:fn Nat->bool]
	             to arbitrary z:Nat
		        suppose z_in_merge
			have z_in_xxs_ys: z ∈ set_of(node(x,xs')) ∪ set_of(ys')
			  by rewrite set_of_merge[node(x,xs'),ys'] in
			     rewrite symmetric len_xxs_ys in z_in_merge
			cases apply member_union
			             [Nat,z,set_of(node(x,xs')),set_of(ys')]
			      to z_in_xxs_ys
			case z_in_xxs {
			  apply all_elements_member[Nat][node(x,xs')]
			                [z,λb{y ≤ b}:fn Nat->bool]
			  to y_le_xxs, z_in_xxs
			}
			case z_in_ys {
			  apply all_elements_member[Nat][ys']
			      [z,λb{y ≤ b}:fn Nat->bool]
			  to y_le_ys, z_in_ys
			}
                IH_xxs_ys, y_le_m_xxs_ys
              }
            }
          }
        }
      }
    }
  }
end

theorem msort_empty: all n:Nat.
  first(msort(n, empty)) = empty and
  second(msort(n, empty)) = empty
proof
  induction Nat
  case 0 {
    definition {msort, first, second}.
  }
  case suc(n') suppose IH {
    definition {msort, first,length}
    have first_empty: first(msort(n',empty)) = empty
      by rewrite conjunct 0 of IH.
    have second_empty: second(msort(n',empty)) = empty
      by rewrite conjunct 1 of IH.
    rewrite first_empty
    rewrite second_empty
    rewrite first_empty
    definition {operator +, merge, second}
    rewrite second_empty.
  }
end

theorem msort_first_empty: all n:Nat.
  first(msort(n, empty)) = empty
proof
  arbitrary n:Nat
  conjunct 0 of msort_empty[n]
end

theorem msort_second_empty: all n:Nat.
  second(msort(n, empty)) = empty
proof
  arbitrary n:Nat
  conjunct 1 of msort_empty[n]
end

theorem msort_sorted: all n:Nat. all xs:List<Nat>. 
  sorted(first(msort(n, xs)))
proof
  induction Nat
  case 0 {
    arbitrary xs:List<Nat>
    switch xs {
      case empty {
        definition {msort, first, sorted}.
      }
      case node(x, xs') {
        definition {msort, first, sorted, sorted, all_elements}.
      }
    }
  }
  case suc(n') suppose IH {
    arbitrary xs:List<Nat>
    have IH1: sorted(first(msort(n',xs)))
      by IH[xs]
    have IH2: sorted(first(msort(n',second(msort(n',xs)))))
      by IH[second(msort(n',xs))]
    definition {msort, first}
    apply merge_sorted[length(first(msort(n',xs))) + length(first(msort(n',second(msort(n',xs)))))]
      [first(msort(n',xs)),
       first(msort(n',second(msort(n',xs))))] to IH1, IH2
  }
end

theorem merge_sort_sorted: all xs:List<Nat>.
  sorted(merge_sort(xs))
proof
  arbitrary xs:List<Nat>
  definition merge_sort
  msort_sorted[log(length(xs))][xs]
end

theorem merge_length: all n:Nat. all xs:List<Nat>, ys:List<Nat>.
  if length(xs) + length(ys) = n
  then length(merge(n, xs, ys)) = n
proof
  induction Nat
  case 0 {
    arbitrary xs:List<Nat>, ys:List<Nat>
    suppose _
    definition {merge, length}.
  }
  case suc(n') suppose IH {
    arbitrary xs:List<Nat>, ys:List<Nat>
    suppose prem
    definition {merge}
    switch xs {
      case empty suppose xs_empty {
        conclude length(ys) = suc(n')
          by definition {length, operator+} in
             rewrite xs_empty in prem
      }
      case node(x, xs') suppose xs_xxs {
        switch ys {
          case empty suppose ys_empty {
            conclude length(node(x,xs')) = suc(n')
              by definition {length}
                 rewrite add_zero[suc(length(xs'))] in
                 definition {length} in
                 rewrite xs_xxs | ys_empty in prem
          }
          case node(y, ys') suppose ys_yys {
            switch x ≤ y {
              case true {
                have suc_len_xs_yys:
                   suc(length(xs') + length(node(y,ys'))) = suc(n')
                  by definition {length}
                     definition {operator+} in
                     rewrite ys_yys in
                     definition length in
                     rewrite xs_xxs in prem
                have len_xs_yys: length(xs') + length(node(y,ys')) = n'
                   by injective suc suc_len_xs_yys
                definition length
                rewrite apply IH[xs', node(y, ys')] to len_xs_yys.
              }
              case false {
                definition length
                have suc_len: suc(length(xs) + length(ys')) = suc(n')
                  by rewrite add_suc[length(xs)][length(ys')] in
                     definition length in
                     rewrite ys_yys in prem
                rewrite (rewrite xs_xxs in apply IH[xs, ys']
                                          to injective suc suc_len).
              }
            }
          }
        }
      }
    }
  }
end

theorem msort_length: all n:Nat. all xs:List<Nat>.
  length(first(msort(n, xs)))  +  length(second(msort(n, xs))) = length(xs)
proof
  induction Nat
  case 0 {
    arbitrary xs:List<Nat>
    switch xs {
      case empty {
        definition {msort, first, second, length, operator+}.
      }
      case node(x, xs') {
        definition {msort, length, length, first, second, operator+, operator+}.
      }
    }
  }
  case suc(n') suppose IH {
    arbitrary xs:List<Nat>
    definition {msort, first, second}

    let ys = first(msort(n',xs))
    let ls = second(msort(n',xs))
    have ys_def: first(msort(n',xs)) = ys  by definition ys.
    have ls_def: second(msort(n',xs)) = ls  by definition ls.
    rewrite ys_def | ls_def
    
    let zs = first(msort(n', ls))
    let ms = second(msort(n', ls))
    have zs_def: first(msort(n', ls)) = zs by definition zs.
    have ms_def: second(msort(n', ls)) = ms by definition ms.
    rewrite zs_def | ms_def

    have ys_ls_xs: length(ys) + length(ls) = length(xs)
      by rewrite ys_def | ls_def in IH[xs]
    have zs_ms_ls: length(zs) + length(ms) = length(ls)
      by rewrite zs_def | ms_def in IH[ls]
    rewrite symmetric ys_ls_xs
    rewrite symmetric zs_ms_ls
    
    rewrite (apply merge_length[length(ys) + length(zs)][ys,zs] to .)
    rewrite add_assoc[length(ys)][length(zs), length(ms)]
    .
  }
end

theorem msort_contents: all n:Nat. all xs:List<Nat>.
  mset_of(first(msort(n, xs)))  ⨄  mset_of(second(msort(n, xs))) = mset_of(xs)
proof
  induction Nat
  case 0 {
    arbitrary xs:List<Nat>
    definition msort
    switch xs {
      case empty {
        definition {first, second, mset_of, operator ⨄,cnt, operator+}.
      }
      case node(x, xs') {
        definition {first, second, mset_of, mset_of}
        rewrite m_sum_empty[Nat,m_one(x)].
      }
    }
  }
  case suc(n') suppose IH {
    arbitrary xs:List<Nat>
    definition {msort, first, second}
    
    let ys = first(msort(n',xs))
    let ls = second(msort(n',xs))
    have ys_def: first(msort(n',xs)) = ys  by definition ys.
    have ls_def: second(msort(n',xs)) = ls  by definition ls.
    rewrite ys_def | ls_def
    
    let zs = first(msort(n', ls))
    let ms = second(msort(n', ls))
    have zs_def: first(msort(n', ls)) = zs by definition zs.
    have ms_def: second(msort(n', ls)) = ms by definition ms.
    rewrite zs_def | ms_def

    have IH1: mset_of(ys) ⨄ mset_of(ls) = mset_of(xs)
        by definition {ys, ls} IH[xs]
    have IH2: mset_of(zs) ⨄ mset_of(ms) = mset_of(ls)
        by definition {zs, ms} IH[ls]
    have m_ys_zs: mset_of(merge(length(ys) + length(zs), ys, zs)) = mset_of(ys) ⨄ mset_of(zs)
        by apply merge_contents[length(ys) + length(zs)][ys, zs] to .
    rewrite m_ys_zs
    rewrite symmetric IH1
    rewrite symmetric IH2
    rewrite m_sum_assoc[Nat, mset_of(ys), mset_of(zs), mset_of(ms)].
  }
end

assert msort(0, interval(10, 1)) = pair(interval(1,1), interval(9, 2))
assert msort(1, interval(10, 1)) = pair(interval(2,1), interval(8, 3))
assert msort(2, interval(10, 1)) = pair(interval(4,1), interval(6, 5))
assert msort(3, interval(10, 1)) = pair(interval(8,1), interval(2, 9))
assert msort(3, interval(8, 1)) = pair(interval(8,1), empty)
assert msort(3, interval(7, 1)) = pair(interval(7,1), empty)
assert msort(3, interval(6, 1)) = pair(interval(6,1), empty)

theorem msort_length_less_equal: all n:Nat. all xs:List<Nat>.
  if pow2(n) ≤ length(xs)
  then length(first( msort(n, xs) )) = pow2(n)
proof
  induction Nat
  case 0 {
    arbitrary xs:List<Nat>
    suppose prem
    switch xs {
      case empty suppose xs_mt {
        conclude false
            by definition {pow2, length, operator≤} in
               rewrite xs_mt in prem
      }
      case node(x, xs') suppose xs_xxs {
        definition {msort,first, length, length, pow2}.
      }
    }
  }
  case suc(n') suppose IH {
    arbitrary xs:List<Nat>
    suppose prem
    have len_xs: pow2(n') + pow2(n') ≤ length(xs)
      by rewrite add_zero[pow2(n')] in
         definition {pow2, operator*, operator*,operator*} in prem
    definition {pow2, msort, first}

    let ys = first(msort(n',xs))
    let ls = second(msort(n',xs))
    have ys_def: first(msort(n',xs)) = ys  by definition ys.
    have ls_def: second(msort(n',xs)) = ls  by definition ls.
    rewrite ys_def | ls_def
    
    let zs = first(msort(n', ls))
    let ms = second(msort(n', ls))
    have zs_def: first(msort(n', ls)) = zs by definition zs.
    have ms_def: second(msort(n', ls)) = ms by definition ms.
    rewrite zs_def | ms_def

    have p2n_le_xs: pow2(n') ≤ length(xs)
      by have p2n_le_2p2n: pow2(n') ≤ pow2(n') + pow2(n')
           by less_equal_add[pow2(n')][pow2(n')]
         apply less_equal_trans[pow2(n')][pow2(n') + pow2(n'), length(xs)]
         to p2n_le_2p2n, len_xs

    have len_ys: length(ys) = pow2(n')
      by rewrite ys_def in apply IH[xs] to p2n_le_xs
      
    have len_ys_ls_eq_xs: length(ys) + length(ls) = length(xs)
      by rewrite ys_def | ls_def in msort_length[n'][xs]

    have p2n_le_ls: pow2(n') ≤ length(ls)
      by have pp_pl: pow2(n') + pow2(n') ≤ pow2(n') + length(ls)
           by rewrite symmetric len_ys_ls_eq_xs | len_ys in len_xs
         apply less_equal_left_cancel[pow2(n')][pow2(n'), length(ls)] to pp_pl
            
    have len_zs: length(zs) = pow2(n')
      by rewrite zs_def in apply IH[ls] to p2n_le_ls

    have len_ys_zs: length(ys) + length(zs) = 2 * pow2(n')
      by rewrite len_ys | len_zs
         definition {operator*,operator*,operator*}
         rewrite add_zero[pow2(n')].

    conclude length(merge(length(ys) + length(zs),ys,zs)) = 2 * pow2(n')
      by rewrite len_ys_zs
         apply merge_length[2 * pow2(n')][ys, zs] to len_ys_zs
  }
end

theorem msort_length_less: all n:Nat. all xs:List<Nat>.
  if length(xs) < pow2(n)
  then length(first( msort(n, xs) )) = length(xs)
proof
  induction Nat
  case 0 {
    arbitrary xs:List<Nat>
    suppose prem
    switch xs {
      case empty suppose xs_mt {
        definition {msort, length, first}.
      }
      case node(x, xs') suppose xs_xxs {
        definition {msort,first, length, length}
        have xs_0: length(xs') = 0
          by definition {operator ≤, length, operator<, pow2} in rewrite xs_xxs in prem
        rewrite xs_0.
      }
    }
  }
  case suc(n') suppose IH {
    arbitrary xs:List<Nat>
    suppose prem
    definition{msort, first}

    let ys = first(msort(n',xs))
    let ls = second(msort(n',xs))
    have ys_def: first(msort(n',xs)) = ys  by definition ys.
    have ls_def: second(msort(n',xs)) = ls  by definition ls.
    rewrite ys_def | ls_def
    
    let zs = first(msort(n', ls))
    let ms = second(msort(n', ls))
    have zs_def: first(msort(n', ls)) = zs by definition zs.
    have ms_def: second(msort(n', ls)) = ms by definition ms.
    rewrite zs_def | ms_def

    have xs_le_two_p2n: length(xs) < pow2(n') + pow2(n')
      by rewrite add_zero[pow2(n')] in
         definition {pow2, operator*,operator*,operator*} in prem

    have ys_ls_eq_xs: length(ys) + length(ls) = length(xs)
      by rewrite ys_def | ls_def in msort_length[n'][xs]

    have pn_xs_or_xs_pn: pow2(n') ≤ length(xs) or length(xs) < pow2(n')
      by dichotomy[pow2(n'), length(xs)]
    cases pn_xs_or_xs_pn
    case pn_xs: pow2(n') ≤ length(xs) {
    
      have ys_pn: length(ys) = pow2(n')
          by rewrite ys_def in apply msort_length_less_equal[n'][xs] to pn_xs

      have ls_l_pn: length(ls) < pow2(n')
          by have pn_ls_l_2pn: pow2(n') + length(ls) < pow2(n') + pow2(n')
               by rewrite symmetric ys_ls_eq_xs | ys_pn in xs_le_two_p2n
             apply less_left_cancel[pow2(n'), length(ls), pow2(n')] to pn_ls_l_2pn

      have len_zs: length(zs) = length(ls)
          by rewrite zs_def in apply IH[ls] to ls_l_pn

      equations
        length(merge(length(ys) + length(zs),ys,zs))
            = length(ys) + length(zs)
              by apply merge_length[length(ys) + length(zs)][ys,zs] to .
        ... = length(ys) + length(ls)
              by rewrite len_zs.
        ... = length(xs)
              by ys_ls_eq_xs
    }
    case xs_pn: length(xs) < pow2(n') {
    
      have len_ys: length(ys) = length(xs)
        by rewrite ys_def in apply IH[xs] to xs_pn

      have len_ls: length(ls) = 0
        by apply left_cancel[length(ys)][length(ls), 0] to
           rewrite add_zero[length(ys)] | len_ys
           rewrite len_ys in ys_ls_eq_xs

      have ls_l_pn: length(ls) < pow2(n')
        by rewrite len_ls  pow_positive[n'] 
      
      have len_zs: length(zs) = 0
        by rewrite zs_def | len_ls in apply IH[ls] to ls_l_pn

      equations
        length(merge(length(ys) + length(zs),ys,zs))
          = length(ys) + length(zs)
            by apply merge_length[length(ys) + length(zs)][ys, zs] to .
      ... = length(xs)
            by rewrite len_zs | add_zero[length(ys)] | len_ys.
    }   
  }
end


theorem merge_sort_contents: all xs:List<Nat>.
  mset_of(merge_sort(xs)) = mset_of(xs)
proof
  arbitrary xs:List<Nat>
  definition merge_sort
  let n = log(length(xs))
  have n_def: log(length(xs)) = n  by definition n.
  let ys = first(msort(n,xs))
  have ys_def: first(msort(n,xs)) = ys  by definition ys.
  let ls = second(msort(n,xs))
  have ls_def: second(msort(n,xs)) = ls  by definition ls.
  
  have len_xs: length(xs) ≤ pow2(n)
    by rewrite symmetric n_def
       less_equal_pow_log[length(xs)]
  have len_ys: length(ys) = length(xs)
    by cases apply less_equal_implies_less_or_equal[length(xs)][pow2(n)]
             to len_xs
       case len_xs_less {
         rewrite ys_def in apply msort_length_less[n][xs] to len_xs_less
       }
       case len_xs_equal {
         have pn_le_xs: pow2(n) ≤ length(xs)
           by rewrite len_xs_equal  less_equal_refl[pow2(n)]
         have len_ys_pow2: length(ys) = pow2(n)
           by rewrite symmetric ys_def
              apply msort_length_less_equal[n][xs] to pn_le_xs
         transitive len_ys_pow2 (symmetric len_xs_equal)
       }
  have ys_ls_eq_xs: length(ys) + length(ls) = length(xs)
    by rewrite ys_def | ls_def in msort_length[n][xs]
  have len_ls: length(ls) = 0
    by apply left_cancel[length(ys)][length(ls), 0] to
       rewrite add_zero[length(ys)] | len_ys
       rewrite len_ys in ys_ls_eq_xs
  have ls_mt: ls = empty
    by apply length_zero_empty[Nat, ls] to len_ls

  have ys_ls_eq_xs: mset_of(ys)  ⨄  mset_of(ls) = mset_of(xs)
    by rewrite ys_def | ls_def in msort_contents[n][xs]

  rewrite n_def
  rewrite ys_def
  equations
    mset_of(ys)
        = mset_of(ys)  ⨄  m_fun(λx{0})
          by rewrite m_sum_empty[Nat, mset_of(ys)].
    ... = mset_of(ys)  ⨄  mset_of(ls)
          by rewrite ls_mt definition mset_of.
    ... = mset_of(xs)
          by ys_ls_eq_xs
end
