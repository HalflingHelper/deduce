/*
  This is inspired by the paper
  A Functional Approach to Standard Binary Heaps
  by Vladimir Kostyukov.

  This is a min-heap.
*/

import Nat
import Pair

union Direction {
  go_left;
  go_right;
}

union Heap {
  empty_heap;
  heap_node(Heap, Nat, Direction, Heap);
}

function bubble_up_left(Heap,Nat,Direction,Heap) -> Heap {
  bubble_up_left(empty_heap, x, d1, R) =
      heap_node(empty_heap, x, d1, R);
  bubble_up_left(heap_node(LL, y, d2, LR), x, d1, R) =
    if y < x then
      heap_node(heap_node(LL, x, d2, LR), y, d1, R)
    else
      heap_node(heap_node(LL, y, d2, LR), x, d1, R);
}

// Note the flip of the argument order!
function bubble_up_right(Heap,Nat,Direction,Heap) -> Heap {
  bubble_up_right(empty_heap, x, d1, L) =
    heap_node(L, x, d1, empty_heap);
  bubble_up_right(heap_node(RL, y, d2, RR), x, d1, L) =
    if y < x then
      heap_node(L, y, d1, heap_node(RL, x, d2, RR))
    else
      heap_node(L, x, d1, heap_node(RL, y, d2, RR));
}

// The insert(H,x) function creates a new heap that includes all the
// keys in the heap H as well as the key x. It returns the new heap
// and a boolean that indicates whether the new heap is a perfect
// binary tree.

function insert(Heap,Nat) -> Pair<Heap,bool> {
  insert(empty_heap, x) =
    pair(heap_node(empty_heap, x, go_left, empty_heap), true);
  insert(heap_node(L, y, d, R), x) =
    switch d {
      case go_left {
        let p = insert(L, x);
        let dir = if second(p) then go_right else go_left;
        pair(bubble_up_left(first(p), y, dir, R), false)
      }
      case go_right {
        let p = insert(R, x);
        let dir = if second(p) then go_left else go_right;
        pair(bubble_up_right(first(p), y, dir, L), second(p))
      }
    };
}

function smaller_parent(Heap, Nat) -> bool {
  smaller_parent(empty_heap, p) = true;
  smaller_parent(heap_node(L, c, d, R), p) = p ≤ c;
}

function is_heap(Heap) -> bool {
  is_heap(empty_heap) = true;
  is_heap(heap_node(L, x, d, R)) =
    is_heap(L) and is_heap(R) and smaller_parent(L, x) and smaller_parent(R, x);
}

//---------------- Testing insert ----------------------------------------------

define H1 = heap_node(empty_heap, 1, go_left, empty_heap)
define H2 = heap_node(empty_heap, 2, go_left, empty_heap)
define H12 = heap_node(H2, 1, go_right, empty_heap)
define H3 = heap_node(empty_heap, 3, go_left, empty_heap)
define H123 = heap_node(H2, 1, go_left, H3)
define H4 = heap_node(empty_heap, 4, go_left, empty_heap)
define H24 = heap_node(H4, 2, go_right, empty_heap)
define H1234 = heap_node(H24, 1, go_left, H3)
define H142 = heap_node(H4, 1, go_left, H2)
define H01234 = heap_node(H142, 0, go_right, H3)

theorem insert_H1: insert(empty_heap, 1) = pair(H1, true)
proof
  apply H1, insert in goal; reflexive
end

theorem insert_H12: insert(H1, 2) = pair(H12, false)
proof
  apply H1, H2, H12, insert, bubble_up_left, first, second, <, ≤ in goal;
  reflexive
end

theorem insert_H123: insert(H12, 3) = pair(H123, true)
proof
  apply H2, H3, H12, H123, insert, bubble_up_right, first, second, <, ≤ in goal;
  reflexive
end

theorem heap_H123: is_heap(H123)
proof
  apply H1, H2, H3, H123, is_heap, smaller_parent, ≤ in goal; .
end

theorem insert_H1234: insert(H123, 4) = pair(H1234, false)
proof
  apply H2, H3, H4, H24, H123, H1234, insert, bubble_up_left,
        first, second, <, ≤ in goal;
  reflexive
end

theorem heap_H1234: is_heap(H1234)
proof
  apply H2, H3, H4, H24, H123, H1234, is_heap, smaller_parent, <, ≤ in goal;
  .
end

theorem insert_H01234: insert(H1234, 0) = pair(H01234, false)
proof
  apply H2, H3, H4, H24, H142, H123, H1234, H01234, insert,
        bubble_up_left, bubble_up_right,
        first, second, <, ≤ in goal;
  reflexive
end

theorem heap_H01234: is_heap(H01234)
proof
  apply H2, H3, H4, H24, H142, H123, H1234, H01234,
      is_heap, smaller_parent, <, ≤ in goal;
  .
end

theorem bubble_up_left_nonempty:
  all L:Heap, x:Nat, d:Direction, R:Heap.
  some L1:Heap, x1:Nat, d1:Direction, R1:Heap.
  bubble_up_left(L, x, d, R) = heap_node(L1, x1, d1, R1)
proof
  arbitrary L:Heap, x:Nat, d:Direction, R:Heap;
  switch L {
    case empty_heap {
      choose empty_heap, x, d, R;
      apply bubble_up_left in goal; reflexive
    }
    case heap_node(LL, y, d2, LR) {
      apply bubble_up_left in goal;
      switch y < x {
        case true {
	  choose heap_node(LL,x,d2,LR), y, d, R;
	  reflexive
	}
	case false {
	  choose heap_node(LL,y,d2,LR),x,d,R;
	  reflexive
	}
      }
    }
  }
end

theorem bubble_up_right_nonempty:
  all L:Heap, x:Nat, d:Direction, R:Heap.
  some L1:Heap, x1:Nat, d1:Direction, R1:Heap.
  bubble_up_right(R, x, d, L) = heap_node(L1, x1, d1, R1)
proof
  arbitrary L:Heap, x:Nat, d:Direction, R:Heap;
  switch R {
    case empty_heap {
      apply bubble_up_right in goal;
      choose L, x, d, empty_heap;
      reflexive
    }
    case heap_node(RL, y, d2, RR) {
      apply bubble_up_right in goal;
      switch y < x {
	case true {
	  choose L, y, d, heap_node(RL,x,d2,RR);
	  reflexive
	}
	case false {
	  choose L, x, d, heap_node(RL,y,d2,RR);
	  reflexive
	}
      }
    }
  }
end


// note inconsistency between induction versus switch regarding
// whether the goal is updated with the cases. -Jeremy
theorem insert_nonempty:
  all x:Nat. all H: Heap.
  some L:Heap, y:Nat, d:Direction, R:Heap.
  first(insert(H, x)) = heap_node(L, y, d, R)
proof
  arbitrary x:Nat;
  induction Heap
  case empty_heap {
    choose empty_heap, x, go_left, empty_heap;
    apply insert, first in goal; reflexive
    }
  case heap_node(L1, y1, d1, R1) {
    have IHL1: (some L:Heap,y:Nat,d:Direction,R:Heap.
                  first(insert(L1,x)) = heap_node(L,y,d,R)) by IH;
    have IHR1: (some L:Heap,y:Nat,d:Direction,R:Heap.
                  first(insert(R1,x)) = heap_node(L,y,d,R)) by IH;
    switch d1 {
      case go_left {
	rewrite goal with EQ;
	obtain L1L, L1R, z, d2 with insertL1 from IHL1;
	apply insert, first in goal;
	rewrite goal with insertL1;
	switch second(insert(L1, x)) {
	  case true {
	    bubble_up_left_nonempty[heap_node(L1L,L1R,z,d2), y1, go_right, R1]
	  }
	  case false {
	    bubble_up_left_nonempty[heap_node(L1L,L1R,z,d2), y1, go_left, R1]
	  }
	}
      }
      case go_right {
	rewrite goal with EQ;
	obtain R1L, R1R, z, d2 with insertR1 from IHR1;
	apply insert, first in goal;
	rewrite goal with insertR1;
	switch second(insert(R1, x)) {
	  case true {
	    bubble_up_right_nonempty[L1, y1, go_left, heap_node(R1L,R1R,z,d2)]
	  }
	  case false {
	    bubble_up_right_nonempty[L1, y1, go_right, heap_node(R1L,R1R,z,d2)]
	  }
	}
      }
    }
  }
end

theorem heap_insert:
  all x:Nat. all H: Heap.
  if is_heap(H) then is_heap(first(insert(H, x)))
proof
  arbitrary x:Nat;
  induction Heap
  case empty_heap {
    assume prem;
    apply insert, first, is_heap, smaller_parent in goal;
    .
  }
  case heap_node(L, y, d, R) {
    assume prem: is_heap(heap_node(L,y,d,R));
    switch d {
      case go_left {
	rewrite goal with EQ;
	have is_heap_L: is_heap(L) by apply is_heap in prem;
        have is_heap_insertL: is_heap(first(insert(L, x)))
	  by using (conjunct 0 of IH) with is_heap_L;
	apply insert, first in goal;
	?
      }
      case go_right {
	have is_heap_R: is_heap(R) by apply is_heap in prem;
        have is_heap_insertR: is_heap(first(insert(R, x)))
	  by using (conjunct 1 of IH) with is_heap_R;
	?
      }
    }
  }
end

/*
function heapify(Heap) -> Heap {
  heapify(heap_node(x, L, R)) =
    switch L {
      case empty_heap {  heap_node(x, L, R) }
      case heap_node(y, LL, LR) {
        switch R {
          
        
        if y ≤ x then
          heap_node(x, L, R)
        else
          heap_node(y, heapify(heap_node(x, LL, LR)), R)
        
      }
    }
}
*/
