/*
  This is inspired by the paper
  A Functional Approach to Standard Binary Heaps
  by Vladimir Kostyukov.

  This is a min-heap.
*/

import Nat
import Pair

union Direction {
  go_left;
  go_right;
}

union Heap {
  empty_heap;
  heap_node(Heap, Nat, Direction, Heap);
}

function bubble_up_left(Heap,Nat,Direction,Heap) -> Heap {
  bubble_up_left(empty_heap, x, d1, R) =
      heap_node(empty_heap, x, d1, R);
  bubble_up_left(heap_node(LL, y, d2, LR), x, d1, R) =
    if y < x then
      heap_node(heap_node(LL, x, d2, LR), y, d1, R)
    else
      heap_node(heap_node(LL, y, d2, LR), x, d1, R);
}

// Note the flip of the argument order!
function bubble_up_right(Heap,Nat,Direction,Heap) -> Heap {
  bubble_up_right(empty_heap, x, d1, L) =
    heap_node(L, x, d1, empty_heap);
  bubble_up_right(heap_node(RL, y, d2, RR), x, d1, L) =
    if y < x then
      heap_node(L, y, d1, heap_node(RL, x, d2, RR))
    else
      heap_node(L, x, d1, heap_node(RL, y, d2, RR));
}

// The insert(H,x) function creates a new heap that includes all the
// keys in the heap H as well as the key x. It returns the new heap
// and a boolean that indicates whether the new heap is a perfect
// binary tree.

function insert2(Heap,Nat) -> Pair<Heap,bool> {
  insert2(empty_heap, x) =
    pair(heap_node(empty_heap, x, go_left, empty_heap), true);
  insert2(heap_node(L, y, d, R), x) =
    switch d {
      case go_left {
        let p = insert2(L, x);
        let dir = if second(p) then go_right else go_left;
        pair(bubble_up_left(first(p), y, dir, R), false)
      }
      case go_right {
        let p = insert2(R, x);
        let dir = if second(p) then go_left else go_right;
        pair(bubble_up_right(first(p), y, dir, L), second(p))
      }
    };
}

function insert(Heap,Nat) -> Pair<Heap,bool> {
  insert(empty_heap, x) =
    pair(heap_node(empty_heap, x, go_left, empty_heap), true);
  insert(heap_node(L, y, d, R), x) =
    let y' = if x < y then x else y;
    let x' = if x < y then y else x;
    switch d {
      case go_left {
	let p = insert(L, x');
        let dir = if second(p) then go_right else go_left;
        pair(heap_node(first(p), y', dir, R), false)	
      }
      case go_right {
	let p = insert(R, x');
        let dir = if second(p) then go_left else go_right;
        pair(heap_node(L, y', dir, first(p)), second(p))
      }
    };
}


function smaller_parent(Heap, Nat) -> bool {
  smaller_parent(empty_heap, p) = true;
  smaller_parent(heap_node(L, c, d, R), p) = p ≤ c;
}

function is_heap(Heap) -> bool {
  is_heap(empty_heap) = true;
  is_heap(heap_node(L, x, d, R)) =
    is_heap(L) and is_heap(R) and smaller_parent(L, x) and smaller_parent(R, x);
}

//---------------- Testing insert ----------------------------------------------

define H1 = heap_node(empty_heap, 1, go_left, empty_heap)
define H2 = heap_node(empty_heap, 2, go_left, empty_heap)
define H12 = heap_node(H2, 1, go_right, empty_heap)
define H3 = heap_node(empty_heap, 3, go_left, empty_heap)
define H123 = heap_node(H2, 1, go_left, H3)
define H4 = heap_node(empty_heap, 4, go_left, empty_heap)
define H24 = heap_node(H4, 2, go_right, empty_heap)
define H1234 = heap_node(H24, 1, go_left, H3)
define H142 = heap_node(H4, 1, go_left, H2)
define H01234 = heap_node(H142, 0, go_right, H3)

theorem insert_H1: insert(empty_heap, 1) = pair(H1, true)
proof
  apply H1, insert in goal; reflexive
end

theorem insert_H12: insert(H1, 2) = pair(H12, false)
proof
  apply H1, H2, H12, insert, bubble_up_left, first, second, <, ≤ in goal;
  reflexive
end

theorem insert_H123: insert(H12, 3) = pair(H123, true)
proof
  apply H2, H3, H12, H123, insert, bubble_up_right, first, second, <, ≤ in goal;
  reflexive
end

theorem heap_H123: is_heap(H123)
proof
  apply H1, H2, H3, H123, is_heap, smaller_parent, ≤ in goal; .
end

theorem insert_H1234: insert(H123, 4) = pair(H1234, false)
proof
  apply H2, H3, H4, H24, H123, H1234, insert, bubble_up_left,
        first, second, <, ≤ in goal;
  reflexive
end

theorem heap_H1234: is_heap(H1234)
proof
  apply H2, H3, H4, H24, H123, H1234, is_heap, smaller_parent, <, ≤ in goal;
  .
end

theorem insert_H01234: insert(H1234, 0) = pair(H01234, false)
proof
  apply H2, H3, H4, H24, H142, H123, H1234, H01234, insert,
        bubble_up_left, bubble_up_right,
        first, second, <, ≤ in goal;
  reflexive
end

theorem heap_H01234: is_heap(H01234)
proof
  apply H2, H3, H4, H24, H142, H123, H1234, H01234,
      is_heap, smaller_parent, <, ≤ in goal;
  .
end

theorem smaller_parent_trans:
  all L:Heap, x:Nat, y:Nat.
  if smaller_parent(L, x) and y ≤ x then smaller_parent(L, y)
proof
  arbitrary L:Heap, x:Nat, y:Nat;
  assume prem: smaller_parent(L, x) and y ≤ x;
  switch L {
    case empty_heap {
      apply smaller_parent in goal;
      .
    }
    case heap_node(LL, z, d, LR) {
      apply smaller_parent in goal;
      have x_z: x ≤ z by apply smaller_parent in (rewrite prem with EQ);
      have y ≤ z by using less_equal_trans[y][x,z] with (prem,x_z)
    }
  }
end
    
theorem heap_insert:
  all H: Heap. all x:Nat. 
  if is_heap(H)
  then is_heap(first(insert(H, x)))
       and (all z:Nat. if smaller_parent(H, z) and z ≤ x
                       then smaller_parent(first(insert(H,x)), z))
proof
  induction Heap
  case empty_heap {
    arbitrary x:Nat;
    assume prem;
    apply insert, first, is_heap, smaller_parent in goal;
    apply smaller_parent in goal;
    have (all z:Nat. if (z ≤ x) then z ≤ x)
        by (arbitrary z:Nat; assume zx : z ≤ x; zx)
  }
  case heap_node(L, y, d, R) {
    arbitrary x:Nat;
    assume prem: is_heap(heap_node(L,y,d,R));
    have is_heap_L: is_heap(L) by apply is_heap in prem;
    have is_heap_R: is_heap(R) by apply is_heap in prem;
    have L_y: smaller_parent(L,y) by apply is_heap in prem;
    have R_y: smaller_parent(R,y) by apply is_heap in prem;
    have is_heap_L_y: is_heap(first(insert(L, y)))
        by using (conjunct 0 of IH)[y] with is_heap_L;
    have is_heap_R_y: is_heap(first(insert(R, y)))
        by using (conjunct 1 of IH)[y] with is_heap_R;
    have is_heap_L_x: is_heap(first(insert(L, x)))
        by using (conjunct 0 of IH)[x] with is_heap_L;
    have is_heap_R_x: is_heap(first(insert(R, x)))
        by using (conjunct 1 of IH)[x] with is_heap_R;
    apply insert in goal;
    switch d {
      case go_left {
	apply first, is_heap in goal;
	switch x < y {
	  case true {
	    have x_l_y: x < y by (rewrite goal with EQ; .);
	    have x_y: x ≤ y by using less_implies_less_equal[x][y] with x_l_y;
	    have L_x: smaller_parent(L,x) 
  	        by using smaller_parent_trans[L, y, x] with (L_y, x_y);
	    have R_x: smaller_parent(R,x)
  	        by using smaller_parent_trans[R, y, x] with (R_y, x_y);
	    have Ly_x: smaller_parent(first(insert(L,y)),x)
	        by using (conjunct 1 of (using (conjunct 0 of IH)[y]
					 with (is_heap_L)))[x]
	           with (L_x, x_y);
	    have zx_zx: (all z:Nat. if (z ≤ y) and (z ≤ x) then z ≤ x)
			    by (arbitrary z:Nat; assume p; p);
	    apply smaller_parent in goal;
	    (is_heap_L_y, is_heap_R, Ly_x, R_x, zx_zx)
	  }
	  case false {
	    apply smaller_parent in goal;
	    have y_x: y ≤ x by using not_less_less_equal[x][y]
     	                       with (assume xy: x < y; rewrite xy with EQ);
	    have Lx_y: smaller_parent(first(insert(L,x)),y)
	      by using (conjunct 1 of (using (conjunct 0 of IH)[x]
				       with is_heap_L))[y]
   	         with (L_y, y_x);
            have zy_zy: all z:Nat. (if (z ≤ y) and (z ≤ x) then z ≤ y)
	      by (arbitrary z:Nat; assume p: z ≤ y and z ≤ x; p);
	    (is_heap_R, is_heap_L_x, Lx_y, R_y, zy_zy)
	  }
	}
      }
      case go_right {
	apply first, is_heap in goal;
	switch x < y {
	  case true {
	    have x_l_y: x < y by (rewrite goal with EQ; .);
	    have x_y: x ≤ y by using less_implies_less_equal[x][y] with x_l_y;
	    have L_x: smaller_parent(L,x)
	      by using smaller_parent_trans[L, y, x] with (L_y, x_y);
	    have R_x: smaller_parent(R,x)
  	        by using smaller_parent_trans[R, y, x] with (R_y, x_y);
	    have Ry_x: smaller_parent(first(insert(R,y)),x)
	        by using (conjunct 1 of (using (conjunct 1 of IH)[y]
					 with (is_heap_R)))[x]
	           with (R_x, x_y);
            apply smaller_parent in goal;
	    have zx_zx: (all z:Nat. (if (z ≤ y) and (z ≤ x) then z ≤ x))
	        by (arbitrary z: Nat; assume p; p);
	    (is_heap_L, is_heap_R_y, L_x, Ry_x, zx_zx)
	  }
	  case false {
	    apply smaller_parent in goal;
	    have y_x: y ≤ x by using not_less_less_equal[x][y]
     	                       with (assume xy: x < y; rewrite xy with EQ);
            have Rx_y: smaller_parent(first(insert(R,x)),y)
	      by using (conjunct 1 of (using (conjunct 1 of IH)[x]
				       with is_heap_R))[y]
   	         with (R_y, y_x);
            have zy_zy: all z:Nat. (if (z ≤ y) and (z ≤ x) then z ≤ y)
	      by (arbitrary z:Nat; assume p: z ≤ y and z ≤ x; p);
	    (is_heap_L, is_heap_R_x, L_y, Rx_y, zy_zy)
	  }
	}
      }
    }
  }
end
