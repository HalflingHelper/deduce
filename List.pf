import Nat
import Option
import Set
import MultiSet

union List<T> {
  empty
  node(T, List<T>)
}

function length<E>(List<E>) -> Nat {
  length(empty) = 0
  length(node(n, next)) = suc(length(next))
}

function append<E>(List<E>, List<E>) -> List<E> {
  append(empty, ys) = ys
  append(node(n, xs), ys) = node(n, append(xs, ys))
}

function reverse<E>(List<E>) -> List<E> {
  reverse(empty) = empty
  reverse(node(n, next)) = append(reverse(next), node(n, empty))
}

function set_of<T>(List<T>) -> Set<T> {
  set_of(empty) = ∅
  set_of(node(x, xs)) = single(x) ∪ set_of(xs)
}

function mset_of<T>(List<T>) -> MultiSet<T> {
  mset_of(empty) = m_fun(λ{0})
  mset_of(node(x, xs)) = m_one(x) ⨄ mset_of(xs)
}

assert length(empty) = 0
assert length(node(42, empty)) = 1

theorem length_one_nat: all x:Nat. length(node(x, empty)) = 1
proof
  arbitrary x:Nat
  definition {length, length, operator +}.
end

theorem length_one: all U :type, x:U. length(node(x, empty)) = 1
proof
  arbitrary U:type, x:U
  definition {length, length, operator +}.
end

define L1 = node(1, node(2, empty))
define L2 = node(3, node(4, node(5, empty)))
define L3 : List<Nat> = node(1, node(2, node(3, node(4, node(5, empty)))))

assert length(L1) = 2
assert length(L3) = 5
assert append(L1, L2) = L3
assert reverse(L1) = node(2, node(1, empty))
assert reverse(L2) = node(5, node(4, node(3, empty)))
assert length(append(L1, L2)) = length(L1) + length(L2)

theorem length_append: all U :type. all xs :List<U>. all ys :List<U>.
  length(append(xs, ys)) = length(xs) + length(ys)
proof
  arbitrary U :type
  enable {length, append, operator +, operator +}
  induction List<U>
  case empty {
    arbitrary ys:List<U>
    conclude length(append(empty,ys)) = length(empty) + length(ys)  by .
  }
  case node(n, xs') suppose IH {
    arbitrary ys :List<U>
    equations
      length(append(node(n,xs'),ys))
          = 1 + length(append(xs', ys))        by .
      ... = 1 + (length(xs') + length(ys))     by rewrite IH[ys].
      ... = length(node(n,xs')) + length(ys)   by .
  }
end

assert append(append(node(1, empty), node(2, empty)), node(3, empty))
     = append(node(1, empty), append(node(2, empty), node(3, empty)))

theorem append_assoc: all U :type. all xs :List<U>. all ys :List<U>, zs:List<U>.
  append(append(xs, ys), zs) = append(xs, append(ys, zs))
proof
  arbitrary U :type
  enable append
  induction List<U>
  case empty {
    arbitrary ys :List<U>, zs :List<U>
    conclude append(append(empty,ys),zs) = append(empty,append(ys,zs))  by .
  }
  case node(n, xs') suppose IH {
    arbitrary ys :List<U>, zs :List<U>
    equations
      append(append(node(n,xs'),ys),zs)
          = node(n,append(append(xs',ys),zs))  by .
      ... = append(node(n,xs'),append(ys,zs))  by rewrite IH[ys,zs].
  }
end

theorem append_empty: all U :type. all xs :List<U>.
  append(xs, empty) = xs
proof
  arbitrary U:type
  induction List<U>
  case empty {
    conclude append(empty, empty) = empty  by definition append.
  }
  case node(n, xs') suppose IH: append(xs',empty) = xs' {
    equations
      append(node(n,xs'),empty)
          = node(n, append(xs',empty))  by definition append.
      ... = node(n,xs')                 by rewrite IH.
  }
end

theorem length_reverse: all U :type. all xs :List<U>.
  length(reverse(xs)) = length(xs)
proof
  arbitrary U : type
  induction List<U>
  case empty {
    have length(reverse(empty)) = length(empty)  by definition reverse.
  }
  case node(n, xs') suppose IH {
    enable {length, reverse, operator +}
    equations
      length(reverse(node(n,xs')))
          = length(append(reverse(xs'), node(n,empty))) by .
      ... = length(reverse(xs')) + length(node(n,empty))
                    by rewrite
                        length_append[U][reverse(xs')][node(n,empty)].
      ... = length(xs') + 1        by rewrite IH.
      ... = length(node(n,xs'))    by rewrite add_one[length(xs')].
  }
end

assert reverse(append(L1, L2)) = append(reverse(L2), reverse(L1))

theorem reverse_append: all U :type. all xs :List<U>. all ys :List<U>.
  reverse(append(xs, ys)) = append(reverse(ys), reverse(xs))
proof
  arbitrary U :type
  induction List<U>
  case empty {
    arbitrary ys :List<U>
    equations
    reverse(append(empty,ys))
        = reverse(ys)                          by definition append.
    ... = append(reverse(ys),empty)
                by rewrite append_empty[U][reverse(ys)].
    ... = append(reverse(ys),reverse(empty))   by definition reverse.
  }
  case node(n, xs') suppose IH {
    arbitrary ys :List<U>
    enable {reverse, append}
    equations
      reverse(append(node(n,xs'),ys))
	  = reverse(node(n,append(xs',ys))) by .
      ... = append(append(reverse(ys), reverse(xs')), node(n, empty))
	    by rewrite IH[ys].
      ... = append(reverse(ys), append(reverse(xs'), node(n, empty)))
	    by append_assoc[U][reverse(ys)][reverse(xs'), node(n, empty)]
      ... = append(reverse(ys), reverse(node(n,xs'))) by .
  }
end

theorem reverse_reverse: all U :type. all ls :List<U>.
  reverse(reverse(ls)) = ls
proof
  arbitrary U :type
  induction List<U>
  case empty {
    have reverse(reverse(empty)) = empty by definition reverse.
  }
  case node(n, ls') suppose IH {
    enable {reverse, reverse, append, append}
    equations
      reverse(reverse(node(n,ls')))
          = reverse(append(reverse(ls'), node(n,empty))) by .
      ... = append(reverse(node(n,empty)), reverse(reverse(ls')))
                  by reverse_append[U][reverse(ls')][node(n,empty)]
      ... = append(reverse(node(n,empty)), ls')
                  by rewrite IH.
      ... = node(n,ls') by .
  }
end

function map<T,U>(List<T>, fn T->U) -> List<U> {
  map(empty, f) = empty
  map(node(x, ls), f) = node(f(x), map(ls, f))
}

assert map(L1, suc : fn Nat->Nat) = node(2, node(3, empty))

theorem length_map: all T:type, f:fn T->T. all xs:List<T>.
  length(map(xs, f)) = length(xs)
proof
  arbitrary T:type, f:fn T->T
  induction List<T>
  case empty {
    definition map.
  }
  case node(x, ls') suppose IH {
    enable {map, length, operator +}
    equations
      length(map(node(x,ls'),f))
          = suc(length(map(ls',f)))  by .
      ... = suc(length(ls'))         by rewrite IH.
      ... = length(node(x,ls'))      by .
  }
end

theorem map_id: all T:type, f:fn T->T. if (all x:T. f(x) = x) then
   all xs:List<T>. map(xs, f) = xs
proof
  arbitrary T:type, f:fn T->T
  suppose fxx: (all x:T. f(x) = x)
  induction List<T>
  case empty {
    have map(empty,f) = empty      by definition map.
  }
  case node(x, ls) suppose IH {
    equations
      map(node(x,ls),f)
          = node(f(x), map(ls, f)) by definition map.
      ... = node(x, map(ls, f))    by rewrite fxx[x].
      ... = node(x,ls)             by rewrite IH.
  }
end

define operator ∘ : < T,U,V > fn (fn U->V), (fn T->U) -> (fn T->V)
                  = generic T,U,V { λ g,f { λ x { g(f(x)) } } }

define id_nat : fn Nat -> Nat = λx{x}

assert (id_nat ∘ id_nat)(zero) = zero

theorem map_append: all T:type, f: fn T->T, ys:List<T>. all xs:List<T>.
  map(append(xs,ys), f) = append(map(xs,f), map(ys, f))
proof
  arbitrary T:type, f:fn T->T, ys:List<T>
  induction List<T>
  case empty {
    equations
      map(append(empty,ys), f)
          = map(ys, f)                       by definition append.
      ... = append(empty, map(ys, f))        by definition append.
      ... = append(map(empty,f), map(ys, f)) by definition map.
  }
  case node(x, xs')
    suppose IH: map(append(xs',ys), f) = append(map(xs',f), map(ys, f))
  {
    enable {map, append}
    equations
      map(append(node(x,xs'),ys),f)
          = node(f(x), map(append(xs',ys), f))         by .
      ... = node(f(x), append(map(xs',f), map(ys,f)))  by rewrite IH.
      ... = append(map(node(x,xs'),f),map(ys,f))       by .
  }
end

theorem map_compose: all T:type, U:type, V:type, f:fn T->U, g:fn U->V.
  all ls :List<T>. map(map(ls, f), g) = map(ls, g ∘ f)
proof
  arbitrary T:type, U:type, V:type, f:fn T->U, g:fn U->V
  induction List<T>
  case empty { definition map. }
  case node(x, ls) suppose IH {
    enable {map, operator ∘}
    equations
      map(map(node(x,ls),f),g)
	  = node(g(f(x)), map(map(ls, f), g))  by .
      ... = node(g(f(x)), map(ls, g ∘ f))      by rewrite IH.
      ... = map(node(x,ls), g ∘ f)             by .
  }
end

function foldr<T,U>(List<T>, U, fn T,U->U) -> U {
  foldr(empty, u, c) = u
  foldr(node(t, ls), u, c) = c(t, foldr(ls, u, c))
}

assert foldr(L1, 0, λa,b{ a + b }) = 3
assert foldr(L1, empty, λx,ls{ node(x,ls) }) = L1

function foldl<T,U>(List<T>, U, fn U,T->U) -> U {
  foldl(empty, u, c) = u
  foldl(node(t, ls), u, c) = foldl(ls, c(u, t), c)
}

assert foldl(L1, 0, λa,b{ a + b }) = 3
assert foldl(L1, empty, λls,x{ node(x,ls) }) = node(2,node(1,empty))

function down_from(Nat) -> List<Nat> {
  down_from(zero) = empty
  down_from(suc(n)) = node(n, down_from(n))
}

assert down_from(2) = node(1, node(0, empty))

define up_to : fn Nat -> List<Nat> = λ n { reverse(down_from(n)) }

assert up_to(2) = node(0, node(1, empty))
assert up_to(3) = node(0, node(1, node(2, empty)))

function range_aux(Nat, Nat, Nat) -> List<Nat> {
  range_aux(0, end, k) = map(up_to(end), (λ x { x + k }) : fn Nat->Nat)
  range_aux(suc(begin'), end, k) =
    switch end {
      case zero { empty } /* shouldn't happen */
      case suc(end') { range_aux(begin', end', suc(k)) }
    }
}

define range : fn Nat,Nat -> List<Nat> = λ b, e { range_aux(b, e, 0) }

assert range(0, 0) = empty
assert range(0, 1) = node(0, empty)
assert range(0, 2) = node(0, node(1, empty))
assert range(1, 3) = node(1, node(2, empty))
assert range(2, 5) = node(2, node(3, node(4, empty)))

function interval(Nat, Nat) -> List<Nat> {
  interval(zero, n) = empty
  interval(suc(k), n) = node(n, interval(k, suc(n)))
}

assert interval(0, 0) = empty
assert interval(1, 0) = node(0, empty)
assert interval(2, 0) = node(0, node(1, empty))
assert interval(3, 0) = node(0, node(1, node(2, empty)))

assert interval(0, 3) = empty
assert interval(1, 3) = node(3, empty)
assert interval(2, 3) = node(3, node(4, empty))
assert interval(3, 3) = node(3, node(4, node(5, empty)))

union Pair<T,U> {
  pair(T,U)
}

function first<T,U>(Pair<T,U>) -> T {
  first(pair(x,y)) = x
}

function second<T,U>(Pair<T,U>) -> U {
  second(pair(x,y)) = y
}

function zip<T,U>(List<T>, List<U>) -> List< Pair<T, U> > {
  zip(empty, ys) = empty
  zip(node(x, xs'), ys) =
    switch ys {
      case empty { empty }
      case node(y, ys') { node(pair(x,y), zip(xs', ys')) }
    }
}

function all_elements<T>(List<T>, fn (T) -> bool) -> bool {
  all_elements(empty, P) = true
  all_elements(node(x, xs'), P) = P(x) and all_elements(xs', P)
}

define L1_positive = all_elements(L1, λx{ 0 < x })

theorem zip_id_right: all T:type. all xs:List<T>. zip(xs, empty) = empty
proof
  arbitrary T:type
  induction List<T>
  case empty { definition zip. }
  case node(x, xs') { definition zip. }
end

define pairfun : < T1,T2,U1,U2 > fn (fn T1->T2), (fn U1->U2)
                                    -> (fn Pair<T1,U1> -> Pair<T2,U2>)
  = generic T1,T2,U1,U2 { λ f, g { λp{ pair(f(first(p)), g(second(p))) } } }

theorem zip_map: all T1:type, T2:type, U1:type, U2:type,
  f : fn T1 -> T2, g : fn U1 -> U2.
  all xs:List<T1>. all ys:List<U1>.
  zip(map(xs, f), map(ys, g)) = map(zip(xs,ys), pairfun(f,g))
proof
  arbitrary T1:type, T2:type, U1:type, U2:type, f:fn T1 -> T2, g:fn U1 -> U2
  enable {map, zip}
  induction List<T1>
  case empty {
    arbitrary ys:List<U1>
    conclude zip(map(empty,f),map(ys,g))
       = map(zip(empty:List<T1>,ys), pairfun(f,g))  by .
  }
  case node(x, xs') suppose IH {
    arbitrary ys:List<U1>
    switch ys {
      case empty suppose EQ { rewrite EQ. }
      case node(y, ys') {
	equations
	  zip(map(node(x,xs'),f),map(node(y,ys'),g))
	    = node(pair(f(x), g(y)), zip(map(xs',f), map(ys',g)))      by .
	... = node(pair(f(x), g(y)), map(zip(xs',ys'), pairfun(f,g)))
		by rewrite IH[ys'].
	... = map(zip(node(x,xs'),node(y,ys')), pairfun(f,g))
		by definition {first, second, pairfun}.
      }
    }
  }
end

function filter<E>(List<E>, fn (E)->bool) -> List<E> {
  filter(empty, P) = empty
  filter(node(x, ls), P) =
    if P(x) then node(x, filter(ls, P))
    else filter(ls, P)
}


theorem filter_all: all T:type, P:fn (T)->bool. all xs:List<T>. 
  if all_elements(xs, P) then filter(xs, P) = xs
proof
  arbitrary T:type, P:fn (T)->bool
  induction List<T>
  case empty {
    suppose cond: all_elements(empty,P)
    conclude filter(empty,P) = empty by definition filter.
  }
  case node(x, xs') suppose IH: if all_elements(xs',P) then filter(xs',P) = xs' {
    suppose Pxs: all_elements(node(x,xs'),P)
    definition filter
    have Px: P(x) by definition all_elements in Pxs
    rewrite Px
    suffices node(x,filter(xs',P)) = node(x,xs')
    have Pxs': all_elements(xs',P) by definition all_elements in Pxs
    have IH_conc: filter(xs',P) = xs' by apply IH to Pxs'
    rewrite IH_conc.
  }
end

theorem all_elements_implies: all T:type. all xs:List<T>. all P: fn T -> bool, Q: fn T -> bool.
  if all_elements(xs,P) and (all z:T. if P(z) then Q(z)) then all_elements(xs,Q)
proof
  arbitrary T:type
  induction List<T>
  case empty {
    arbitrary P: fn T -> bool, Q: fn T -> bool
    suppose _
    definition all_elements.
  }
  case node(x, xs') suppose IH {
    arbitrary P: fn T -> bool, Q: fn T -> bool
    suppose prem
    definition all_elements
    suffices Q(x) and all_elements(xs',Q)
    have Px: P(x) by definition all_elements in prem
    have Qx: Q(x) by apply (conjunct 1 of prem)[x] to Px
    have Pxs: all_elements(xs',P) by definition all_elements in prem
    Qx , apply IH[P,Q] to Pxs , prem
  }
end

theorem set_of_empty: all T:type, xs:List<T>.
  if set_of(xs) = ∅
  then xs = empty
proof
  arbitrary T:type, xs:List<T>
  switch xs {
    case empty {
      .
    }
    case node(x, xs') {
      suppose prem
      have x_xxs: x ∈ (single(x) ∪ set_of(xs'))
        by apply in_left_union[T,x,single(x),set_of(xs')]
	   to single_member[T, x]
      conclude false
        by apply empty_no_members[T,x]
	   to (rewrite (definition set_of in prem) in x_xxs)
    }
  }
end

theorem mset_of_empty: all T:type, xs:List<T>.
  if mset_of(xs) = m_fun(λx{0})
  then xs = empty
proof
  arbitrary T:type, xs:List<T>
  switch xs {
    case empty {
      .
    }
    case node(x, xs') {
      suppose prem
      have cnt_x_z: cnt(m_fun(λx{0} : fn T->Nat))(x) = 0
        by definition cnt.
      have cnt_x_pos: 1 ≤ cnt(m_fun(λx{0} : fn T->Nat))(x)
        by rewrite symmetric prem
	   definition {mset_of, cnt, operator ⨄, m_one}
	   less_equal_add[1][cnt(mset_of(xs'))(x)]
      conclude false
          by definition {cnt, operator ≤} in
	     (rewrite cnt_x_z in cnt_x_pos)
    }
  }
end

theorem som_mset_eq_set: all T:type. all xs:List<T>.
  set_of_mset(mset_of(xs)) = set_of(xs)
proof
  arbitrary T:type
  induction List<T>
  case empty {
    definition {mset_of, set_of, set_of_mset}
    have eq:(λx{(if cnt(m_fun(λx{0} : fn T->Nat))(x) = 0 then false else true)} : fn T->bool)
            = λ_{false}
     by extensionality
        arbitrary x:T
	definition {cnt}.
    rewrite eq.
  }
  case node(x, xs') suppose IH {
    definition {mset_of, set_of}
    rewrite som_union[T, m_one(x), mset_of(xs')]
    rewrite som_one_single[T, x]
    rewrite IH.
  }
end

function remove<T>(List<T>, T) -> List<T> {
  remove(empty, y) = empty
  remove(node(x, xs'), y) =
    if x = y then
      xs'
    else
      node(x, remove(xs', y))
}



function remove_all<T>(List<T>, T) -> List<T> {
  remove_all(empty, y) = empty
  remove_all(node(x, xs'), y) =
    if x = y then
      remove_all(xs', y)
    else
      node(x, remove_all(xs', y))
}

theorem remove_all_absent: all T:type. all xs:List<T>. all y:T.
  not (y ∈ set_of(remove_all(xs, y)))
proof
  arbitrary T:type
  induction List<T>
  case empty {
    arbitrary y:T
    definition {remove_all, set_of}
    empty_no_members[T,y]
  }
  case node(x, xs') suppose IH {
    arbitrary y:T
    definition {remove_all, set_of}
    switch x = y {
      case true {
        IH[y]
      }
      case false suppose xy_false {
	suppose y_in_sx_xsy
	have y_in_sx_or_xsy: y ∈ single(x) or y ∈ set_of(remove_all(xs',y))
	  by apply member_union[T,y,single(x), set_of(remove_all(xs',y))]
	     to y_in_sx_xsy
	cases y_in_sx_or_xsy
	case y_in_sx {
	  have xy: x = y by apply single_equal[T, x, y] to y_in_sx
	  conclude false by rewrite xy_false in xy
	}
	case y_in_xsy {
	  conclude false by apply IH[y] to y_in_xsy
	}
      }
    }
  }
end

theorem all_elements_member: all T:type. all ys: List<T>. all x:T, P: fn T->bool.
  if all_elements(ys, P) and x ∈ set_of(ys)
  then P(x)
proof
  arbitrary T:type
  induction List<T>
  case empty {
    arbitrary x:T, P:fn T->bool
    suppose prem
    enable {set_of, operator ∈, rep}
    conclude false  by prem
  }
  case node(y, ys') suppose IH {
    arbitrary x:T, P:fn T->bool
    suppose prem
    have x_sy_or_x_ys: x ∈ single(y) or x ∈ set_of(ys')
      by enable {set_of}
         apply member_union[T, x, single(y), set_of(ys')] to prem
    cases x_sy_or_x_ys
    case x_sy {
      have y_eq_x: y = x  by apply single_equal[T,y,x] to x_sy
      conclude P(x)   by enable {all_elements} rewrite y_eq_x in
	                 conjunct 0 of prem
    }
    case x_ys {
      have ys_P: all_elements(ys',P)
          by definition all_elements in conjunct 0 of prem
      conclude P(x)
          by apply IH[x,P] to ys_P, x_ys
    }
  }
end

theorem all_elements_set_of_implies:
  all T:type. all xs:List<T>. all ys:List<T>, P:fn T -> bool.
  if (all z:T. if z ∈ set_of(xs) then z ∈ set_of(ys)) and all_elements(ys, P)
  then all_elements(xs, P) 
proof
  arbitrary T:type
  induction List<T>
  case empty {
    arbitrary ys:List<T>, P:fn T -> bool
    suppose prem
    conclude all_elements(empty,P)
        by definition all_elements.
  }
  case node(x, xs') suppose IH {
    arbitrary ys:List<T>, P:fn T -> bool
    suppose prem
    definition all_elements
    suffices P(x) and all_elements(xs',P)
    have x_in_ys: x ∈ set_of(ys)
      by definition {set_of, operator ∈, single, operator ∪, rep} in
         (conjunct 0 of prem)[x]
    have P_x: P(x)
      by apply all_elements_member[T][ys][x, P] to prem, x_in_ys
    have xs_ys: all z:T. (if z ∈ set_of(xs') then z ∈ set_of(ys))
      by arbitrary z:T suppose z_xs
         have z_xxs: z ∈ set_of(node(x,xs'))
	     by enable {set_of, operator ∈, operator ∪, rep} z_xs
         apply (conjunct 0 of prem)[z] to z_xxs
    have xs_P: all_elements(xs',P)
      by apply IH[ys, P] to xs_ys, prem
    P_x, xs_P
  }
end

theorem all_elements_set_of: all T:type, xs:List<T>, ys:List<T>, P:fn T -> bool.
  if set_of(xs) = set_of(ys)
  then all_elements(xs, P) = all_elements(ys, P)
proof
  arbitrary T:type, xs:List<T>, ys:List<T>, P:fn T -> bool
  suppose xs_ys
  switch all_elements(xs, P) {
    case true suppose xs_P_true {
      have xs_P: all_elements(xs,P)
          by rewrite xs_P_true.
      have ys_xs: all z:T. (if z ∈ set_of(ys) then z ∈ set_of(xs))
          by arbitrary z:T suppose z_ys  rewrite xs_ys  z_ys
      rewrite (apply all_elements_set_of_implies[T][ys][xs, P] to xs_P, ys_xs).
    }
    case false suppose xs_P_false {
      have not_ys_P: not all_elements(ys,P)
        by suppose ys_P: all_elements(ys,P)
	   have xs_P: all_elements(xs, P)
	     by have xs_ys: all z:T. (if z ∈ set_of(xs) then z ∈ set_of(ys))
	         by arbitrary z:T suppose z_xs  rewrite symmetric xs_ys  z_xs
	        apply all_elements_set_of_implies[T][xs][ys, P] to xs_ys, ys_P
	   rewrite xs_P_false in xs_P
      rewrite not_ys_P.
    }
  }
end

theorem all_elements_append: all T:type. all xs:List<T>.
  all ys:List<T>, P:fn T -> bool.
  if all_elements(xs, P) and all_elements(ys, P)
  then all_elements(append(xs, ys), P)
proof
  arbitrary T:type
  induction List<T>
  case empty {
    arbitrary ys:List<T>, P:fn T -> bool
    suppose ys_P
    definition append
    conclude all_elements(ys, P) by ys_P
  }
  case node(x, xs') suppose IH {
    arbitrary ys:List<T>, P:fn T -> bool
    suppose all_xxs_ys
    definition {append, append, all_elements}
    suffices P(x) and all_elements(append(xs',ys),P)
    have Px: P(x)  by definition all_elements in all_xxs_ys
    have Pxsys: all_elements(append(xs',ys),P)
      by apply IH[ys,P] to definition all_elements in all_xxs_ys
    Px, Pxsys
  }
end

theorem set_of_append: all T:type. all xs:List<T>.
  all ys:List<T>.
  set_of(append(xs, ys)) = set_of(xs) ∪ set_of(ys)
proof
  arbitrary T:type
  induction List<T>
  case empty {
    arbitrary ys:List<T>
    definition {append, set_of}
    rewrite empty_union[T, set_of(ys)].
  }
  case node(x, xs') suppose IH {
    arbitrary ys:List<T>
    definition {append, set_of}
    rewrite IH[ys]
    rewrite union_assoc[T, single(x), set_of(xs'), set_of(ys)].
  }
end

function nth<T>(List<T>, T) -> (fn Nat -> T) {
  nth(empty, default) = λi{default}
  nth(node(x, xs), default) = λi{
    if i = 0 then
      x
    else
       nth(xs, default)(pred(i))
 }
}

function drop<T>(Nat, List<T>) -> List<T> {
  drop(0, xs) = xs
  drop(suc(n), xs) =
    switch xs {
      case empty { empty }
      case node(x, xs') { drop(n, xs') }
    }
}

theorem nth_drop: all T:type. all n:Nat. all xs:List<T>, i:Nat, d:T.
  nth(drop(n, xs), d)(i) = nth(xs, d)(n + i)
proof
  arbitrary T:type
  induction Nat
  case zero {
    arbitrary xs:List<T>, i:Nat, d:T
    definition {drop, operator+}.
  }
  case suc(n') suppose IH {
    arbitrary xs:List<T>, i:Nat, d:T
    definition drop
    switch xs {
      case empty {
        definition nth.
      }
      case node(x, xs') {
	definition nth
	have nsz: not (suc(n') + i = 0) by
	  suppose sz conclude false by definition operator + in sz
	rewrite nsz
	definition {pred, operator +}
	conclude nth(drop(n',xs'),d)(i) = nth(xs',d)(n' + i) by IH[xs',i,d]
      }
    }
  }
end

theorem nth_append_front: all T:type. all xs:List<T>. all ys:List<T>, i:Nat, d:T.
  if i < length(xs)
  then nth(append(xs, ys), d)(i) = nth(xs, d)(i)
proof
  arbitrary T:type
  induction List<T>
  case empty {
    arbitrary ys:List<T>, i:Nat, d:T
    suppose i_z: i < length(empty)
    conclude false by definition {length, operator <, operator ≤} in i_z
  }
  case node(x, xs) suppose IH {
    arbitrary ys:List<T>, i:Nat, d:T
    suppose i_xxs: i < length(node(x,xs))
    definition append
    switch i {
      case zero {
        definition nth.
      }
      case suc(i') suppose i_si {
        definition {nth, pred}
	have i_xs: i' < length(xs) by
	    enable {operator <, operator ≤}
	    conclude i' < length(xs) by rewrite i_si in definition length in i_xxs
	apply IH[ys, i', d] to i_xs
      }
    }
  }
end

theorem nth_append_back: all T:type. all xs:List<T>. all ys:List<T>, i:Nat, d:T.
  nth(append(xs, ys), d)(length(xs) + i) = nth(ys, d)(i)
proof
  arbitrary T:type
  induction List<T>
  case empty {
    arbitrary ys:List<T>, i:Nat, d:T
    definition {append, nth, length, operator +}.
  }
  case node(x, xs) suppose IH {
    arbitrary ys:List<T>, i:Nat, d:T
    definition {append,length, nth}
    have X: not (suc(length(xs)) + i = 0) by suppose eq_z enable operator + have false by eq_z
    rewrite X
    definition {operator +, pred}
    IH[ys, i, d]
  }
end

define flip : < T,U,V > fn (fn T,U->V) ->(fn U,T->V)
  = generic T,U,V { λf{ λx,y{ f(y,x) }}}

function rev_app<T>(List<T>, List<T>) -> List<T> {
  rev_app(empty, ys) = ys
  rev_app(node(x, xs), ys) = rev_app(xs, node(x, ys))
}

theorem rev_app_reverse_append: all T:type. all xs:List<T>. all ys:List<T>.
  rev_app(xs, ys) = append(reverse(xs), ys)
proof
  arbitrary T:type
  induction List<T>
  case empty {
    arbitrary ys:List<T>
    definition {append, rev_app,reverse}.
  }
  case node(x, xs') suppose IH {
    arbitrary ys:List<T>
    definition {append, rev_app, reverse}
    equations
      rev_app(xs', node(x,ys))
          = append(reverse(xs'), node(x,ys)) by IH[node(x,ys)]
      ... = append(reverse(xs'), append(node(x,empty), ys))
            by definition {append,append}.
      ... = append(append(reverse(xs'), node(x,empty)), ys)
            by symmetric append_assoc[T][reverse(xs')][node(x,empty),ys]
  }
end

theorem foldr_rev_app_foldl:
  all T:type. all xs:List<T>. all ys:List<T>, b:T, f:fn T,T->T.
  foldr(rev_app(xs,ys), b, f) = foldl(xs, foldr(ys,b,f), flip(f))
proof
  arbitrary T:type
  induction List<T>
  case empty {
    arbitrary ys:List<T>, b:T, f:fn T,T->T
    definition {rev_app,foldl}.
  }
  case node(x, xs') suppose IH {
    arbitrary ys:List<T>, b:T, f:fn T,T->T
    definition {rev_app}
    rewrite IH[node(x,ys),b,f]
    definition {foldl,flip,foldr}.
  }
end

theorem flip_flip:
  all T:type, f:fn T,T->T. flip(flip(f)) = f
proof
  arbitrary T:type, f:fn T,T->T
  extensionality
  arbitrary x:T, y:T
  definition flip.
end

theorem foldl_foldr:
  all T:type, xs:List<T>, b:T, f:fn T,T->T.
  foldl(xs, b, f) = foldr(reverse(xs), b, flip(f))
proof
  arbitrary T:type, xs:List<T>, b:T, f:fn T,T->T
  equations
    foldl(xs, b, f)
        = foldl(xs,foldr(empty,b,flip(f)),flip(flip(f)))
              by definition foldr rewrite flip_flip[T,f].
    ... = foldr(rev_app(xs,empty),b,flip(f))
              by symmetric foldr_rev_app_foldl[T][xs][empty,b,flip(f)]
    ... = foldr(append(reverse(xs),empty), b, flip(f))
              by rewrite rev_app_reverse_append[T][xs][empty].
    ... = foldr(reverse(xs), b, flip(f)) 
             by rewrite append_empty[T][reverse(xs)].
end

theorem mset_equal_implies_set_equal: all T:type, xs:List<T>, ys:List<T>.
  if mset_of(xs) = mset_of(ys)
  then set_of(xs) = set_of(ys)
proof
  arbitrary T:type, xs:List<T>, ys:List<T>
  suppose xs_ys
  equations
    set_of(xs) = set_of_mset(mset_of(xs))
               by symmetric som_mset_eq_set[T][xs]
           ... = set_of_mset(mset_of(ys))
               by rewrite xs_ys.
	   ... = set_of(ys)
               by som_mset_eq_set[T][ys]
end

/*
theorem mset_length: all T:type. all xs:List<T>. all ys:List<T>.
  if mset_of(xs) = mset_of(ys)
  then length(xs) = length(ys)
proof
  arbitrary T:type
  induction List<T>
  case empty {
    arbitrary ys:List<T>
    suppose prem
    definition {length}
    switch ys {
      case empty {
        .
      }
      case node(y, ys') suppose ys_yys {
	let m_empty = (λx{0} : fn T->Nat)
        have eq: m_empty
  	         = λx{(if y = x then 1 else 0) + cnt(mset_of(ys'))(x)}
	  by injective m_fun
	     definition m_empty
	     definition {mset_of,m_one,operator ⨄, cnt} in
	     rewrite ys_yys in prem
	have app_empty_z: m_empty(y) = 0
	   by definition m_empty.
	have not_app_empty_z: not (m_empty(y) = 0)
	   by rewrite eq
	      definition operator +.
        conclude false
          by apply not_app_empty_z to app_empty_z
      }
    }
  }
  case node(x, xs') suppose IH {
    arbitrary ys:List<T>
    suppose prem
    switch ys {
      case empty suppose ys_empty {
	let m_empty = (λx{0} : fn T->Nat)
        have eq: (λz{(if x = z then 1 else 0) + cnt(mset_of(xs'))(z)} : fn T->Nat)
  	         = m_empty
	  by injective m_fun
	     definition m_empty
	     definition {mset_of,m_one,operator ⨄, cnt} in
	     rewrite ys_empty in prem
	have app_empty_z: m_empty(x) = 0
	   by definition m_empty.
	have not_app_empty_z: not (m_empty(x) = 0)
	   by rewrite symmetric eq
	      definition operator+.
        conclude false
          by apply not_app_empty_z to app_empty_z
      }
      case node(y, ys') suppose ys_yys {
        definition length
        ?
      }
    }
  }
end
*/