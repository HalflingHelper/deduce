import Nat

union List<T> {
  empty;
  node(T, List<T>);
}

function length<E>(List<E>) -> Nat {
  length(empty) = 0;
  length(node(n, next)) = 1 + length(next);
}

function append<E>(List<E>, List<E>) -> List<E> {
  append(empty, ys) = ys;
  append(node(n, xs), ys) = node(n, append(xs, ys));
}

function reverse<E>(List<E>) -> List<E> {
  reverse(empty) = empty;
  reverse(node(n, next)) = append(reverse(next), node(n, empty));
}

theorem length_zero: length(empty) = 0
proof
  apply length in goal; .
end

theorem length_one: all U :type, x:U. length(node(x, empty)) = 1
proof
  arbitrary U:type, x:U;
  apply length, operator + in goal; .
end

define L1 = node(1, node(2, empty))
define L2 = node(3, node(4, node(5, empty)))
define L3 : List<Nat> = node(1, node(2, node(3, node(4, node(5, empty)))))

theorem length_L3: length(L3) = 5
proof
  apply L1, L2, L3, length, operator + in goal; .
end

theorem append_test: append(L1, L2) = L3
proof
  apply L1, L2, L3, append in goal; .
end

theorem reverse_test2: reverse(L1) = node(2, node(1, empty))
proof
  apply L1, reverse, append in goal; .
end

theorem reverse_test3: reverse(L2) = node(5, node(4, node(3, empty)))
proof
  apply L2, reverse, append in goal; .
end

theorem length_append_123: length(append(L1, L2)) = length(L1) + length(L2)
proof
  apply L1, L2, length, append, operator + in goal; .
end  

theorem length_append: all U :type. all xs :List<U>. all ys :List<U>.
  length(append(xs, ys)) = length(xs) + length(ys)
proof
  arbitrary U :type;
  induction List<U>
  case empty {
    arbitrary ys:List<U>;
    have length(append(empty,ys)) = length(empty) + length(ys)
        by apply length, append, operator + in goal; .
  }
  case node(n, xs') assume IH {
    arbitrary ys :List<U>;
    enable length, operator +, append;
    equations
      length(append(node(n,xs'),ys))
          = 1 + length(append(xs', ys))        by .
      ... = 1 + (length(xs') + length(ys))     by rewrite goal with IH[ys]; .
      ... = length(node(n,xs')) + length(ys)   by .
  }
end

theorem append_assoc1:
  append(append(node(1, empty), node(2, empty)), node(3, empty))
  = append(node(1, empty), append(node(2, empty), node(3, empty)))
proof
  apply append in goal; .
end  

theorem append_assoc: all U :type. all xs :List<U>. all ys :List<U>, zs:List<U>.
  append(append(xs, ys), zs) = append(xs, append(ys, zs))
proof
  arbitrary U :type;
  induction List<U>
  case empty {
    arbitrary ys :List<U>, zs :List<U>;
    have append(append(empty,ys),zs) = append(empty,append(ys,zs))
      by apply append in goal; .
  }
  case node(n, xs') assume IH {
    arbitrary ys :List<U>, zs :List<U>;
    enable append;
    equations
      append(append(node(n,xs'),ys),zs)
          = node(n,append(append(xs',ys),zs))  by .
      ... = append(node(n,xs'),append(ys,zs))  by rewrite goal with IH[ys,zs]; .
  }
end

theorem append_empty: all U :type. all xs :List<U>.
  append(xs, empty) = xs
proof
  arbitrary U :type;
  induction List<U>
  case empty {
    have append(empty, empty) = empty by apply append in goal; .
  }
  case node(n, xs') assume IH {
    equations
      append(node(n,xs'),empty)
          = node(n,append(xs',empty))     by apply append in goal; .
      ... = node(n,xs')                   by rewrite goal with IH; .
  }
end

theorem length_reverse: all U :type. all xs :List<U>.
  length(reverse(xs)) = length(xs)
proof
  arbitrary U : type;
  induction List<U>
  case empty {
    have length(reverse(empty)) = length(empty) by apply reverse in goal; .
  }
  case node(n, xs') assume IH {
    enable length, reverse, operator +;
    equations
      length(reverse(node(n,xs')))
          = length(append(reverse(xs'), node(n,empty))) by .
      ... = length(reverse(xs')) + length(node(n,empty))
                    by rewrite goal with
                       length_append[U][reverse(xs')][node(n,empty)]; .
      ... = length(xs') + 1        by rewrite goal with IH; .
      ... = length(node(n,xs'))    by rewrite goal with add_one[length(xs')]; .
  }
end

theorem reverse_append_123:
  reverse(append(L1, L2)) = append(reverse(L2), reverse(L1))
proof
  apply L1, L2, reverse, append in goal; .
end  

theorem reverse_append: all U :type. all xs :List<U>. all ys :List<U>.
  reverse(append(xs, ys)) = append(reverse(ys), reverse(xs))
proof
  arbitrary U :type;
  induction List<U>
  case empty {
    arbitrary ys :List<U>;
    equations
    reverse(append(empty,ys))
        = reverse(ys)                          by apply append in goal; .
    ... = append(reverse(ys),empty)
                by rewrite goal with append_empty[U][reverse(ys)]; .
    ... = append(reverse(ys),reverse(empty))   by apply reverse in goal; .
  }
  case node(n, xs') assume IH {
    arbitrary ys :List<U>;
    enable reverse, append;
    equations
      reverse(append(node(n,xs'),ys))
	  = reverse(node(n,append(xs',ys))) by .
      ... = append(append(reverse(ys), reverse(xs')), node(n, empty))
	    by rewrite goal with IH[ys]; .
      ... = append(reverse(ys), append(reverse(xs'), node(n, empty)))
	    by append_assoc[U][reverse(ys)][reverse(xs'), node(n, empty)]
      ... = append(reverse(ys), reverse(node(n,xs'))) by .
  }
end

theorem reverse_reverse: all U :type. all ls :List<U>.
  reverse(reverse(ls)) = ls
proof
  arbitrary U :type;
  induction List<U>
  case empty {
    have reverse(reverse(empty)) = empty by apply reverse in goal; .
  }
  case node(n, ls') assume IH {
    enable reverse, append;
    equations
      reverse(reverse(node(n,ls')))
          = reverse(append(reverse(ls'), node(n,empty))) by .
      ... = append(reverse(node(n,empty)), reverse(reverse(ls')))
                  by reverse_append[U][reverse(ls')][node(n,empty)]
      ... = append(reverse(node(n,empty)), ls')
                  by rewrite goal with IH; .
      ... = node(n,ls') by .
  }
end

function map<T,U>(List<T>, fn T->U) -> List<U> {
  map(empty, f) = empty;
  map(node(x, ls), f) = node(f(x), map(ls, f));
}

theorem map_suc: map(L1, suc : fn Nat->Nat) = node(2, node(3, empty))
proof
  apply L1, map in goal; .
end

theorem length_map: all T:type, f:fn T->T. all xs:List<T>.
  length(map(xs, f)) = length(xs)
proof
  arbitrary T:type, f:fn T->T;
  induction List<T>
  case empty {
    apply map in goal; .
  }
  case node(x, ls') assume IH {
    enable map, length, operator +;
    equations
      length(map(node(x,ls'),f))
          = suc(length(map(ls',f)))  by .
      ... = suc(length(ls'))         by rewrite goal with IH; .
      ... = length(node(x,ls'))      by .
  }
end

theorem map_id: all T:type, f:fn T->T. if (all x:T. f(x) = x) then
   all xs:List<T>. map(xs, f) = xs
proof
  arbitrary T:type, f:fn T->T;
  assume fxx: (all x:T. f(x) = x);
  induction List<T>
  case empty {
    have map(empty,f) = empty      by apply map in goal; .
  }
  case node(x, ls) assume IH {
    equations
      map(node(x,ls),f)
          = node(f(x), map(ls, f)) by apply map in goal; .
      ... = node(x, map(ls, f))    by rewrite goal with fxx[x]; .
      ... = node(x,ls)             by rewrite goal with IH; .
  }
end

define operator ∘ : < T,U,V > fn (fn U->V), (fn T->U) -> (fn T->V)
                  = generic T { λ g,f { λ x { g(f(x)) } } }

define id_nat : fn Nat -> Nat = λx{x}

theorem compose_test: (id_nat ∘ id_nat)(zero) = zero
proof
  apply operator ∘, id_nat in goal; .
end

theorem map_append: all T:type, f: fn T->T, ys:List<T>. all xs:List<T>.
  map(append(xs,ys), f) = append(map(xs,f), map(ys, f))
proof
  arbitrary T:type, f:fn T->T, ys:List<T>;
  induction List<T>
  case empty {
    apply map, append in goal; .
  }
  case node(x, xs') assume IH {
    enable map, append;
    equations
      map(append(node(x,xs'),ys),f)
          = node(f(x), map(append(xs',ys), f))    by .
      ... = node(f(x), append(map(xs',f), map(ys,f)))
                                        by (rewrite goal with IH; .)
      ... = append(map(node(x,xs'),f),map(ys,f))  by .
  }
end

theorem map_compose: all T:type, U:type, V:type, f:fn T->U, g:fn U->V.
  all ls :List<T>. map(map(ls, f), g) = map(ls, g ∘ f)
proof
  arbitrary T:type, U:type, V:type, f:fn T->U, g:fn U->V;
  induction List<T>
  case empty { apply map in goal; . }
  case node(x, ls) assume IH {
    enable map, operator ∘;
    equations
      map(map(node(x,ls),f),g)
	  = node(g(f(x)), map(map(ls, f), g))  by .
      ... = node(g(f(x)), map(ls, g ∘ f))      by rewrite goal with IH; .
      ... = map(node(x,ls), g ∘ f)             by .
  }
end

function foldr<T,U>(List<T>, U, fn T,U->U) -> U {
  foldr(empty, u, c) = u;
  foldr(node(t, ls), u, c) = c(t, foldr(ls, u, c));
}

theorem foldr_add12: foldr(L1, 0, λa,b{ a + b }) = 3
proof
  apply L1, foldr, operator + in goal; .
end

theorem foldr_id: foldr(L1, empty, λx,ls{ node(x,ls) }) = L1
proof
  apply L1, foldr in goal; .
end

function foldl<T,U>(List<T>, U, fn U,T->U) -> U {
  foldl(empty, u, c) = u;
  foldl(node(t, ls), u, c) = foldl(ls, c(u, t), c);
}

theorem foldl_add12: foldl(L1, 0, λa,b{ a + b }) = 3
proof
  apply L1, foldl, operator + in goal; .
end  

theorem foldl_rev12:
  foldl(L1, empty, λls,x{ node(x,ls) }) = node(2,node(1,empty))
proof
  apply L1, foldl in goal; .
end  


function down_from(Nat) -> List<Nat> {
  down_from(zero) = empty;
  down_from(suc(n)) = node(n, down_from(n));
}

theorem down_from2: down_from(2) = node(1, node(0, empty))
proof
  apply down_from in goal; .
end

define up_to : fn Nat -> List<Nat> = λ n { reverse(down_from(n)) }

theorem up_to2: up_to(2) = node(0, node(1, empty))
proof
  apply up_to, down_from, reverse, append in goal; .
end

theorem up_to3: up_to(3) = node(0, node(1, node(2, empty)))
proof
  apply up_to, down_from, reverse, append in goal; .
end

function range_aux(Nat, Nat, Nat) -> List<Nat> {
  range_aux(0, end, k) = map(up_to(end), (λ x { x + k }) : fn Nat->Nat);
  range_aux(suc(begin'), end, k) =
    switch end {
      case zero { empty } /* shouldn't happen */
      case suc(end') { range_aux(begin', end', suc(k)) }
    };
}

define range : fn Nat,Nat -> List<Nat> = λ b, e { range_aux(b, e, 0) }

theorem range_empty: range(0, 0) = empty
proof
  apply range, range_aux, up_to, down_from, reverse, map in goal; .
end  

theorem range1: range(0, 1) = node(0, empty)
proof
  apply range, range_aux, up_to, down_from, reverse, map, append, operator +
  in goal; .
end  

theorem range2: range(0, 2) = node(0, node(1, empty))
proof
  apply range, range_aux, up_to, down_from, reverse, map, append, operator +
  in goal; .
end  

theorem range13: range(1, 3) = node(1, node(2, empty))
proof
  apply range, range_aux, up_to, down_from, reverse, map, append, operator +
  in goal; .
end  

theorem range25: range(2, 5) = node(2, node(3, node(4, empty)))
proof
  apply range, range_aux, up_to, down_from, reverse, map, append, operator +
  in goal; .
end  

union Pair<T,U> {
  pair(T,U);
}

function first<T,U>(Pair<T,U>) -> T {
  first(pair(x,y)) = x;
}

function second<T,U>(Pair<T,U>) -> U {
  second(pair(x,y)) = y;
}

function zip<T,U>(List<T>, List<U>) -> List< Pair<T, U> > {
  zip(empty, ys) = empty;
  zip(node(x, xs'), ys) =
    switch ys {
      case empty { empty }
      case node(y, ys') { node(pair(x,y), zip(xs', ys')) }
    };
}

function all_elements<T>(List<T>, fn (T) -> bool) -> bool {
  all_elements(empty, P) = true;
  all_elements(node(x, xs'), P) = P(x) and all_elements(xs', P);
}

define L1_positive = all_elements(L1, λx{ 0 < x })

theorem zip_id_right: all T:type. all xs:List<T>. zip(xs, empty) = empty
proof
  arbitrary T:type;
  induction List<T>
  case empty { apply zip in goal; . }
  case node(x, xs') { apply zip in goal; . }
end

define pairfun : < T1,T2,U1,U2 > fn (fn T1->T2), (fn U1->U2)
                                    -> (fn Pair<T1,U1> -> Pair<T2,U2>)
  = generic T1,T2,U1,U2 { λ f, g { λp{ pair(f(first(p)), g(second(p))) } } }

theorem zip_map: all T1:type, T2:type, U1:type, U2:type,
  f : fn T1 -> T2, g : fn U1 -> U2.
  all xs:List<T1>. all ys:List<U1>.
  zip(map(xs, f), map(ys, g)) = map(zip(xs,ys), pairfun(f,g))
proof
  arbitrary T1:type, T2:type, U1:type, U2:type, f:fn T1 -> T2, g:fn U1 -> U2;
  induction List<T1>
  case empty {
      arbitrary ys:List<U1>;
      apply map, zip in goal; .
  }
  case node(x, xs') assume IH {
    arbitrary ys:List<U1>;
    switch ys {
    case empty assume EQ { rewrite goal with EQ; apply map, zip in goal; . }
    case node(y, ys') {
      enable map, zip;
      equations
        zip(map(node(x,xs'),f),map(node(y,ys'),g))
	  = node(pair(f(x), g(y)), zip(map(xs',f), map(ys',g)))      by .
      ... = node(pair(f(x), g(y)), map(zip(xs',ys'), pairfun(f,g)))
              by rewrite goal with IH[ys']; .
      ... = map(zip(node(x,xs'),node(y,ys')), pairfun(f,g))
              by apply first, second, pairfun in goal; .
    }
    }
  }
end