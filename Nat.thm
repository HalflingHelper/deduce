This file was automatically generated by Deduce.
This file summarizes the theorems proved in the file:
	./Nat.pf

zero_add: (all n:Nat. 0 + n = n)

add_zero: (all n:Nat. n + 0 = n)

suc_add: (all m:Nat, n:Nat. suc(m) + n = suc(m + n))

not_one_add_zero: (all n:Nat. not (1 + n = 0))

add_suc: (all m:Nat. (all n:Nat. m + suc(n) = suc(m + n)))

add_commute: (all n:Nat. (all m:Nat. n + m = m + n))

one_add: (all m:Nat. 1 + m = suc(m))

add_one: (all m:Nat. m + 1 = suc(m))

add_assoc: (all m:Nat. (all n:Nat, o:Nat. (m + n) + o = m + (n + o)))

left_cancel: (all x:Nat. (all y:Nat, z:Nat. (if x + y = x + z then y = z)))

add_to_zero: (all n:Nat. (all m:Nat. (if n + m = 0 then (n = 0 and m = 0))))

pred_one: pred(1) = 0

sub_cancel: (all n:Nat. n - n = 0)

sub_zero: (all n:Nat. n - 0 = n)

add_sub_identity: (all m:Nat. (all n:Nat. (m + n) - m = n))

sub_sub_eq_sub_add: (all x:Nat. (all y:Nat. (all z:Nat. (x - y) - z = x - (y + z))))

zero_mult: (all n:Nat. 0 * n = 0)

mult_zero: (all n:Nat. n * 0 = 0)

suc_mult: (all m:Nat, n:Nat. suc(m) * n = n + m * n)

mult_suc: (all m:Nat. (all n:Nat. m * suc(n) = m + m * n))

mult_commute: (all m:Nat. (all n:Nat. m * n = n * m))

one_mult: (all n:Nat. 1 * n = n)

mult_one: (all n:Nat. n * 1 = n)

two_mult: (all n:Nat. 2 * n = n + n)

dist_mult_add: (all a:Nat. (all x:Nat, y:Nat. a * (x + y) = a * x + a * y))

dist_mult_add_right: (all x:Nat, y:Nat, a:Nat. (x + y) * a = x * a + y * a)

mult_assoc: (all m:Nat. (all n:Nat, o:Nat. (m * n) * o = m * (n * o)))

suc_less_equal_iff_less_equal_suc: (all x:Nat, y:Nat. (x ≤ y ⇔ suc(x) ≤ suc(y)))

less_suc_iff_suc_less: (all x:Nat, y:Nat. (x < y ⇔ suc(x) < suc(y)))

less_equal_implies_less_or_equal: (all x:Nat. (all y:Nat. (if x ≤ y then (x < y or x = y))))

less_implies_less_equal: (all x:Nat. (all y:Nat. (if x < y then x ≤ y)))

less_equal_refl: (all n:Nat. n ≤ n)

equal_implies_less_equal: (all x:Nat, y:Nat. (if x = y then x ≤ y))

less_equal_antisymmetric: (all x:Nat. (all y:Nat. (if (x ≤ y and y ≤ x) then x = y)))

less_equal_trans: (all m:Nat. (all n:Nat, o:Nat. (if (m ≤ n and n ≤ o) then m ≤ o)))

not_less_less_equal: (all x:Nat. (all y:Nat. (if not (x < y) then y ≤ x)))

less_irreflexive: (all x:Nat. not (x < x))

less_not_equal: (all x:Nat, y:Nat. (if x < y then not (x = y)))

greater_not_equal: (all x:Nat, y:Nat. (if x > y then not (x = y)))

trichotomy: (all x:Nat. (all y:Nat. (x < y or x = y or y < x)))

trichotomy2: (all y:Nat, x:Nat. (if (not (x = y) and not (x < y)) then y < x))

positive_1_and_2: (0 ≤ 1 and 0 ≤ 2)

positive_2: 0 ≤ 2

less_implies_less_equal: (all x:Nat. (all y:Nat. (if x < y then x ≤ y)))

dichotomy: (all x:Nat, y:Nat. (x ≤ y or y < x))

zero_or_positive: (all x:Nat. (x = 0 or 0 < x))

zero_le_zero: (all x:Nat. (if x ≤ 0 then x = 0))

not_less_equal_iff_greater: (all x:Nat, y:Nat. (not (x ≤ y) ⇔ y < x))

less_implies_not_greater: (all x:Nat. (all y:Nat. (if x < y then not (y < x))))

not_less_equal_less_equal: (all x:Nat, y:Nat. (if not (x ≤ y) then y ≤ x))

not_zero_suc: (all n:Nat. (if not (n = 0) then some n':Nat. n = suc(n')))

positive_suc: (all n:Nat. (if 0 < n then some n':Nat. n = suc(n')))

less_equal_add: (all x:Nat. (all y:Nat. x ≤ x + y))

less_equal_add_left: (all x:Nat, y:Nat. y ≤ x + y)

less_equal_suc: (all n:Nat. n ≤ suc(n))

less_trans: (all m:Nat, n:Nat, o:Nat. (if (m < n and n < o) then m < o))

less_one_add: (all n:Nat. 0 < 1 + n)

greater_any_zero: (all x:Nat, y:Nat. (if x < y then 0 < y))

less_equal_left_cancel: (all x:Nat. (all y:Nat, z:Nat. (x + y ≤ x + z ⇔ y ≤ z)))

less_left_cancel: (all x:Nat, y:Nat, z:Nat. (x + y < x + z ⇔ y < z))

mult_mono_le: (all n:Nat. (all x:Nat, y:Nat. (if x ≤ y then n * x ≤ n * y)))

sub_add_assoc: (all n:Nat. (all l:Nat, m:Nat. (if m ≤ n then l + (n - m) = (l + n) - m)))

sub_add_identity: (all n:Nat. (all m:Nat. (if m ≤ n then m + (n - m) = n)))

less_equal_add_sub: (all m:Nat. (all n:Nat, o:Nat. (if (n ≤ m and m ≤ n + o) then m - n ≤ o)))

sub_less_zero: (all x:Nat. (all y:Nat. (if x ≤ y then x - y = 0)))

dist_mult_sub: (all x:Nat. (all y:Nat, z:Nat. x * (y - z) = x * y - x * z))

max_same: (all x:Nat. max(x, x) = x)

max_suc: (all x:Nat. max(suc(x), x) = suc(max(x, x)))

max_suc2: (all x:Nat, y:Nat. max(suc(x), suc(y)) = suc(max(x, y)))

max_greater_right: (all y:Nat. (all x:Nat. y ≤ max(x, y)))

max_greater_left: (all x:Nat. (all y:Nat. x ≤ max(x, y)))

max_is_left_or_right: (all x:Nat. (all y:Nat. (max(x, y) = x or max(x, y) = y)))

zero_max: (all x:Nat. max(0, x) = x)

max_zero: (all x:Nat. max(x, 0) = x)

max_symmetric: (all x:Nat. (all y:Nat. max(x, y) = max(y, x)))

max_assoc: (all x:Nat. (all y:Nat, z:Nat. max(max(x, y), z) = max(x, max(y, z))))

max_equal_greater_right: (all x:Nat. (all y:Nat. (if x ≤ y then max(x, y) = y)))

max_equal_greater_left: (all x:Nat. (all y:Nat. (if y ≤ x then max(x, y) = x)))

max_less_equal: (all x:Nat. (all y:Nat, z:Nat. (if (x ≤ z and y ≤ z) then max(x, y) ≤ z)))

addition_of_evens: (all x:Nat, y:Nat. (if (Even(x) and Even(y)) then Even(x + y)))

is_even_odd: (all n:Nat. ((if is_even(n) then Even(n)) and (if is_odd(n) then Odd(n))))

summation_cong: (all k:Nat. (all f:(fn Nat -> Nat), g:(fn Nat -> Nat), s:Nat, t:Nat. (if (all i:Nat. (if i < k then f(s + i) = g(t + i))) then summation(k, s, f) = summation(k, t, g))))

summation_cong4: (all k:Nat. (all f:(fn Nat -> Nat), g:(fn Nat -> Nat), s:Nat. (if (all i:Nat. (if (s ≤ i and i < s + k) then f(i) = g(i))) then summation(k, s, f) = summation(k, s, g))))

summation_suc: (all k:Nat. (all f:(fn Nat -> Nat), g:(fn Nat -> Nat), s:Nat. (if (all i:Nat. f(i) = g(suc(i))) then summation(k, s, f) = summation(k, suc(s), g))))

summation_cong3: (all k:Nat. (all f:(fn Nat -> Nat), g:(fn Nat -> Nat), s:Nat, t:Nat. (if (all i:Nat. f(s + i) = g(t + i)) then summation(k, s, f) = summation(k, t, g))))

summation_add: (all a:Nat. (all b:Nat, s:Nat, t:Nat, f:(fn Nat -> Nat), g:(fn Nat -> Nat), h:(fn Nat -> Nat). (if ((all i:Nat. (if i < a then g(s + i) = f(s + i))) and (all i:Nat. (if i < b then h(t + i) = f(s + (a + i))))) then summation(a + b, s, f) = summation(a, s, g) + summation(b, t, h))))

equal_refl: (all n:Nat. equal(n, n))

equal_complete_sound: (all m:Nat. (all n:Nat. (m = n ⇔ equal(m, n))))

not_equal_not_eq: (all m:Nat, n:Nat. (if not (equal(m, n)) then not (m = n)))

div2_add_2: (all n:Nat. div2(suc(suc(n))) = suc(div2(n)))

div2_double: (all n:Nat. div2(n + n) = n)

div2_times2: (all n:Nat. div2(2 * n) = n)

div2_suc_double: (all n:Nat. div2(suc(n + n)) = n)

div2_suc_times2: (all n:Nat. div2(suc(2 * n)) = n)

pos_positive: (all p:Pos. 0 < pos2nat(p))

pow_positive: (all n:Nat. 0 < pow2(n))

find_quotient_correct: (all u:Nat. (all q:Nat, n:Nat, m:Pos. (if (q * pos2nat(m) ≤ n and n < u * pos2nat(m)) then some r:Nat. (find_quotient(u, n, m, q) * pos2nat(m) + r = n and r < pos2nat(m)))))

mod_def: (all n:Nat, m:Pos. n % m = n - (n / m) * pos2nat(m))

division: (all n:Nat, m:Pos. some r:Nat. ((n / m) * pos2nat(m) + r = n and r < pos2nat(m)))

division_remainder: (all n:Nat, m:Pos. (n / m) * pos2nat(m) + n % m = n)

remainder_less_divisor: (all n:Nat, m:Pos. n % m < pos2nat(m))

