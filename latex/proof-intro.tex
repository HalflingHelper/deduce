\documentclass[12pt]{article}
\usepackage[noprint]{booklet}
% The following are necessary when using the print option of the booklet package. -Jeremy
\pdfoutput = 1
\setpdftargetpages

% When changing to the print option, uncomment the \nofiles
% to preserve the table of contents page numbering.

% When changing to the noprint option, comment the \nofiles.

%\nofiles

\pagespersignature{64}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\usepackage[margin=4cm,a4paper]{geometry}
\usepackage[object=vectorian]{pgfornament}
\usepackage{xfp}
\usetikzlibrary{calc}
\usepackage{blindtext}
\usepackage[manualmark]{scrlayer-scrpage}
% scrlayer-scrpage %
\clearpairofpagestyles
\addtokomafont{pagehead}{\color{blue!50!green!80!black}\large}
%\chead*{The current page style is \toplevelpagestyle{} \ifstr{\toplevelpagestyle}{\currentpagestyle}{}{as alias for \currentpagestyle}.}
\cfoot*{\pagemark}


%\newcommand\om{5mm}% ornament margin
\newcommand\om{27mm}% ornament margin
\newcommand\wom{33mm}% west ornament margin
\newcommand\som{10mm}% south ornament margin
\newcommand\nom{20mm}% north ornament margin
\newcommand\ow{2cm}% ornament width
\newcommand\oh{2cm}% ornament height
\newcommand\ols{0mm}% ornament line shift %1.5mm
%\newcommand\on{63}% ornament number
\newcommand\on{41}% ornament number
\newcommand\magicOrnamentOffset{0.25cm}


\def\lencorner{2}
\def\lencornerdivtwo{\fpeval{\lencorner/{2}}}
\def\lencornerdivthree{\fpeval{\lencorner/{3}}}
\newcommand\lencornerdivthreecm{\lencornerdivthree cm}
\newcommand\lencornerdivtwocm{\lencornerdivtwo cm}


\colorlet{bordercolor}{black}
\tikzset{mainborder/.style={line width=0.65mm}}
\tikzset{thinborder/.style={line width=0.2mm}}

% define the border and save it in a box
\newsavebox\border
\sbox\border{%
\tikz[color=bordercolor]{
  \useasboundingbox(0,0)rectangle(\paperwidth,-\paperheight);
  
  % ornaments %
  \foreach[count=\i]\a/\p/\s in {%
  north west/{\wom,-\nom}/none,
  north east/{{\paperwidth-\om},-\nom}/v,
  south east/{{\paperwidth-\om},{-\paperheight+\som}}/c,%
  south west/{\wom,{-\paperheight+\som}}/h%
  }\node[anchor=\a](n\i) at (\p){
    \pgfornament[width=\ow,height=\oh, symmetry=\s]{\on}
  };

  %% \begin{scope}[mainborder]
  %%   %% lines %%
  %%   \draw ([yshift=-\ols]n1.north east) -- ([yshift=-\ols]n2.north west);
  %%   \draw ([xshift=-\ols]n2.south east) -- ([xshift=-\ols]n3.north east);
  %%   \draw ([yshift=\ols]n3.south west) -- ([yshift=\ols]n4.south east) ;
  %%   \draw ([xshift=\ols]n4.north west) -- ([xshift=\ols]n1.south west);
  %%   %% corners %%
  %%   % top left %
  %%   \coordinate (B) at ([xshift=-\lencornerdivthreecm, yshift=-\lencornerdivthreecm]n1.north east);
  %%   \coordinate (C) at ([xshift=\lencornerdivthreecm, yshift=-\lencornerdivthreecm]n1.north west);
  %%   \draw (n1.south west) arc (180:90:\lencornerdivthree) -- (C) -- (B) arc (180:90:\lencornerdivthree);
  %%   % bottom left %
  %%   \coordinate (Y) at ([xshift=\lencornerdivthreecm, yshift=\lencornerdivthreecm]n4.south west);
  %%   \coordinate (Z) at ([xshift=-\lencornerdivthreecm, yshift=\lencornerdivthreecm]n4.south east);
  %%   \draw (n4.north west) arc (180:270:\lencornerdivthree) -- (Y) -- (Z) arc (180:270:\lencornerdivthree);
  %%   % top right %
  %%   \coordinate (S) at ([xshift=-\lencornerdivthreecm, yshift=-\lencornerdivthreecm]n2.north east);
  %%   \coordinate (T) at ([xshift=-\lencornerdivthreecm, yshift=\lencornerdivthreecm]n2.south east);
  %%   \draw (n2.north west) arc (90:0:\lencornerdivthree) -- (S) -- (T) arc (90:0:\lencornerdivthree);
  %%   % bottom right %
  %%   \coordinate (F) at ([xshift=-\lencornerdivthreecm, yshift=-\lencornerdivthreecm]n3.north east);
  %%   \coordinate (G) at ([xshift=-\lencornerdivthreecm, yshift=\lencornerdivthreecm]n3.south east);
  %%   \draw (n3.south west) arc (-90:0:\lencornerdivthree) -- (G) -- (F) arc (-90:0:\lencornerdivthree);
  %% \end{scope}

  [thin borders] %%
  \begin{scope}[thinborder]
    % top left
    \coordinate (topLeftBottom) at ([xshift=\ols+3mm, yshift=-3mm]n1.south west); %down
    \coordinate (topLeftTop) at ([xshift=3mm, yshift=\ols-3mm]n1.north east); %up
    \coordinate (topLeftCenter) at ([yshift=-\lencornerdivtwocm-\magicOrnamentOffset, xshift=\lencornerdivtwocm+\magicOrnamentOffset]n1.north west);
    % bottom left
    \coordinate (bottomLeftBottom) at ([xshift=+3mm, yshift=\ols+3mm]n4.south east);
    \coordinate (bottomLeftTop) at ([xshift=\ols+3mm, yshift=3mm]n4.north west);
    \coordinate (bottomLeftCenter) at ([yshift=\lencornerdivtwocm+\magicOrnamentOffset, xshift=\lencornerdivtwocm+\magicOrnamentOffset]n4.south west);
    % bottom right
    \coordinate (bottomRightBottom) at ([xshift=-4mm, yshift=\ols+3mm]n3.south west);
    \coordinate (bottomRightTop) at ([xshift=-\ols-4mm, yshift=3mm]n3.north east);
    \coordinate (bottomRightCenter) at ([yshift=\lencornerdivtwocm+\magicOrnamentOffset, xshift=-\lencornerdivtwocm-\magicOrnamentOffset]n3.south east); 
    % top right
    \coordinate (topRightBottom) at ([xshift=\ols-4mm, yshift=-\ols-3mm]n2.south east);
    \coordinate (topRightTop) at ([xshift=-\ols-4mm, yshift=-\ols-3mm]n2.north west);
    \coordinate (topRightCenter) at ([yshift=-\lencornerdivtwocm-\magicOrnamentOffset, xshift=-\lencornerdivtwocm-\magicOrnamentOffset]n2.north east); 
    %% lines %%
    \draw (topLeftTop) -- (topRightTop); % top
    \draw (bottomRightBottom) -- (bottomLeftBottom) ; % bottom 
    \draw (topRightBottom) -- (bottomRightTop); % right
    \draw (bottomLeftTop) -- (topLeftBottom); % left 
    %% top left %%
    %% % loops %
    %% \draw (topLeftBottom) arc (180:0:0.2) arc (0:-180:0.1) coordinate (topLeftLower); % bottom
    %% \draw (topLeftTop) arc (90:270:0.2) arc (-90:90:0.1) coordinate (topLeftUpper); %top
  %%   % brackets to center %
  %%   \draw (topLeftCenter) to [in=90, out=280] (topLeftLower); % left
  %%   \draw (topLeftUpper) to [in=0, out=175] (topLeftCenter); % right
  %%   %% bottom left %%
  %%   % loops %
  %%   \draw (bottomLeftBottom) arc (270:90:0.2) arc (90:-90:0.1) coordinate (bottomLeftLower);
  %%   \draw (bottomLeftTop) arc (-180:0:0.2) arc (0:180:0.1) coordinate (bottomLeftUpper);
  %%   % brackets to center %
  %%   \draw (bottomLeftCenter) to [in=175, out=0] (bottomLeftLower); % left
  %%   \draw (bottomLeftUpper) to [in=90, out=280] (bottomLeftCenter); % right
  %%   %% bottom right %%
  %%   %% loops %%
  %%   \draw (bottomRightBottom) arc (-90:90:0.2) arc (90:270:0.1) coordinate (bottomRightLower);
  %%   \draw (bottomRightTop) arc (0:-180:0.2) arc (180:0:0.1) coordinate (bottomRightUpper);
  %%   %% brackets to center %
  %%   \draw (bottomRightCenter) to [in=0, out=175] (bottomRightLower);
  %%   \draw (bottomRightUpper) to  [in=90, out=280] (bottomRightCenter);
  %%   %% top right %%
  %%   % loops %
  %%   \draw (topRightBottom) arc (0:180:0.2) arc (-180:0:0.1) coordinate (topRightLower);
  %%   \draw (topRightTop) arc (90:-90:0.2) arc (270:90:0.1) coordinate (topRightUpper);
  %%   % brackets to center %
  %%   \draw (topRightCenter) to [in=90, out=280] (topRightLower);
  %%   \draw (topRightUpper) to  [in=175, out=0] (topRightCenter);
  \end{scope}
}}


% define a switch to enable and disable the border
\newif\ifBorder
% define a new layer
\DeclareNewLayer[{%
    background,
    page,
    contents={\ifBorder\usebox\border\fi}
  }]{border.bg}
% add the border layer to all layer page styles (scrheadings, plain, empty, ...) ...
\AddLayersAtBeginOfPageStyle{@everystyle@}{border.bg}
% but no border on empty pages 
\AddToLayerPageStyleOptions{empty}{oninit=\Borderfalse}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\usepackage{palatino}
%\usepackage{garamond}
\usepackage{times}
\usepackage{listings}

\renewcommand\ttdefault{lmtt}

\setcounter{tocdepth}{1}

\usepackage{newunicodechar}
\newunicodechar{∷}{{::}}
\newunicodechar{⊤}{\ensuremath{\top}}
\newunicodechar{⊥}{\ensuremath{\bot}}
\newunicodechar{₁}{\ensuremath{_1}}
\newunicodechar{₂}{\ensuremath{_2}}
\newunicodechar{₃}{\ensuremath{_3}}

\newunicodechar{β}{\ensuremath{\beta}}
\newunicodechar{γ}{\ensuremath{\gamma}}
\newunicodechar{λ}{\ensuremath{\lambda}}
\newunicodechar{Λ}{\ensuremath{\Lambda}}
\newunicodechar{μ}{\ensuremath{\mu}}
\newunicodechar{ν}{\ensuremath{\nu}}
\newunicodechar{ρ}{\ensuremath{\rho}}
\newunicodechar{σ}{\ensuremath{\sigma}}
\newunicodechar{Π}{\ensuremath{\Pi}}
\newunicodechar{ξ}{\ensuremath{\xi}}
\newunicodechar{Γ}{\ensuremath{\Gamma}}
\newunicodechar{Δ}{\ensuremath{\Delta}}
\newunicodechar{Σ}{\ensuremath{\Sigma}}

\newunicodechar{≤}{\ensuremath{\leq}}


\title{Proving Theorems in Deduce}
\author{Jeremy G. Siek}


\begin{document}

%% \pagestyle{fancy}
%% \fancyhead{}
%% \fancyhead[L]{Programming in Deduce}
%% \fancyhead[R]{Jeremy G. Siek}
%%\fancyhead[L]{\pgfornament[width = 1cm]{39}}
%% \fancyhead[R]{\pgfornament[width = 1cm]{40}}

\Bordertrue

\maketitle

{\footnotesize
\tableofcontents
}
\pagebreak

%\large

%\section{Introduction}

This booklet introduces the Deduce proof language whereas the booklet
``Programming in Deduce`` introduces the programming language.  This
booklet freely uses definitions that were introduced in ``Programming
in Deduce``, so we recommend reading that booklet first.

\section{Theorems and Applying Definitions to the Goal}

We begin with a simple example, proving that the length of an empty
list is \texttt{0}. Of course, this is a direct consequence of the
definition of \texttt{length}, so this first example is about how to
use definitions.  To get started, we write down the theorem we would
like to prove.  A theorem consists of (1) the keyword
\texttt{theorem}, (2) a name for the theorem, (3) a colon, (4) the
formula, (5) the keyword \texttt{proof}, (6) the proof of the formula,
and (7) the keyword \texttt{end}. But for now, instead of writing the
proof, we'll simply write \texttt{?} to say that we're not done yet.

\begin{verbatim}
theorem length_nat_empty: length(@empty<Nat>) = 0
proof
  ?
end
\end{verbatim}

\noindent Run Deduce on the file. Deduce will respond with the following message
to remind us of what is left to prove.

\begin{verbatim}
incomplete proof:
    length(empty) = 0
\end{verbatim}

To tell Deduce to apply the definition of \texttt{length}, we can use
the \texttt{definition} statement.

\begin{verbatim}
theorem length_nat_empty: length(@empty<Nat>) = 0
proof
  definition length
end
\end{verbatim}

\noindent Deduce expanded the definition of \texttt{length} in the
goal, changing \texttt{length(empty) = 0} to \texttt{0 = 0}. In
particular, Deduce noticed that \texttt{length(empty)} matches the
first clause in the definition of \texttt{length} and then replaced it
with the right-hand side of the first clause. Deduce then simplified
\texttt{0 = 0} to \texttt{true} and therefore accepted the
\texttt{definition} statement. In general, whenever Deduce sees an
equality with the same left and right-hand side, it automatically
simplifies it to \texttt{true}.

Run Deduce on the file to see it respond that the file is valid.

Let's try a slightly more complex theorem, that the length
of a list with just a single node is indeed \texttt{1}. Based
on what we learned above, we better start by applying the
definition of \texttt{length} a couple of times.

\begin{verbatim}
theorem length_node42: length(node(42, empty)) = 1
proof
  definition {length, length}
end
\end{verbatim}

\noindent Deduce responds that we still need to prove the following
obvious fact.

\begin{verbatim}
failed to prove:
    length(node(42,empty)) = 1
by
    definition {length, length}
remains to prove:
    1 + 0 = 1
\end{verbatim}

\noindent But that is just a consequence of the definition of
addition, which we can refer to as \texttt{operator +}.  To carry on
with proving what remains, we can use the \texttt{suffices} statement
as follows. We write the formula that is left to prove after the
\texttt{suffices} keyword then \texttt{by} then the
\texttt{definition} statement that we're using to transform the goal.
After the \texttt{suffices}, the goal changes to the \texttt{suffices}
formula, which here is \texttt{1 + 0 = 1}.

\begin{verbatim}
theorem length_node42: length(node(42, empty)) = 1
proof
  suffices 1 + 0 = 1   with definition {length, length}
  definition {operator +, operator +}
end
\end{verbatim}

\subsection*{Exercise}

Prove that \texttt{node(1,empty) ++ node(2, empty) = node(1, node(2, empty))}.


\section{Generalizing with \texttt{all} Formulas}

In the proof of \texttt{length\_node42} it did not matter that the
element in the node was \texttt{42}. We can generalize this theorem by
using an \texttt{all} formula. We begin the formula with \texttt{all
  x:Nat} to say that the formula must be true for all natural numbers
and the variable \texttt{x} will be used as a stand-in to refer to any
of them.  We replace the \texttt{42} in the formula with \texttt{x} to
obtain the following theorem.

\begin{verbatim}
theorem length_one_nat: all x:Nat. length(node(x, empty)) = 1
proof
  ?
end
\end{verbatim}
Deduce responds with
\begin{verbatim}
incomplete proof:
    all x:Nat. length(node(x,empty)) = 1
\end{verbatim}

The most straightforward way to prove an \texttt{all} formula in
Deduce is with an \texttt{arbitrary} statement. When you use
\texttt{arbitrary} you are promising to prove the formula for a
hypothetical entity that can stand in for all entities of the
specified type. The \texttt{arbitrary} statement asks you to name the
hypothetical entity. Here we choose \texttt{x} but we could have
chosen a different name.

\begin{verbatim}
theorem length_one_nat: all x:Nat. length(node(x, empty)) = 1
proof
  arbitrary x:Nat
  ?
end
\end{verbatim}

\noindent Deduce responds with

\begin{verbatim}
incomplete proof:
    length(node(x,empty)) = 1
\end{verbatim}

We don't know anything about this hypothetical \texttt{x} other than
it being a natural number. But as we previously observed, we don't
need any more information about \texttt{x} for this proof.  We
complete the proof as before, using the definitions of \texttt{length}
and addition.

\begin{verbatim}
theorem length_one_nat: all x:Nat. length(node(x, empty)) = 1
proof
  arbitrary x:Nat
  definition {length, length, operator +, operator +}
end
\end{verbatim}

Once we have proved that an \texttt{all} formula is true, we can use it by
supplying an entity of the appropriate type inside square brackets. In
the following we prove the \texttt{length\_node42} theorem again, but this
time the proof makes use of \texttt{length\_one\_nat}.

\begin{verbatim}
theorem length_node42_again: length(node(42, empty)) = 1
proof
  length_one_nat[42]
end
\end{verbatim}

We can further generalize the theorem by noticing that it does not
matter whether the element is a natural number. It could be a value of
any type. In Deduce we can also use the \texttt{all} statement to
generalize types. In the following, we add \texttt{U:type} to the
\texttt{all} formula and to the \texttt{arbitrary} statement.

\begin{verbatim}
theorem length_one: all U:type, x:U. length(node(x, empty)) = 1
proof
  arbitrary U:type, x:U
  definition {length, length, operator +, operator+}
end
\end{verbatim}

To summarize this section:
\begin{itemize}
\item To state that a formula is true for all entities of a given
  type, use Deduce's \texttt{all} formula.
\item To prove that an \texttt{all} formula is true, use Deduce's
  \texttt{arbitrary} statement.  (We'll see a second method in 
  section~\ref{sec:induction}.)
\item To use a fact that is an \texttt{all} formula, instantiate the
  fact by using square brackets around the specific entity.
\end{itemize}

\subsection*{Exercise}

Prove that
\begin{verbatim}
all T:type, x:T, y:T. 
    node(x,empty) ++ node(y, empty) = node(x, node(y, empty))
\end{verbatim}

\noindent Prove again that 
\begin{verbatim}
node(1,empty) ++ node(2, empty) = node(1, node(2, empty))
\end{verbatim}
but this time use the previous theorem.

\pagebreak

\section{Rewriting the Goal with Equations}
\label{sec:rewriting-goal}

Deduce provides the \texttt{rewrite} statement to apply an equation to the
current goal. In particular, \texttt{rewrite} replaces each occurence of the
left-hand side of an equation with the right-hand side of the
equation.

For example, let us prove the following theorem using \texttt{rewrite}
with the above \texttt{length\_one} theorem.

\begin{verbatim}
theorem length_one_equal: all U:type, x:U, y:U.
  length(node(x,empty)) = length(node(y,empty))
proof
  arbitrary U:type, x:U, y:U
  ?
end
\end{verbatim}

To replace \texttt{length(node(x,empty))} with \texttt{1}, we rewrite
using the \texttt{length\_one} theorem instantiated at \texttt{U} and \texttt{x}.

\begin{verbatim}
rewrite length_one[U,x]
\end{verbatim}

\noindent Deduce tells us that the current goal has become

\begin{verbatim}
remains to prove:
        1 = length(node(y,empty))
\end{verbatim}

\noindent We rewrite again, separated by a vertical bar, using
\texttt{length\_one}, this time instantiated with \texttt{y}.

\begin{verbatim}
rewrite length_one[U,x] | length_one[U,y]
\end{verbatim}

\noindent Deduce changes the goal to \texttt{1 = 1}, which simplies to
just \texttt{true}, so Deduce accepts the \texttt{rewrite} statement.

Here is the completed proof of \texttt{length\_one\_equal}.

\begin{verbatim}
theorem length_one_equal: all U:type, x:U, y:U.
  length(node(x,empty)) = length(node(y,empty))
proof
  arbitrary U:type, x:U, y:U
  rewrite length_one[U,x] | length_one[U,y]
end
\end{verbatim}

\section{Reasoning about Natural Numbers}

The \texttt{Nat.pf} file includes the definition of natural numbers,
operations on them (e.g. addition), and proofs about those
operations. Here we discuss how to reason about addition. Reasoning
about the other operations follows a similar pattern.

Here is the definition of addition from \texttt{Nat.pf}:
\begin{verbatim}
function operator +(Nat,Nat) -> Nat {
  operator +(0, m) = m
  operator +(suc(n), m) = suc(n + m)
}
\end{verbatim}

Recall that we can use Deduce's \texttt{definition} statement whenever
we want to rewrite the goal according to the equations for
addition. Here are the two defining equations, but written with infix
notation:

\begin{verbatim}
0 + m = m
suc(n) + m = suc(n + m)
\end{verbatim}

The \texttt{Nat.pf} file also includes proofs of many equations.
Figure~\ref{fig:nat} lists a selection of the theorems.

\begin{figure}[btp]
{\footnotesize
\begin{verbatim}
add_zero: all n:Nat.  n + 0 = n
add_commute: all n:Nat. all m:Nat.  n + m = m + n
add_assoc: all m:Nat. all n:Nat, o:Nat.  (m + n) + o = m + (n + o)
left_cancel: all x:Nat. all y:Nat, z:Nat.  if x + y = x + z then y = z
add_to_zero: all n:Nat. all m:Nat. if n + m = 0 then n = 0 and m = 0
dist_mult_add: all a:Nat. all x:Nat, y:Nat. a * (x + y) = a * x + a * y
mult_zero: all n:Nat. n * 0 = 0
mult_one: all n:Nat. n * 1 = n
mult_commute: all m:Nat. all n:Nat. m * n = n * m
mult_assoc: all m:Nat. all n:Nat, o:Nat. (m * n) * o = m * (n * o)
\end{verbatim}
}
\caption{A selection of theorems from \texttt{Nat.pf}.}
\label{fig:nat}
\end{figure}

You can use these theorems by instantiating them with particular
entities. For example, \texttt{add\_zero[2]} is a proof of \texttt{2 +
  0 = 2}.  We have not yet discussed how to use the
\texttt{if}-\texttt{then} formula in \texttt{left\_cancel}, but we
will get to that in section~\ref{sec:implication}.

\subsection*{Exercise}

Prove the following theorem using \texttt{left\_cancel} and using
\texttt{add\_commute} with \texttt{rewrite}.

\begin{verbatim}
right_cancel: all x:Nat, y:Nat, z:Nat.
    if x + z = y + z then x = y
\end{verbatim}

\pagebreak

\section{Proving Intermediate Facts with \texttt{have}}

One often needs to prove some intermediate facts on the way to proving
the final goal of a theorem. The \texttt{have} statement of Deduce provides a
way to state and prove a fact and give it a label so that it can be
used later in the proof. For example, consider the proof of

\begin{verbatim}
x + y + z = z + y + x
\end{verbatim}

It takes several uses of \texttt{add\_commute} and \texttt{add\_assoc}
to prove this.  To get started, we use \texttt{have} to prove
\texttt{step1}, which states that \texttt{x + y + z = x + z + y}
(flipping the \texttt{y} and \texttt{z}).

\begin{verbatim}
theorem xyz_zyx: all x:Nat, y:Nat, z:Nat.
  x + y + z = z + y + x
proof
  arbitrary x:Nat, y:Nat, z:Nat
  have step1: x + y + z = x + z + y
    by rewrite add_commute[y][z]
  ?
end
\end{verbatim}

Deduce prints the current goal and the \textbf{givens}, that is, the
facts that we aleady know are true, which now includes \texttt{step1}.

\begin{verbatim}
incomplete proof
Goal:
    x + (y + z) = z + (y + x)
Givens:
    step1: x + (y + z) = x + (z + y)
\end{verbatim}

We proceed four more times, using \texttt{have} to create each
intermediate step in the reasoning.

{\small
\begin{verbatim}
  have step2: x + z + y = (x + z) + y by rewrite add_assoc[x][z,y]
  have step3: (x + z) + y = (z + x) + y by rewrite add_commute[z][x]
  have step4: (z + x) + y = z + (x + y) by rewrite add_assoc[z][x,y]
  have step5: z + (x + y) = z + y + x by rewrite add_commute[x][y]
\end{verbatim}
}

We finish the proof by connecting them all together using Deduce's
\texttt{transitive} statement. The \texttt{transitive} statement takes
two proofs of equations, such as \texttt{a = b} and \texttt{b = c},
and proves \texttt{a = c}.

\begin{verbatim}
  transitive step1 (transitive step2 (transitive step3
    (transitive step4 step5)))
\end{verbatim}

\noindent Figure~\ref{fig:xyz-theorem} shows the complete proof of the
\texttt{xyz\_zyx} theorem.

\begin{figure}[tbp]
\begin{verbatim}
theorem xyz_zyx: all x:Nat, y:Nat, z:Nat.
  x + y + z = z + y + x
proof
  arbitrary x:Nat, y:Nat, z:Nat
  have step1: x + y + z = x + z + y
    by rewrite add_commute[y][z]
  have step2: x + z + y = (x + z) + y
    by rewrite add_assoc[x][z,y]
  have step3: (x + z) + y = (z + x) + y
    by rewrite add_commute[z][x]
  have step4: (z + x) + y = z + (x + y)
    by rewrite add_assoc[z][x,y]
  have step5: z + (x + y) = z + y + x
    by rewrite add_commute[x][y]
  transitive step1 (transitive step2 (transitive step3
    (transitive step4 step5)))
end
\end{verbatim}
\caption{Proof of the \texttt{xyz\_zyx} theorem.}
\label{fig:xyz-theorem}
\end{figure}

\clearpage

\section{Chaining Equations with \texttt{equations}}

Combining a sequence of equations using \texttt{transitive} is quite
common but also cumbersome, so Deduce provides the \texttt{equations}
statement to streamline this process.  After the first equation, the
left-hand side of each equation is written as \texttt{...} because it
is just a repetition of the right-hand side of the previous
equation. Here's another proof of the theorem about \texttt{x + y +
  z}, this time using an \texttt{equations} statement.

\begin{verbatim}
theorem xyz_zyx_eqn: all x:Nat, y:Nat, z:Nat.
  x + y + z = z + y + x
proof
  arbitrary x:Nat, y:Nat, z:Nat
  equations
    x + y + z = x + z + y      by rewrite add_commute[y][z]
          ... = (x + z) + y    by rewrite add_assoc[x][z,y]
          ... = (z + x) + y    by rewrite add_commute[z][x]
          ... = z + x + y      by rewrite add_assoc[z][x,y]
          ... = z + y + x      by rewrite add_commute[x][y]
end
\end{verbatim}

\subsection*{Exercise}

Prove that \texttt{x + y + z = z + y + x} but using fewer than 5 steps.

\pagebreak

\section{Proving \texttt{all} Formulas with Induction}
\label{sec:induction}

Sometimes the \texttt{arbitrary} statement does not give us enough
information to prove an \texttt{all} formula. In those situations, so
long as the type of the \texttt{all} variable is a \texttt{union}
type, we can use the more powerful \texttt{induction} statement.

For example, consider this theorem about appending a list to an empty
list. Suppose we try to use \texttt{arbitrary} for both the
\texttt{all U} and the \texttt{all xs}.

\begin{verbatim}
theorem append_empty: all U :type. all xs :List<U>.
  xs ++ empty = xs
proof
  arbitrary U:type
  arbitrary xs:List<U>
  ?
end
\end{verbatim}

\noindent Deduce replies that we need to prove

\begin{verbatim}
    incomplete proof:
        xs ++ empty = xs
\end{verbatim}

\noindent But now we're stuck because the definition of append pattern
matches on its first argument, but we don't know whether \texttt{xs}
is an \texttt{empty} list or a \texttt{node}.

So instead of using \texttt{arbitrary xs:List<U>} to prove the
\texttt{all xs}, we proceed by induction as follows.

\begin{verbatim}
    theorem append_empty: all U :type. all xs :List<U>.
      xs ++ empty = xs
    proof
      arbitrary U:type
      induction List<U>
      case empty {
        ?
      }
      case node(n, xs') suppose IH: xs' ++ empty = xs' {
        ?
      }
    end
\end{verbatim}

When doing a proof by induction, there is one \texttt{case} for every
alternative in the \texttt{union} type. Here the union type is
\texttt{List<U>}, so we have one case for \texttt{empty} and one case
for \texttt{node}.  Furthermore, because \texttt{node} includes a
recursive argument, that is, and argument of type \texttt{List<U>}, in
the case for \texttt{node} we get to assume that the formula we are
trying to prove is already true for the argument. This is commonly
known at the \textbf{induction hypothesis}.  We must give a label for
the induction hypothesis so here we choose \texttt{IH} for short.

Let us first focus on the case for \texttt{empty}. Deduce tells us that we
need to prove the following.

\begin{verbatim}
incomplete proof:
    empty ++ empty = empty
\end{verbatim}
This follows directly from the definition of append.
\begin{verbatim}
    case empty {
      definition operator++
    }
\end{verbatim}
However, to make the proof more readable by other humans, I recommend
restating the goal using the \texttt{conclude} statement.
\begin{verbatim}
    case empty {
      conclude @empty<U> ++ empty = empty
          by definition operator++
    }
\end{verbatim}

Next let us focus on the case for \texttt{node}. Deduce tells us that
we need to prove the following and that \texttt{IH} has been added to
the available facts.
\begin{verbatim}
incomplete proof:
    node(n,xs') ++ empty = node(n,xs')

available facts:
    IH: xs' ++ empty = xs',
    ...
\end{verbatim}
Looking at the goal, we notice that we can expand the definition of
\texttt{append} on the right-hand side, because it is applied to a
\texttt{node}.  Deduce provides the \texttt{term} statement as way to
use Deduce to expand definitions for us.
\begin{verbatim}
    case node(n, xs') suppose IH: xs' ++ empty = xs' {
      term node(n,xs') ++ empty by definition operator++
      ?
    }
\end{verbatim}
Deduce responds with
\begin{verbatim}
    remains to prove:
        node(n,xs' ++ empty)
\end{verbatim}

We use Deduce's \texttt{have} statement to label this equality.  We
choose the label \texttt{step1}, state the equality, and then provide
its proof after the \texttt{by} keyword.
\begin{verbatim}
    case node(n, xs') suppose IH: xs' ++ empty = xs' {
      have step1: node(n,xs') ++ empty
                = node(n, xs' ++ empty)  by definition operator++
      ?
    }
\end{verbatim}
Next, we see that the subterm \texttt{xs' ++ empty} matches the
right-hand side of the induction hypothesis \texttt{IH}. We use the
\texttt{rewrite} statement to apply the \texttt{IH} equation to this subterm.
\begin{verbatim}
    have step2: node(n, xs' ++ empty)
                = node(n,xs')                 by rewrite IH
\end{verbatim}
To complete the proof, we combine equations (1) and (2) using
the \texttt{transitive} statement.
\begin{verbatim}
    conclude node(n,xs') ++ empty = node(n,xs')
        by transitive step1 step2
\end{verbatim}

The completed proof of \texttt{append\_empty} is shown in
Figure~\ref{fig:append-empty}, but we replace the intermediate
\texttt{have} statements and \texttt{transitive} by an
\texttt{equations} statement.

\begin{figure}[tbp]
\begin{verbatim}
theorem append_empty: all U :type. all xs :List<U>.
  xs ++ empty = xs
proof
  arbitrary U:type
  induction List<U>
  case empty {
    conclude @empty<U> ++ empty = empty
        by definition operator++
  }
  case node(n, xs') suppose IH: xs' ++ empty = xs' {
    equations
      node(n,xs') ++ empty
          = node(n, xs' ++ empty)   by definition operator++
      ... = node(n,xs')             by rewrite IH
  }
end
\end{verbatim}
\caption{Proof of the \texttt{append\_empty} theorem.}
\label{fig:append-empty}
\end{figure}

To summarize this section:
\begin{itemize}
  \item To prove an \texttt{all} formula that concerns entities of a
    \texttt{union} type, use Deduce's \texttt{induction} statement.
\end{itemize}

\subsection*{Exercise}

Prove that \texttt{length(xs ++ ys) = length(xs) + length(ys)}.

\clearpage

\section{Reasoning about \texttt{and} (Conjunction)}
\label{sec:conjunction}

To create a single formula that expresses that two formulas are true,
combine the two formulas with \texttt{and} (i.e. conjunction). The
following example proves that \texttt{0 ≤ 1 and 0 ≤ 2}.  This is
accomplished by separately proving that \texttt{0 ≤ 1} is true and
that \texttt{0 ≤ 2} is true, then using the comma operator to combine
those proofs: \texttt{one\_pos, two\_pos}.

\begin{verbatim}
theorem positive_1_and_2: 0 ≤ 1 and 0 ≤ 2
proof
  have one_pos: 0 ≤ 1 by definition operator ≤
  have two_pos: 0 ≤ 2 by definition operator ≤
  conclude 0 ≤ 1 and 0 ≤ 2 by one_pos, two_pos
end
\end{verbatim}

On the other hand, in Deduce you can use a conjunction as if it were
one of its subformulas, implicitly. In the following we use the
fact that \texttt{0 ≤ 1 and 0 ≤ 2} to prove \texttt{0 ≤ 2}.

\begin{verbatim}
theorem positive_2: 0 ≤ 2
proof
  conclude 0 ≤ 2 by positive_1_and_2
end
\end{verbatim}

To summarize this section:
\begin{itemize}
\item Use \texttt{and} in Deduce to express the truth of two formulas.
\item To prove an \texttt{and} formula, prove its parts and then
  combine them using comma.
\item You can implicitly use an \texttt{and} formula as one of its
  parts.
\end{itemize}

\pagebreak

\section{Reasoning about \texttt{or} (Disjunction)}
\label{sec:disjunction}

Two create a formula that expresses that at least one of two formulas
is true (i.e. disjunction), use \texttt{or} to combine the formulas.

For example, consider the following variation on the trichotomy law,
which states that for any two natural numbers \texttt{x} and
\texttt{y}, either \texttt{x ≤ y} or \texttt{y < x}.

\begin{verbatim}
    theorem dichotomy:  all x:Nat, y:Nat.  x ≤ y  or  y < x
    proof
      ?
    end
\end{verbatim}
We can prove this using the \texttt{trichotomy} theorem from
\texttt{Nat.pf}, which tells us that \texttt{x < y} or \texttt{x = y}
or \texttt{y < x}.
\begin{verbatim}
    theorem dichotomy:  all x:Nat, y:Nat.  x ≤ y  or  y < x
    proof
      arbitrary x:Nat, y:Nat
      have tri: x < y or x = y or y < x by trichotomy[x][y]
      ?
    end
\end{verbatim}
In Deduce, you can use an \texttt{or} fact by doing case analysis with
the \texttt{cases} statement. There is one \texttt{case} for each
subformula of the \texttt{or}.
\begin{verbatim}
    have tri: x < y or x = y or y < x by trichotomy[x][y]
    cases tri
    case x_l_y: x < y {
      ?
    }
    case x_eq_y: x = y {
      ?
    }
    case y_l_x: y < x {
      ?
    }
\end{verbatim}
In the first case, we consider the situation where \texttt{x < y} and
still need to prove that \texttt{x ≤ y or y < x}. Thankfully, the
theorem \texttt{less\_implies\_less\_equal} in \texttt{Nat.pf} tells us
that \texttt{x ≤ y}.
\begin{verbatim}
    case x_l_y: x < y {
      have x_le_y: x ≤ y
          by apply less_implies_less_equal[x][y] to x_l_y
      ?
    }
\end{verbatim}

In Deduce, an \texttt{or} formula can be proved using a proof of either
subformula, so here we prove \texttt{x ≤ y or y < x} with \texttt{x ≤ y}.
\begin{verbatim}
    case x_l_y: x < y {
      have x_le_y: x ≤ y
          by apply less_implies_less_equal[x][y] to x_l_y
      conclude x ≤ y or y < x by x_le_y
    }
\end{verbatim}
In the second case, we consider the situation where \texttt{x =
  y}. Here we can prove that \texttt{x ≤ y} by rewriting the
\texttt{x} to \texttt{y} and then using the reflexive property of the
less-equal relation to prove that \texttt{y ≤ y}.
\begin{verbatim}
    case x_eq_y: x = y {
      have x_le_y: x ≤ y by
          suffices y ≤ y  with rewrite x_eq_y
          less_equal_refl[y]
      conclude x ≤ y or y < x by x_le_y
    }
\end{verbatim}
In the third case, we consider the situation where \texttt{y < x}.
So we can immediately conclude that \texttt{x ≤ y or y < x}.
\begin{verbatim}
    case y_l_x: y < x {
      conclude x ≤ y or y < x by y_l_x
    }
\end{verbatim}

\noindent Figure~\ref{fig:dichotomy} shows the completed proof of the
\texttt{dichotomy} theorem.

\begin{figure}[tbp]
\begin{verbatim}
theorem dichotomy:  all x:Nat, y:Nat.  x ≤ y  or  y < x
proof
  arbitrary x:Nat, y:Nat
  have tri: x < y or x = y or y < x by trichotomy[x][y]
  cases tri
  case x_l_y: x < y {
    have x_le_y: x ≤ y
        by apply less_implies_less_equal[x][y] to x_l_y
    conclude x ≤ y or y < x by x_le_y
  }
  case x_eq_y: x = y {
    have x_le_y: x ≤ y by
        suffices y ≤ y   with rewrite x_eq_y
        less_equal_refl[y]
    conclude x ≤ y or y < x by x_le_y
  }
  case y_l_x: y < x {
    conclude x ≤ y or y < x by y_l_x
  }
end
\end{verbatim}
\caption{Proof of the \texttt{dichotomy} theorem.}
\label{fig:dichotomy}
\end{figure}

To summarize this section:
\begin{itemize}
\item Use \texttt{or} in Deduce to express that at least one of two or
  more formulas is true.
\item To prove an \texttt{or} formula, prove either one of the
  formulas.
\item To use a fact that is an \texttt{or} formula, use the
  \texttt{cases} statement.
\end{itemize}

\section{The \texttt{switch} Proof Statement}
\label{sec:switch-proof}

Similar to Deduce's \texttt{switch} statement for writing functions,
there is also a \texttt{switch} statement for writing proofs. As an
example, let us consider how to prove the following theorem.
\begin{verbatim}
theorem zero_or_positive: all x:Nat. x = 0 or 0 < x
proof
  ?
end
\end{verbatim}
We could proceed by induction, but it turns out we don't need the
induction hypothesis. In such situations, we can instead use \texttt{switch}.
Like induction, \texttt{switch} works on unions and there is one case for
each alternative of the union. Unlike induction, the goal formula does
not need to be an \texttt{all} formula. Instead, you indicate which entity to
switch on, as in \texttt{switch x} below.
\begin{verbatim}
arbitrary x:Nat
switch x {
  case zero {
    ?
  }
  case suc(x') {
    ?
  }
}
\end{verbatim}
Deduce responds that in the first case we need to prove the following.
\begin{verbatim}
incomplete proof:
    true or 0 < 0
\end{verbatim}
So we just need to prove \texttt{true}, which is what the period is for.
\begin{verbatim}
    case zero {
      conclude true or 0 < 0 by .
    }
\end{verbatim}
In the second case, for \texttt{x = suc(x')}, we need to prove the following.
\begin{verbatim}
incomplete proof:
    false or 0 < suc(x')
\end{verbatim}
There's no hope of proving \texttt{false}, so we better prove
\texttt{0 < suc(x')}.  Thankfully that follows from the definitions of
\texttt{<} and \texttt{≤}.
\begin{verbatim}
    case suc(x') {
      have z_l_sx: 0 < suc(x')
          by definition {operator <, operator ≤}
      conclude suc(x') = 0 or 0 < suc(x') by z_l_sx
    }
\end{verbatim}
Here is the completed proof that every natural number is either zero
or positive.

\begin{verbatim}
theorem zero_or_positive: all x:Nat. x = 0 or 0 < x
proof
  arbitrary x:Nat
  switch x {
    case zero {
      conclude true or 0 < 0 by .
    }
    case suc(x') {
      have z_l_sx: 0 < suc(x') 
          by definition {operator <, operator ≤, operator ≤}
      conclude suc(x') = 0 or 0 < suc(x') by z_l_sx
    }
  }
end
\end{verbatim}

To summarize this section:
\begin{itemize}
\item Use \texttt{switch} on an entity of union type to split the
  proof into cases, with one case for each alternative of the union.
\end{itemize}

\pagebreak

\section{Applying Definitions and Rewrites to the Goal}

Sometimes one needs to apply a set of definitions and rewrites
to the goal. Consider the following definition of \texttt{max'}.
(There is a different definition of \texttt{max} in \texttt{Nat.pf}.)

\begin{verbatim}
define max' : fn Nat, Nat -> Nat
            = λx,y{ if x ≤ y then y else x }
\end{verbatim}

To prove that \texttt{x ≤ max'(x,y)} we consider two cases, whether
\texttt{x ≤ y} or not. If \texttt{x ≤ y} is true, we apply the
definition of \texttt{max'} \textbf{and} we rewrite with the fact that
\texttt{x ≤ y} is true, which resolves the
\texttt{if}-\texttt{then}-\texttt{else} inside of \texttt{max'} to
just \texttt{y}.

\begin{verbatim}
    suffices x ≤ y with definition max' and rewrite x_le_y_true
\end{verbatim}

\noindent So we are left to prove \texttt{x ≤ y}, which we already
know.  Similarly, if \texttt{x ≤ y} is false, we apply the definition
of \texttt{max'} and rewrite with the fact that \texttt{x ≤ y} is
false.

\begin{verbatim}
    suffices x ≤ x with definition max' and rewrite x_le_y_false
\end{verbatim}

\noindent This resolves the \texttt{if}-\texttt{then}-\texttt{else}
inside of \texttt{max'} to just \texttt{x}. So we are left to prove
\texttt{x ≤ x}, which of course is true.  Here is the complete proof
that \texttt{x ≤ max'(x,y)}.

\begin{verbatim}
theorem less_max: all x:Nat, y:Nat.  x ≤ max'(x,y)
proof
  arbitrary x:Nat, y:Nat
  switch x ≤ y {
    case true suppose x_le_y_true {
      suffices x ≤ y with definition max' and rewrite x_le_y_true
      rewrite x_le_y_true
    }
    case false suppose x_le_y_false {
      suffices x ≤ x with definition max' and rewrite x_le_y_false
      less_equal_refl[x]
    }
  }
end
\end{verbatim}


\section{Conditional Formulas (Implication) and Applying Definitions to Facts}
\label{sec:implication}

Some logical statements are true only under certain conditions, so
Deduce provides an \texttt{if}-\texttt{then} formula.  To demonstrate
how to work with \texttt{if}-\texttt{then} formulas, we prove that if
a list has length zero, then it must be the \texttt{empty} list. Along
the way we will also learn how to apply a definition to an
already-known fact.

\begin{verbatim}
theorem length_zero_empty: all T:type, xs:List<T>.
  if length(xs) = 0 then xs = empty
proof
  arbitrary T:type, xs:List<T>
  ?
end
\end{verbatim}

\noindent Deduce tells us:

\begin{verbatim}
incomplete proof
Goal:
    (if length(xs) = 0 then xs = empty)
\end{verbatim}

To prove an \texttt{if}-\texttt{then} formula, we \texttt{suppose} the
condition and then prove the conclusion.

\begin{verbatim}
  suppose len_z: length(xs) = 0
\end{verbatim}

Deduce adds \texttt{len\_z} to the givens (similar to \texttt{have}).

\begin{verbatim}
incomplete proof
Goal:
    xs = empty
Givens:
    len_z: length(xs) = 0
\end{verbatim}

Next we \texttt{switch} on the list \texttt{xs}. In the case when
\texttt{xs} is \texttt{empty} it is trivial to prove \texttt{xs = empty}.
In the other case, we will obtain a contradiction.

\begin{verbatim}
  switch xs {
    case empty { . }
    case node(x, xs') suppose xs_xxs: xs = node(x,xs') {
      ?
    }
  }
\end{verbatim}

We can put the facts \texttt{len\_z} and \texttt{xs\_xxs} together
to obtain the dubious looking \texttt{length(node(x,xs')) = 0}.

\begin{verbatim}
    have len_z2: length(node(x,xs')) = 0
        by rewrite xs_xxs in len_z
\end{verbatim}

The contradiction becomes apparent to Deduce once we apply the
definition of \texttt{length} to this fact. We do so using Deduce's
\texttt{definition}-\texttt{in} statement as follows. 

\begin{verbatim}
    conclude false  by definition length in len_z2
\end{verbatim}

\noindent We discuss contradictions and \texttt{false} in more detail
in section~\ref{sec:false}.
%
Here is the complete proof of \texttt{length\_zero\_empty}.

\begin{verbatim}
theorem length_zero_empty: all T:type, xs:List<T>.
  if length(xs) = 0 then xs = empty
proof
  arbitrary T:type, xs:List<T>
  suppose len_z: length(xs) = 0
  switch xs {
    case empty { . }
    case node(x, xs') suppose xs_xxs: xs = node(x,xs') {
      have len_z2: length(node(x,xs')) = 0
          by rewrite xs_xxs in len_z
      conclude false  by apply not_one_add_zero[length(xs')]
                         to definition length in len_z2
    }
  }
end
\end{verbatim}

The next topic to discuss is how to use an \texttt{if}-\texttt{then}
fact that is already proven.  We use Deduce's
\texttt{apply}-\texttt{to} statement (aka. modus ponens) to obtain the
conclusion of an \texttt{if}-\texttt{then} formula by supplying a
proof of its condition.  We demonstrate several uses of
\texttt{apply}-\texttt{to} in the proof of the following theorem,
which builds on \texttt{length\_zero\_empty}.

\begin{verbatim}
theorem length_append_zero_empty: 
  all T:type, xs:List<T>, ys:List<T>.
  if length(xs ++ ys) = 0
  then xs = empty and ys = empty
proof
  arbitrary T:type, xs:List<T>, ys:List<T>
  suppose len_xs_ys: length(xs ++ ys) = 0
  ?
end
\end{verbatim}

Recall that in a previous exercise, you proved that

\begin{verbatim}
length(xs ++ ys) = length(xs) + length(ys)
\end{verbatim}

\noindent so we can prove that \texttt{length(xs) + length(ys) = 0} as
follows.

\begin{verbatim}
  have len_xs_len_ys: length(xs) + length(ys) = 0
    by transitive (symmetric length_append[T][xs][ys]) len_xs_ys
\end{verbatim}

\noindent Note that Deduce's the \texttt{symmetric} statement takes a
proof of some equality like \texttt{a = b} and flips it around to
\texttt{b = a}.

Now from \texttt{Nat.pf} we have the following \texttt{if}-\texttt{then} fact.

\begin{verbatim}
add_to_zero: all n:Nat. all m:Nat. 
    if n + m = 0 then n = 0 and m = 0
\end{verbatim}

\noindent Here we use of \texttt{apply}-\texttt{to} to obtain
\texttt{length(xs) = 0} and the same for \texttt{ys}.

\begin{verbatim}
  have len_xs: length(xs) = 0
      by apply add_to_zero to len_xs_len_ys
  have len_ys: length(ys) = 0
      by apply add_to_zero to len_xs_len_ys
\end{verbatim}

We conclude that \texttt{xs = empty and ys = empty} by more uses of
\texttt{apply}-\texttt{to} with the theorem
\texttt{length\_zero\_empty}.

\begin{verbatim}
  conclude xs = empty and ys = empty
  by (apply length_zero_empty[T,xs] to len_xs),
     (apply length_zero_empty[T,ys] to len_ys)
\end{verbatim}

Here is the complete proof of \texttt{length\_append\_zero\_empty}.

\begin{verbatim}
theorem length_append_zero_empty: 
  all T:type, xs:List<T>, ys:List<T>.
  if length(xs ++ ys) = 0
  then xs = empty and ys = empty
proof
  arbitrary T:type, xs:List<T>, ys:List<T>
  suppose len_xs_ys: length(xs ++ ys) = 0
  have len_xs_len_ys: length(xs) + length(ys) = 0
    by transitive (symmetric length_append[T][xs][ys]) len_xs_ys
  have len_xs: length(xs) = 0
      by apply add_to_zero to len_xs_len_ys
  have len_ys: length(ys) = 0
      by apply add_to_zero to len_xs_len_ys
  conclude xs = empty and ys = empty
  by (apply length_zero_empty[T,xs] to len_xs),
     (apply length_zero_empty[T,ys] to len_ys)
end
\end{verbatim}

To summarize this section:
\begin{itemize}
\item A conditional formula is stated in Deduce using the
  \texttt{if}-\texttt{then} syntax.
\item To prove an \texttt{if}-\texttt{then}, \texttt{suppose} the
  condition and prove the conclusion.
\item To use a fact that is an \texttt{if}-\texttt{then},
  \texttt{apply} it \texttt{to} a proof of the condition.
\item To apply a definition to a fact, use
  \texttt{definition}-\texttt{in}.
\end{itemize}

\subsection*{Exercise}

Prove that \texttt{all x:Nat. if x ≤ 0 then x = 0}.

\pagebreak

\section{Reasoning about \texttt{true}}
\label{sec:true}

There's not much to say about \texttt{true}. It's true!  And as we've
already seen, proving \texttt{true} is easy. Just use a period.

\begin{verbatim}
theorem really_trivial: true
proof
  .
end
\end{verbatim}

\noindent One almost never sees \texttt{true} written explicitly in a
formula. However, it is common for a formula to simplify to
\texttt{true} after some rewriting.

\pagebreak

\section{Reasoning about \texttt{false}}
\label{sec:false}

The formula \texttt{false} is also rarely written explicitly in a
formula.  However, it can arise in contradictory situations. For
example, in the following we have a situation in which \texttt{true = false}.
That can't be, so Deduce simplifies \texttt{true = false}
to just \texttt{false}.

\begin{verbatim}
theorem contra_false: all a:bool, b:bool.
  if a = b and a = true and b = false then false
proof
  arbitrary a:bool, b:bool
  suppose prem: a = b and a = true and b = false
  have a_true: a = true by prem
  have b_true: b = false by prem
  conclude false by rewrite a_true | b_true in prem
end
\end{verbatim}

More generally, Deduce knows that the different constructors of a
union are in fact different. So in the next example, because
\texttt{foo} and \texttt{bar} are different constructors, Deduce
simplifies \texttt{foo = bar} to \texttt{false}.

\begin{verbatim}
    union U {
      foo
      bar
    }
    
    theorem foo_bar_false: if foo = bar then false
    proof
      .
    end
\end{verbatim}

The above proof is just a period because Deduce simplifies any formula
of the form \texttt{if false then ...} to \texttt{true}, which is
related to our next point.

So far we've discussed how a proof of \texttt{false} can arise.  Next
let's talk about how you can use \texttt{false} once you've got it.
The answer is anything! The Principle of Explosion tells us that
\texttt{false} implies anything\footnote{I promise I didn't make this
  up. It's a legitimate rule of logic!}. For example, normally we
don't know whether or not two arbitrary Booleans \texttt{x} and
\texttt{y} are the same or different.  But if we have a premise that
is \texttt{false}, it doesn't matter.

\begin{verbatim}
theorem false_any: all x:bool, y:bool. if false then x = y
proof
  arbitrary x:bool, y:bool
  suppose f: false
  conclude x = y by f
end
\end{verbatim}

To summarize this section:
\begin{itemize}
\item Deduce simplifies any obviously contradictory equation to \texttt{false}.
\item \texttt{false} implies anything.
\end{itemize}

\pagebreak

\section{Reasoning about \texttt{not}}
\label{sec:not}

To express that a formula is false, precede it with \texttt{not}.  For
example, for any natural number \texttt{x}, it is not the case that
\texttt{x < x}.
\begin{verbatim}
    theorem less_irreflexive:  all x:Nat. not (x < x)
    proof
      ?
    end
\end{verbatim}
We proceed by induction.
\begin{verbatim}
    induction Nat
    case zero {
      ?
    }
    case suc(x') suppose IH: not (x' < x') {
      ?
    }
\end{verbatim}
Deduce treats \texttt{not} as syntactic sugar for a conditional formal with a
\texttt{false} conclusion. So in the first case, we must prove 
that \texttt{0 < 0} implies \texttt{false}.
We \texttt{suppose} the premise \texttt{0 < 0} and then conclude
\texttt{false} by the definitions of \texttt{<} and \texttt{≤}.
\begin{verbatim}
    case zero {
      suppose z_l_z: 0 < 0
      conclude false 
          by definition {operator <, operator ≤} in z_l_z
    }
\end{verbatim}
In the case where \texttt{x = suc(x')}, we must prove that
\texttt{suc(x') < suc(x')} implies \texttt{false}.  So we assume the
premise \texttt{suc(x') < suc(x')} from which we prove that
\texttt{x' < x'} using the definitions of \texttt{<} and \texttt{≤}.
\begin{verbatim}
    suppose sx_l_sx: suc(x') < suc(x')
    enable {operator <, operator ≤}
    have x_l_x: x' < x' by sx_l_sx
\end{verbatim}
We conclude this case by applying the induction hypothesis to \texttt{x' < x'}.
\begin{verbatim}
    conclude false by apply IH to x_l_x
\end{verbatim}
Here is the completed proof that less-than is irreflexive.

\begin{verbatim}
theorem less_irreflexive:  all x:Nat. not (x < x)
proof
  induction Nat
  case zero {
    suppose z_l_z: 0 < 0
    conclude false by definition {operator <, operator ≤} in z_l_z
  }
  case suc(x') suppose IH: not (x' < x') {
    suppose sx_l_sx: suc(x') < suc(x')
    enable {operator <, operator ≤}
    have x_l_x: x' < x' by sx_l_sx
    conclude false by apply IH to x_l_x
  }
end
\end{verbatim}

To summarize this section:
\begin{itemize}
\item To expression that a formula is false, use \texttt{not}.
\item Deduce treats the formula \texttt{not P} just like \texttt{if P
  then false}.
\item Therefore, to prove a \texttt{not} formula, suppose \texttt{P}
  then prove \texttt{false}.
\item To use a formula like \texttt{not P}, apply it to a proof of
  \texttt{P} to obtain a proof of \texttt{false}.
\end{itemize}

\section{Rewriting Facts with Equations}
\label{sec:rewriting-facts}  

In section~\ref{sec:rewriting-goal} we learned that the
\texttt{rewrite} statement of Deduce applies an equation to the
current goal.  There is a second variant of \texttt{rewrite} that
applies an equation to a fact. As an example, we'll prove the
following theorem that is a straightforward use of
\texttt{less\_irreflexive}.

\begin{verbatim}
theorem less_not_equal: all x:Nat, y:Nat.
  if x < y then not (x = y)
proof
  arbitrary x:Nat, y:Nat
  suppose x_l_y: x < y
  ?
end
\end{verbatim}

Deduce responds with the current goal, in which \texttt{not (x = y)} is
expanding into \texttt{if x = y then false}.

\begin{verbatim}
incomplete proof
Goal:
        (if x = y then false)
Givens:
        x_l_y: x < y
\end{verbatim}

So following the usual recipe to prove an \texttt{if}-\texttt{then},
we \texttt{suppose} the condition \texttt{x = y}.

\begin{verbatim}
  suppose x_y: x = y
\end{verbatim}

Now we need to prove false, and we have the hint to use the
\texttt{less\_irreflexive} theorem.

\begin{verbatim}
incomplete proof
Goal:
        false
Givens:
        x_y: x = y,
        x_l_y: x < y
\end{verbatim}

Here is where the second variant of \texttt{rewrite} comes in.  We can
use it to apply the equation \texttt{x = y} to the fact \texttt{x < y}
to get \texttt{y < y}.  Note the extra keyword \texttt{in} that is
used in this version of \texttt{rewrite}.

\begin{verbatim}
  have y_l_y: y < y   by rewrite x_y in x_l_y
\end{verbatim}

We arrive at the contradition by applying \texttt{less\_irreflexive}
to \texttt{y < y}.

\begin{verbatim}
  conclude false by apply less_irreflexive[y] to y_l_y
\end{verbatim}

Here is the complete proof of \texttt{less\_not\_equal}.

\begin{verbatim}
theorem less_not_equal: all x:Nat, y:Nat.
  if x < y then not (x = y)
proof
  arbitrary x:Nat, y:Nat
  suppose x_l_y: x < y
  suppose x_y: x = y
  have y_l_y: y < y by rewrite x_y in x_l_y
  conclude false by apply less_irreflexive[y] to y_l_y
end
\end{verbatim}

\subsection{Exercise}

Prove the following theorem without using \texttt{less\_not\_equal}.

\begin{verbatim}
greater_not_equal: all x:Nat, y:Nat. if x > y then not (x = y)
\end{verbatim}

Note that greater-than is defined as follows in \texttt{Nat.pf}:

\begin{verbatim}
define operator > : fn Nat,Nat -> bool = λ x, y { y < x }
\end{verbatim}

\pagebreak

\section{Reasoning about \texttt{some} (Exists)}
\label{sec:exists}

In Deduce, you can express that there is at least one entity that
satisfies a given property using the \texttt{some} formula.  For example, one
way to define an even number is to say that it is a number that is 2
times some other number. We express this in Deduce as follows.
\begin{verbatim}
    define Even : fn Nat -> bool = λ n { some m:Nat. n = 2*m }
\end{verbatim}
As an example of how to reason about \texttt{some} formulas, let us prove a
classic property of the even numbers, that the addition of two even
numbers is an even number. Here's the beginning of the proof.
\begin{verbatim}
    theorem addition_of_evens:
      all x:Nat, y:Nat.
      if Even(x) and Even(y) then Even(x + y)
    proof
      arbitrary x:Nat, y:Nat
      suppose even_xy: Even(x) and Even(y)
      have even_x: some m:Nat. x = 2*m
          by definition Even in even_xy
      have even_y: some m:Nat. y = 2*m
          by definition Even in even_xy
      ?
    end
\end{verbatim}
The next step in the proof is to make use of the facts
\texttt{even\_x} and \texttt{even\_y}.  We can make use of a
\texttt{some} formula using the \texttt{obtain} statement of Deduce.
\begin{verbatim}
    obtain a where x_2a: x = 2*a from even_x
    obtain b where y_2b: y = 2*b from even_y
\end{verbatim}
Deduce responds with
\begin{verbatim}
available facts:
    y_2b: y = 2*b,
    x_2a: x = 2*a,
\end{verbatim}
The \texttt{a} and \texttt{b} are new variables and the two facts
\texttt{y\_2b} and \texttt{x\_2a} are the subformulas of the
\texttt{some}, but with \texttt{a} and \texttt{b} replacing
\texttt{m}.

We still need to prove the following:
\begin{verbatim}
incomplete proof:
    Even(x + y)
\end{verbatim}
So we use the definition of \texttt{Even} in a \texttt{suffices} statement
\begin{verbatim}
    suffices some m:Nat. x + y = 2*m   with definition Even
    ?
\end{verbatim}
To prove a \texttt{some} formula, we use Deduce's \texttt{choose}
statement.  This requires some thinking on our part.  What number can
we plug in for \texttt{m} such that doubling it is equal to \texttt{x
  + y}? Given what we know about \texttt{a} and \texttt{b}, the answer
is \texttt{a + b}. We conclude the proof by using the equations for
\texttt{x} and \texttt{y} and the distributivity property of
multiplication over addition (from \texttt{Nat.pf}).
\begin{verbatim}
    choose a + b
    suffices 2*a + 2*b = 2*(a + b) with rewrite x_2a | y_2b
    symmetric dist_mult_add[2][a,b]
\end{verbatim}

\noindent Figure~\ref{fig:add-evens} shows the complete proof of
\texttt{addition\_of\_evens}.

\begin{figure}[tbp]
\begin{verbatim}
theorem addition_of_evens:
  all x:Nat, y:Nat.
  if Even(x) and Even(y) then Even(x + y)
proof
  arbitrary x:Nat, y:Nat
  suppose even_xy: Even(x) and Even(y)
  have even_x: some m:Nat. x = 2*m
      by definition Even in even_xy
  have even_y: some m:Nat. y = 2*m
      by definition Even in even_xy
  obtain a where x_2a: x = 2*a from even_x
  obtain b where y_2b: y = 2*b from even_y
  suffices some m:Nat. x + y = 2*m with definition Even
  choose a + b
  suffices 2*a + 2*b = 2*(a + b) with rewrite x_2a | y_2b
  symmetric dist_mult_add[2][a,b]
end
\end{verbatim}
\caption{Proof of the \texttt{addition\_of\_evens} theorem.}
\label{fig:add-evens}
\end{figure}

To summarize this section:
\begin{itemize}
\item The \texttt{some} formula expresses that a property is true for
  at least one entity.
\item Deduce's \texttt{obtain} statement lets you make
  use of a fact that is a \texttt{some} formula.
\item To prove a \texttt{some} formula, use Deduce's \texttt{choose}
  statement.
\end{itemize}


\end{document}

% LocalWords:  Deduce's pf fn NatList suc bool len app NEList Pos
