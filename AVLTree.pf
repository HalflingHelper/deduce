import Nat

union Tree<K> {
  empty;
  node(K, Nat, Tree<K>, Tree<K>);
}

function compute_height<T>(Tree<T>) -> Nat {
  compute_height(empty) = 0;
  compute_height(node(n,h,L,R)) = 1 + max(compute_height(L), compute_height(R));
}

function height<T>(Tree<T>) -> Nat {
  height(empty) = 0;
  height(node(n,h,L,R)) = h;
}

function is_AVL<T>(Tree<T>) -> bool {
  is_AVL(empty) = true;
  is_AVL(node(n, h, L, R)) = diff(compute_height(L), compute_height(R)) ≤ 1
                             and is_AVL(L) and is_AVL(R);
}

define make_node : (Nat, Tree<Nat>, Tree<Nat>) -> Tree<Nat> is
  λ x, A, B { node(x, 1 + max(height(A), height(B)), A, B) }

define balance : (Tree<Nat>) -> Tree<Nat>
  is λ A {
  switch A {
    case empty { empty }
    case node(x, xh, L, R) {
      if height(L) + 1 < height(R) then
        switch R {
	  case empty { empty }
	  case node(y, yh, RL, RR) {
	    if height(RL) ≤ height(RR) then
	      make_node(y, make_node(x, L, RL), RR)
	    else (
	      switch RL {
	        case empty { empty } // can't happen
	        case node(z, zh, RLL, RLR) {
	          make_node(z, make_node(x, L, RLL), make_node(y, RLR, RR))
	        }
	      }
	    ) 
	  }
	}
      else if height(R) + 1 < height(L) then (
        switch L {
	  case empty { empty }
	  case node(y, yh, LL, LR) {
	    if height(LR) ≤ height(LL) then
	      make_node(y, LL, make_node(x, LR, R))
	    else (
	      switch LR {
	        case empty { empty }
		case node(z, zh, LRL, LRR) {
		  make_node(z, make_node(y, LL, LRL), make_node(x, LRR, R))
		}
              }
	    )
	  }
        }
      ) else
        A
    }
  }
}
