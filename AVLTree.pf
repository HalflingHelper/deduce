import Nat

union Tree<K> {
  empty;
  node(K, Nat, Tree<K>, Tree<K>);
}

function compute_height<T>(Tree<T>) -> Nat {
  compute_height(empty) = 0;
  compute_height(node(n,h,L,R)) = 1 + max(compute_height(L), compute_height(R));
}

function height<T>(Tree<T>) -> Nat {
  height(empty) = 0;
  height(node(n,h,L,R)) = h;
}

function is_AVL<T>(Tree<T>) -> bool {
  is_AVL(empty) = true;
  is_AVL(node(n, h, L, R)) = diff(compute_height(L), compute_height(R)) ≤ 1
                             and is_AVL(L) and is_AVL(R);
}

/*

  rotate right

       x          y
      / \        / \
     y   C      A   x
    / \            / \
   A   B          B   C


  node(x, hx, node(y, hy, A, B), C)
  =>
  hx = 1 + max(height(B), height(C))
  hy = 1 + max(height(A), hx)
  node(y, hy, A, node(x, hx, B, C))

*/

define make_node : (Nat, Tree<Nat>, Tree<Nat>) -> Tree<Nat> is
  λ x, A, B { node(x, 1 + max(height(A), height(B)), A, B) }

define rotate_right : (Nat, Nat, Tree<Nat>, Tree<Nat>, Tree<Nat>) -> Tree<Nat>
  is λ x, y, A, B, C {
  make_node(y, A, make_node(x, B, C))
}