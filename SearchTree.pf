/*

  Binary Search Tree
  (not balanced)

*/

import Nat
import Pair
import Option
import Maps

union Tree {
  empty_tree;
  tree_node(Tree, Nat, Nat, Tree);
}

function insert(Tree, Nat, Nat) -> Tree {
  insert(empty_tree, x, v) = tree_node(empty_tree, x, v, empty_tree);
  insert(tree_node(L, y, v2, R), x, v) =
    if x = y then
      tree_node(L, y, v, R)
    else if x < y then
      tree_node(insert(L, x, v), y, v2, R)
    else
      tree_node(L, y, v2, insert(R, x, v));
}

function keys(Tree) -> fn(Nat)->bool {
  containsKey(empty_tree) = λx{false};
  containsKey(tree_node(L, y, v, R)) = λx{x = y} ∪ keys(L) ∪ keys(R);
}

function lookup(Tree) -> fn (Nat) -> Option<Nat> {
  lookup(empty_tree) = λx{none};
  lookup(tree_node(L, y, v, R)) =
    λx{if x = y then
         just(v)
       else if x < y then
         lookup(L)(x)
       else
         lookup(R)(x)};
}

function all_keys(Tree, fn (Nat) -> bool) -> bool {
  all_keys(empty_tree, P) = true;
  all_keys(tree_node(L, x, v, R), P) =
    all_keys(L, P) and P(x) and all_keys(R, P);
}

function is_BST(Tree) -> bool {
  is_BST(empty_tree) = true;
  is_BST(tree_node(L, x, v, R)) =
    all_keys(L, λk{k < x}) and all_keys(R, λk{x < k}) and
    is_BST(L) and is_BST(R);
}

theorem insert_all:
  all T:Tree. all x:Nat, v:Nat, P: fn(Nat) -> bool.
  if all_keys(T, P) and P(x)
  then all_keys(insert(T, x, v), P)
proof
  induction Tree
  case empty_tree {
    arbitrary x:Nat,v:Nat, Q: fn(Nat) -> bool;
    assume prem: all_keys(empty_tree,Q) and Q(x);
    apply all_keys, insert in goal;
    conjunct 1 of prem
  }
  case tree_node(L, z, v2, R) assume IHL, IHR {
    arbitrary x:Nat,v:Nat,P: fn(Nat) -> bool;
    assume prem: all_keys(tree_node(L,z,v2,R),P) and P(x);
    have PL: all_keys(L, P) by apply all_keys in prem;
    have PR: all_keys(R, P) by apply all_keys in prem;    
    apply all_keys, insert in goal;
    switch x = z {
      case true assume xz_true {
        apply all_keys in goal;
        have xz: x = z by (rewrite goal with xz_true; .);
        have Pz: P(z) by (rewrite prem with xz);
        (apply all_keys in prem, Pz)
      }
      case false {
        switch x < z {
          case true {
            apply all_keys in goal;
            have Pz: P(z) by apply all_keys in prem;
            have LxP: all_keys(insert(L,x,v),P)
              by using IHL[x,v,P] with PL, prem;
            (LxP, Pz, PR)
          }
          case false {
            apply all_keys in goal;
            have Pz: P(z) by apply all_keys in prem;
            have RxP: all_keys(insert(R,x,v),P)
              by using IHR[x,v,P] with PR, prem;
            (PL, Pz, RxP)
          }
        }
      }
    }
  }
end

theorem insert_BST:
  all T:Tree. all x:Nat, v:Nat.
  if is_BST(T)
  then is_BST(insert(T, x, v))
proof
  induction Tree
  case empty_tree {
    arbitrary x:Nat,v:Nat;
    assume prem;
    have is_BST(insert(empty_tree,x,v))
      by apply insert, is_BST, all_keys in goal; .
  }
  case tree_node(L, y, v2, R) assume IHL, IHR {
    arbitrary x:Nat, v:Nat;
    assume prem: is_BST(tree_node(L,y,v2,R));
    have BST_L: is_BST(L) by apply is_BST in prem;
    have BST_R: is_BST(R) by apply is_BST in prem;
    have L_less_y: all_keys(L, λk{k < y})
       by conjunct 0 of (apply is_BST in prem);
    have y_less_R: all_keys(R, λk{y < k})
       by conjunct 1 of (apply is_BST in prem);
    apply insert in goal;
    switch x = y {
      case true {
        have is_BST(tree_node(L,y,v,R))
            by apply is_BST in goal; L_less_y, y_less_R, BST_L, BST_R
      }
      case false assume xy_false {
        have not_xey: not (x = y) by (assume xy; rewrite xy with xy_false);
        switch x < y {
          case true assume xy_true {
            have xy: x < y by (rewrite goal with xy_true; .);
            have Lx_less_y: all_keys(insert(L,x,v), λk{k < y})
              by using insert_all[L][x,v,(λk{k < y}):fn(Nat)->bool]
                 with L_less_y, xy;
            have BST_Lx: is_BST(insert(L,x,v))
               by using IHL[x,v] with BST_L;
            have is_BST(tree_node(insert(L,x,v),y,v2,R))
                by apply is_BST in goal; Lx_less_y, y_less_R, BST_R, BST_Lx
          }
          case false assume xy_false {
            have BST_Rx: is_BST(insert(R,x,v))
              by using IHR[x,v] with BST_R;
            have not_xly: not (x < y)
               by (assume prem; rewrite prem with xy_false); 
            have yx: y < x by using trichotomy2[y,x] with not_xey, not_xly;
            have y_less_Rx: all_keys(insert(R,x,v), λk{y < k})
              by using insert_all[R][x,v,(λk{y < k}):fn(Nat)->bool]
                 with y_less_R, yx;
            have is_BST(tree_node(L,y,v2,insert(R,x,v)))
                by apply is_BST in goal; L_less_y, BST_Rx, y_less_Rx, BST_L
          }
        }
      }
    }
  }
end

theorem lookup_empty:
  all k:Nat.
  lookup(empty_tree)(k) = none
proof
  arbitrary k:Nat;
  apply lookup in goal;
  .
end


/*
theorem lookup_tree_node:
  all L:Tree, R:Tree, j:Nat, w:Nat, f:fn(Nat)->Option<Nat>.
  if lookup(tree_node(L,j,w,R)) = f
  then f(j) = w
  and lookup(L) = update(f, j, none)
  and lookup(R) = update(f, j, none)
proof
  ?
end
*/

theorem true_is_true: all x:bool. if x then x = true
proof
  arbitrary x:bool;
  assume x_true;
  switch x {
    case true { . }
    case false assume x_false {
      have false by rewrite x_true with x_false
    }
  }
end

theorem false_is_false: all x:bool. if not x then x = false
proof
  arbitrary x:bool;
  assume not_x;
  switch x {
    case true assume x_true {
      have x_is_true: x by (rewrite goal with x_true; .);
      have false by using not_x with x_is_true
    }
    case false { . }
  }
end


theorem lookup_insert_update:
  all T:Tree. all k:Nat, v:Nat.
  if is_BST(T)
  then lookup(insert(T, k, v)) = update(lookup(T), k, just(v))
proof
  induction Tree
  case empty_tree {
    arbitrary k:Nat, v:Nat;
    assume prem;
    extensionality; arbitrary x:Nat;
    switch x = k {
      case true assume xk_true {
        enable insert, lookup, update;
        equations
          lookup(insert(empty_tree,k,v))(x) = just(v)
  	      by (rewrite goal with xk_true; .)
	 ... = update(lookup(empty_tree),k,just(v))(x)
  	      by (rewrite goal with xk_true; .)
      }
      case false assume xk_false {
        switch x < k {
          case true assume x_less_k_true {
	    have x_neq_k: not (x = k)
	      by (using less_implies_not_equal[x][k] with rewrite goal with x_less_k_true; .);
	    have xk_false: (x = k) = false
	      by using false_is_false[x = k] with x_neq_k;
	    equations
	      lookup(insert(empty_tree,k,v))(x) = none
	          by (apply insert, lookup in goal; rewrite goal with x_less_k_true;
	              rewrite goal with using false_is_false[x = k] with x_neq_k;.)
              ... = update(lookup(empty_tree),k,just(v))(x)
	          by (apply lookup, update in goal; rewrite goal with xk_false;.)
	  }
          case false assume x_less_k_false {
	    equations
  	      lookup(insert(empty_tree,k,v))(x) = none
  	          by (apply insert, lookup in goal; rewrite goal with xk_false; rewrite goal with x_less_k_false; .)
  	      ... = update(lookup(empty_tree),k,just(v))(x)
	          by (apply update, lookup in goal; rewrite goal with xk_false; .)
	  }
        }
      }
    }

/*    
    apply insert, lookup, update in goal;
    extensionality; arbitrary x:Nat;
    switch x = k {
      case true { . }
      case false {
        switch x < k {
          case true { . }
          case false { . }
        }
      }
    }
*/    
  }
  case tree_node(L, j, w, R) assume IHL, IHR {
    arbitrary k:Nat, v:Nat;
    assume prem;
    extensionality; arbitrary x:Nat;
    cases trichotomy[x][j]
    case x_less_j {
      have not_xj: not (x = j)
        by using less_implies_not_equal[x][j] with x_less_j;
      switch k < j {
        case true assume k_less_j_true {
          apply insert in goal;
	  rewrite goal with k_less_j_true;
	  have k_less_j: k < j by (rewrite goal with k_less_j_true; .);
	  have not_kj: not (k = j)
	      by using less_implies_not_equal[k][j] with k_less_j;
	  rewrite goal with using false_is_false[k = j] with not_kj;
	  apply lookup, insert, update in goal;
	  rewrite goal with using false_is_false[x = j] with not_xj;
	  rewrite goal with (using true_is_true[x < j] with x_less_j);
	  have BST_L: is_BST(L) by apply is_BST in prem;
	  have IHL2: lookup(insert(L,k,v)) = update(lookup(L),k,just(v))
	    by using IHL[k,v] with BST_L;
	  rewrite goal with IHL2; apply update in goal;
          .
        }
        case false assume k_less_j_false {
	  have not_k_less_j: not (k < j)
	     by (assume kj; have false by rewrite kj with k_less_j_false);
	  apply lookup, update in goal;
	  have lookupL: lookup(insert(tree_node(L,j,w,R),k,v))(x) = lookup(L)(x)
	    by (apply insert, lookup in goal;
	        switch k = j {
		  case true {
		    apply lookup in goal;
		    rewrite goal with using false_is_false[x = j] with not_xj;
		    rewrite goal with (using true_is_true[x < j] with x_less_j);
		    .
		  }
		  case false assume kj_false {
		    rewrite goal with k_less_j_false;
		    apply lookup in goal;
		    rewrite goal with using false_is_false[x = j] with not_xj;
		    rewrite goal with (using true_is_true[x < j] with x_less_j);
		    .
		  }
		});
          rewrite goal with lookupL;
	  have x_neq_k: not (x = k)
	    by (assume xk; using (rewrite not_k_less_j with xk)
	                   with (rewrite x_less_j with xk));
          rewrite goal with using false_is_false[x = k] with x_neq_k;
          rewrite goal with using false_is_false[x = j] with not_xj;
	  rewrite goal with (using true_is_true[x < j] with x_less_j);
          .
        }
      }
    }
    case x_eq_j {
      rewrite goal with x_eq_j;
      apply insert in goal;
      switch k = j {
        case true assume kj {
	  apply lookup, update in goal;
	  have jk: j = k by symmetric (rewrite goal with kj; .);
	  rewrite goal with jk;
	  .
	}
        case false assume kj_false {
          have jk_false: (j = k) = false
              by (using false_is_false[j = k] with
                  (assume jk; have false by rewrite kj_false with jk));
	  switch k < j {
	    case true {
	      apply lookup, update in goal;
	      rewrite goal with jk_false;
	      .
	    }
	    case false {
	      apply lookup, update in goal;
	      rewrite goal with jk_false;
              .
	    }
          }
        }
      }
    }
    case j_less_x {
      have not_x_less_j: not (x < j)
        by using less_implies_not_greater[j][x] with j_less_x;
      have not_jx: not (j = x)
        by using less_implies_not_equal[j][x] with j_less_x;
      have not_xj: not (x = j)
        by (assume xj; using not_jx with symmetric xj);
      switch j < k {
	case true assume j_less_k_true {
	  have j_less_k: j < k by (rewrite goal with j_less_k_true; .);
	  have not_jk: not (j = k)
	    by using less_implies_not_equal[j][k] with j_less_k;
	  apply insert in goal;
	  rewrite goal with using false_is_false[k = j]
	       with (assume kj; using not_jk with symmetric kj);
	  have not_k_less_j: not (k < j)
	       by using less_implies_not_greater[j][k] with j_less_k;
	  rewrite goal with using false_is_false[k < j] with not_k_less_j;
	  apply lookup, update in goal;
	  rewrite goal with using false_is_false[x = j]
	    with (assume xj; using not_jx with symmetric xj);
	  have not_xj: not (x < j)
	    by using less_implies_not_greater[j][x] with j_less_x;
	  rewrite goal with using false_is_false[x < j] with not_xj;
	  have BST_R: is_BST(R) by apply is_BST in prem;
	  have IHR2: lookup(insert(R,k,v)) = update(lookup(R),k,just(v))
	    by using IHR[k,v] with BST_R;
	  rewrite goal with IHR2; apply update in goal;
	  .
	}
        case false assume j_less_k_false {
	  have not_jk: not (j < k)
	    by (assume jk; have false by rewrite jk with j_less_k_false);
	  apply lookup, update in goal;
	  have lookupR: lookup(insert(tree_node(L,j,w,R),k,v))(x) = lookup(R)(x)
	    by (apply insert, lookup in goal;
	        switch k = j {
		  case true {
		    apply lookup in goal;
		    rewrite goal with using false_is_false[x = j] with not_xj;
		    rewrite goal with using false_is_false[x < j]
		                      with not_x_less_j;
		    .
		  }
		  case false assume kj_false {
		    have not_j_eq_k: not (j = k)
		       by (assume jk; rewrite (symmetric jk) with kj_false);
		    have k_less_j: k < j
		       by using trichotomy2[k, j] with (not_j_eq_k, not_jk);
		    rewrite goal with using true_is_true[k < j]
		           with k_less_j;
	            apply lookup in goal;
		    rewrite goal with (using false_is_false[x = j]
 		                       with assume xj;
				         using not_jx with symmetric xj);
                    rewrite goal with (using false_is_false[x < j]
		                      with not_x_less_j);
		    .
		  }
		});
	  rewrite goal with lookupR;
	  have x_neq_k: not (x = k)
	    by (assume xk; using (rewrite not_jk with (symmetric xk))
	                   with j_less_x);
          rewrite goal with (using false_is_false[x = k] with x_neq_k);
          rewrite goal with (using false_is_false[x = j] with
	    assume xj; (using not_jx with symmetric xj));
	  rewrite goal with (using false_is_false[x < j] with not_x_less_j);
          .
        }
      }
    }
  }
end

