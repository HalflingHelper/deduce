/*

  Binary Search Tree
  (not balanced)

*/

import Nat
import Pair

union Tree {
  empty_tree;
  tree_node(Tree, Nat, Nat, Tree);
}

function insert(Tree, Nat, Nat) -> Tree {
  insert(empty_tree, x, v) = tree_node(empty_tree, x, v, empty_tree);
  insert(tree_node(L, y, v2, R), x, v) =
    if x = y then
      tree_node(L, y, v2, R)
    else if x < y then
      tree_node(insert(L, x, v), y, v2, R)
    else
      tree_node(L, y, v2, insert(R, x, v));
}

function containsKey(Tree, Nat) -> bool {
  containsKey(empty_tree, x) = false;
  containsKey(tree_node(L, y, v, R), x) =
    x = y or containsKey(L, x) or containsKey(R, x);
}

function lookup(Tree, Nat, Nat) -> Nat {
  lookup(empty_tree, x, d) = d;
  lookup(tree_node(L, y, v, R), x, d) =
    if x = y then
      v
    else if x < y then
      lookup(L, x, d)
    else
      lookup(R, x, d);
}

function all_keys(Tree, fn (Nat) -> bool) -> bool {
  all_keys(empty_tree, P) = true;
  all_keys(tree_node(L, x, v, R), P) =
    all_keys(L, P) and P(x) and all_keys(R, P);
}

function is_BST(Tree) -> bool {
  is_BST(empty_tree) = true;
  is_BST(tree_node(L, x, v, R)) =
    all_keys(L, λk{k < x}) and all_keys(R, λk{x < k}) and
    is_BST(L) and is_BST(R);
}

theorem insert_all:
  all T:Tree. all x:Nat, v:Nat, P: fn(Nat) -> bool.
  if all_keys(T, P) and P(x)
  then all_keys(insert(T, x, v), P)
proof
  induction Tree
  case empty_tree {
    arbitrary x:Nat,v:Nat, Q: fn(Nat) -> bool;
    assume prem: all_keys(empty_tree,Q) and Q(x);
    apply all_keys, insert in goal;
    conjunct 1 of prem
  }
  case tree_node(L, z, v2, R) {
    arbitrary x:Nat,v:Nat,P: fn(Nat) -> bool;
    assume prem: all_keys(tree_node(L,z,v2,R),P) and P(x);
    have PL: all_keys(L, P) by apply all_keys in prem;
    have PR: all_keys(R, P) by apply all_keys in prem;    
    apply all_keys, insert in goal;
    switch x = z {
      case true {
        apply all_keys in goal;
	have xz: x = z by (rewrite goal with EQ; .);
	have Pz: P(z) by (rewrite prem with xz);
        (apply all_keys in prem, Pz)
      }
      case false {
        switch x < z {
	  case true {
	    apply all_keys in goal;
	    have Pz: P(z) by apply all_keys in prem;
	    have LxP: all_keys(insert(L,x,v),P)
	      by using (conjunct 0 of IH)[x,v,P] with PL, prem;
	    (LxP, Pz, PR)
	  }
	  case false {
	    apply all_keys in goal;
	    have Pz: P(z) by apply all_keys in prem;
	    have RxP: all_keys(insert(R,x,v),P)
	      by using (conjunct 1 of IH)[x,v,P] with PR, prem;
	    (PL, Pz, RxP)
	  }
	}
      }
    }
  }
end

theorem insert_less:
  all T:Tree. all x:Nat, y:Nat, v:Nat.
  if all_keys(T, λk{k < y}) and x < y
  then all_keys(insert(T, x, v), λk{k < y})
proof
  arbitrary T:Tree;
  arbitrary x:Nat, y:Nat, v:Nat;
  assume prem: all_keys(T, λ k {k < y}) and x < y;
  using insert_all[T][x,v,(λ k {k < y}) : fn(Nat)->bool] with prem
end

theorem insert_BST:
  all T:Tree. all x:Nat, v:Nat.
  if is_BST(T)
  then is_BST(insert(T, x, v))
proof
  induction Tree
  case empty_tree {
    arbitrary x:Nat,v:Nat;
    assume prem;
    apply insert, is_BST, all_keys in goal;
    .
  }
  case tree_node(L, y, v2, R) {
    arbitrary x:Nat,v:Nat;
    assume prem: is_BST(tree_node(L,y,v2,R));
    have BST_L: is_BST(L) by apply is_BST in prem;
    have BST_R: is_BST(R) by apply is_BST in prem;
    have Ly: all_keys(L,λ k{k < y})
       by conjunct 0 of (apply is_BST in prem);
    have Ry: all_keys(R,λ k{y < k})
       by conjunct 1 of (apply is_BST in prem);
    apply insert, is_BST in goal;
    switch x = y {
      case true {
        apply is_BST in goal;
        (Ly, Ry, BST_L, BST_R)
      }
      case false {
        have not_xey: not (x = y) by (assume xy; rewrite xy with EQ);
        switch x < y {
          case true {
	    have xy: x < y by (rewrite goal with EQ; .);
	    apply is_BST in goal;
	    have Lx_y: all_keys(insert(L,x,v),λ k{k < y})
	      by using insert_less[L][x,y,v] with Ly, xy;
	    have BST_Lx: is_BST(insert(L,x,v))
	       by using (conjunct 0 of IH)[x,v] with BST_L;
	    Lx_y, Ry, BST_R, BST_Lx
	  }
	  case false {
	    apply is_BST in goal;
	    have BST_Rx: is_BST(insert(R,x,v))
	      by using (conjunct 1 of IH)[x,v] with BST_R;
	    have not_xly: not (x < y) by (assume prem; rewrite prem with EQ); 
	    have yx: y < x by using trichotomy2[y,x] with not_xey, not_xly;
	    have Rx_y: all_keys(insert(R,x,v),λ k{y < k})
	      by using insert_all[R][x,v,(λ k {y < k}) : fn(Nat)->bool]
	         with Ry, yx;
	    Ly, BST_Rx, Rx_y, BST_L
	  }
	}
      }
    }
  }
end