/*

  Binary Search Tree
  (not balanced)

*/

import Nat
import Pair
import Option
import Maps

theorem ex_mid: all b:bool. b or not b
proof
  arbitrary b:bool;
  switch b {
    case true { . }
    case false { . }
  }
end

union Tree {
  empty_tree;
  tree_node(Tree, Nat, Nat, Tree);
}

function insert(Tree, Nat, Nat) -> Tree {
  insert(empty_tree, x, v) = tree_node(empty_tree, x, v, empty_tree);
  insert(tree_node(L, y, v2, R), x, v) =
    if x = y then
      tree_node(L, y, v, R)
    else if x < y then
      tree_node(insert(L, x, v), y, v2, R)
    else
      tree_node(L, y, v2, insert(R, x, v));
}

function keys(Tree) -> fn(Nat)->bool {
  containsKey(empty_tree) = λx{false};
  containsKey(tree_node(L, y, v, R)) = λx{x = y} ∪ keys(L) ∪ keys(R);
}

function lookup(Tree) -> fn (Nat) -> Option<Nat> {
  lookup(empty_tree) = λx{none};
  lookup(tree_node(L, y, v, R)) =
    λx{if x = y then
         just(v)
       else if x < y then
         lookup(L)(x)
       else
         lookup(R)(x)};
}

function all_keys(Tree, fn (Nat) -> bool) -> bool {
  all_keys(empty_tree, P) = true;
  all_keys(tree_node(L, x, v, R), P) =
    all_keys(L, P) and P(x) and all_keys(R, P);
}

function is_BST(Tree) -> bool {
  is_BST(empty_tree) = true;
  is_BST(tree_node(L, x, v, R)) =
    all_keys(L, λk{k < x}) and all_keys(R, λk{x < k}) and
    is_BST(L) and is_BST(R);
}

theorem insert_all:
  all T:Tree. all x:Nat, v:Nat, P: fn(Nat) -> bool.
  if all_keys(T, P) and P(x)
  then all_keys(insert(T, x, v), P)
proof
  induction Tree
  case empty_tree {
    arbitrary x:Nat,v:Nat, P: fn(Nat) -> bool;
    assume prem: all_keys(empty_tree,P) and P(x);
    show all_keys(insert(empty_tree, x, v), P);
    definition all_keys, insert;
    show P(x)  by prem
  }
  case tree_node(L, z, v2, R) assume IHL, IHR {
    arbitrary x:Nat,v:Nat,P: fn(Nat) -> bool;
    assume prem: all_keys(tree_node(L,z,v2,R),P) and P(x);
    enable all_keys, insert;
    have PL: all_keys(L, P)  by prem;
    have Pz: P(z)  by prem;
    have PR: all_keys(R, P)  by prem;
    show all_keys(insert(tree_node(L, z, v2, R), x, v), P);
    cases ex_mid[x = z]
    case xz: x = z {
      rewrite with xz;
      show all_keys(L,P) and P(z) and all_keys(R,P)  by (PL, Pz, PR)
    }
    case not_xz: not (x = z) {
      cases ex_mid[x < z]
      case xlz: x < z {
        have LxP: all_keys(insert(L,x,v),P)  by using IHL[x,v,P] with PL, prem;
        rewrite with not_xz | xlz;
        show all_keys(insert(L,x,v),P) and P(z) and all_keys(R,P)  by LxP,Pz,PR
      }
      case not_xlz: not (x < z) {
        have RxP: all_keys(insert(R,x,v),P)  by using IHR[x,v,P] with PR, prem;
        rewrite with not_xz | not_xlz;
        show all_keys(L,P) and P(z) and all_keys(insert(R,x,v),P) by PL,Pz,RxP
      }
    }
  }
end

theorem insert_BST:
  all T:Tree. all x:Nat, v:Nat.
  if is_BST(T) then is_BST(insert(T, x, v))
proof
  induction Tree
  case empty_tree {
    arbitrary x:Nat,v:Nat;
    assume prem;
    show is_BST(insert(empty_tree,x,v))  by definition insert,is_BST,all_keys; .
  }
  case tree_node(L, y, v2, R) assume IHL, IHR {
    arbitrary x:Nat, v:Nat;
    assume prem: is_BST(tree_node(L,y,v2,R));
    have BST_L: is_BST(L) by apply is_BST in prem;
    have BST_R: is_BST(R) by apply is_BST in prem;
    have L_less_y: all_keys(L, λk{k < y})
       by conjunct 0 of (apply is_BST in prem);
    have y_less_R: all_keys(R, λk{y < k})
       by conjunct 1 of (apply is_BST in prem);
    show is_BST(insert(tree_node(L, y, v2, R), x, v));
    definition insert;
    switch x = y {
      case true {
        show is_BST(tree_node(L,y,v,R))
            by definition is_BST; L_less_y, y_less_R, BST_L, BST_R
      }
      case false assume xy_false {
        have not_xey: not (x = y) by (assume xy; rewrite xy with xy_false);
        switch x < y {
          case true assume xy_true {
            have xy: x < y by (rewrite with xy_true; .);
            have Lx_less_y: all_keys(insert(L,x,v), λk{k < y})
              by using insert_all[L][x,v,(λk{k < y}):fn(Nat)->bool]
                 with L_less_y, xy;
            have BST_Lx: is_BST(insert(L,x,v))  by using IHL[x,v] with BST_L;
            show is_BST(tree_node(insert(L,x,v),y,v2,R))
                by definition is_BST; Lx_less_y, y_less_R, BST_R, BST_Lx
          }
          case false assume xy_false {
            have BST_Rx: is_BST(insert(R,x,v))
              by using IHR[x,v] with BST_R;
            have not_xly: not (x < y)
               by (assume prem; rewrite prem with xy_false); 
            have yx: y < x by using trichotomy2[y,x] with not_xey, not_xly;
            have y_less_Rx: all_keys(insert(R,x,v), λk{y < k})
              by using insert_all[R][x,v,(λk{y < k}):fn(Nat)->bool]
                 with y_less_R, yx;
            show is_BST(tree_node(L,y,v2,insert(R,x,v)))
                by definition is_BST; L_less_y, BST_Rx, y_less_Rx, BST_L
          }
        }
      }
    }
  }
end

theorem lookup_empty:
  all k:Nat.
  lookup(empty_tree)(k) = none
proof
  arbitrary k:Nat;
  definition lookup;
  .
end


theorem true_is_true: all x:bool. if x then x = true
proof
  arbitrary x:bool;
  assume x_true;
  switch x {
    case true { . }
    case false assume x_false {
      have false by rewrite x_true with x_false
    }
  }
end

theorem false_is_false: all x:bool. if not x then x = false
proof
  arbitrary x:bool;
  assume not_x;
  switch x {
    case true assume x_true {
      have x_is_true: x by (rewrite with x_true; .);
      have false by using not_x with x_is_true
    }
    case false { . }
  }
end

theorem lookup_insert_update_empty:
  all k:Nat, v:Nat.
  lookup(insert(empty_tree, k, v)) = update(lookup(empty_tree), k, just(v))
proof
  arbitrary k:Nat, v:Nat;
  extensionality; arbitrary x:Nat;
  switch x = k {
    case true assume xk_true {
      enable insert, lookup, update;
      equations
	lookup(insert(empty_tree,k,v))(x)
	    = just(v)                            by (rewrite with xk_true; .)
	... = update(lookup(empty_tree),k,just(v))(x)
		by (rewrite with xk_true; .)
    }
    case false assume xk_false {
      switch x < k {
	case true assume x_less_k_true {
	  enable insert, lookup, update;
	  equations
	    lookup(insert(empty_tree,k,v))(x)
		= none          by (rewrite with x_less_k_true | xk_false; .)
	    ... = update(lookup(empty_tree),k,just(v))(x)
				by (rewrite with xk_false; .)
	}
	case false assume x_less_k_false {
	  enable insert, lookup, update;
	  equations
	    lookup(insert(empty_tree,k,v))(x)
		= none          by (rewrite with xk_false | x_less_k_false; .)
	    ... = update(lookup(empty_tree),k,just(v))(x)
				by (rewrite with xk_false; .)
	}
      }
    }
  }
end

theorem lookup_insert_update_empty_short:
  all k:Nat, v:Nat.
  lookup(insert(empty_tree, k, v)) = update(lookup(empty_tree), k, just(v))
proof
  arbitrary k:Nat, v:Nat;
  extensionality; arbitrary x:Nat;
  enable insert, lookup, update;
  switch x = k {
    case true assume xk_true { . }
    case false assume xk_false {
      switch x < k {
	case true { . }
	case false { . }
      }
    }
  }
end

theorem lookup_insert_update:
  all T:Tree. all k:Nat, v:Nat.
  if is_BST(T)
  then lookup(insert(T, k, v)) = update(lookup(T), k, just(v))
proof
  induction Tree
  case empty_tree {
    arbitrary k:Nat, v:Nat;
    assume prem;
    show lookup(insert(empty_tree,k,v)) = update(lookup(empty_tree),k,just(v));
    lookup_insert_update_empty[k,v]
  }
  case tree_node(L, j, w, R) assume IHL, IHR {
    arbitrary k:Nat, v:Nat;
    assume prem;
    extensionality; arbitrary x:Nat;
    cases trichotomy[x][j]
    case x_less_j {
      have not_xj: not (x = j)
        by using less_not_equal[x][j] with x_less_j;
      switch k < j {
        case true assume k_less_j_true {
          have k_less_j: k < j by (rewrite with k_less_j_true; .);
          have not_kj: not (k = j)
              by using less_not_equal[k][j] with k_less_j;
          have BST_L: is_BST(L) by apply is_BST in prem;
          enable lookup, insert, update;
          equations
            lookup(insert(tree_node(L,j,w,R),k,v))(x)
                = lookup(insert(L,k,v))(x)
                      by (rewrite with k_less_j_true|not_kj|not_xj|x_less_j; .)
            ... = update(lookup(L),k,just(v))(x)
                      by (rewrite with (using IHL[k,v] with BST_L); .)
            ... = update(lookup(tree_node(L,j,w,R)), k, just(v))(x)
                      by (rewrite with not_xj | x_less_j; .)
        }
        case false assume k_less_j_false {
          have not_k_less_j: not (k < j)
             by (assume kj; have false by rewrite kj with k_less_j_false);
          have x_neq_k: not (x = k)
            by (assume x_eq_k; using (rewrite not_k_less_j with x_eq_k)
                               with (rewrite x_less_j with x_eq_k));
          enable insert, lookup, update;			
          equations
            lookup(insert(tree_node(L,j,w,R),k,v))(x)
	        = lookup(L)(x)
                   by (switch k = j {
		      case true { rewrite with not_xj | x_less_j; . }
		      case false {rewrite with k_less_j_false|not_xj|x_less_j;.}
		      })
	    ... = update(lookup(tree_node(L,j,w,R)),k,just(v))(x)
                    by (rewrite with not_k_less_j|x_neq_k|x_less_j|not_xj; .)
        }
      }
    }
    case x_eq_j {
      switch k = j {
        case true assume kj {
          have jk: j = k by symmetric (rewrite with kj; .);
	  enable insert, lookup, update;
	  equations
	    lookup(insert(tree_node(L,j,w,R),k,v))(x)
	        = just(v)    	              by (rewrite with kj|x_eq_j; .)
            ... = update(lookup(tree_node(L,j,w,R)),k,just(v))(x)
 	                                      by (rewrite with x_eq_j|jk; .)
	}
	case false assume kj_false {
          have jk_false: (j = k) = false
              by (using false_is_false[j = k] with
                  (assume jk; have false by rewrite kj_false with jk));
	  show lookup(insert(tree_node(L,j,w,R),k,v))(x)
	       = update(lookup(tree_node(L,j,w,R)),k,just(v))(x);
          switch k < j {
	    case true assume klj: (k < j) = true {
	      enable insert, lookup, update;
	      equations
	        lookup(insert(tree_node(L,j,w,R),k,v))(x)
	           = just(w)           by (rewrite with kj_false|klj|x_eq_j; .)
	        ... = update(lookup(tree_node(L,j,w,R)),k,just(v))(x)
	                               by (rewrite with x_eq_j|jk_false; .)
	    }
	    case false assume not_klj: (k < j) = false {
	      enable insert, lookup, update;
              equations
	        lookup(insert(tree_node(L,j,w,R),k,v))(x)
                    = just(w)         by rewrite with kj_false|not_klj|x_eq_j; .
                ... = update(lookup(tree_node(L,j,w,R)),k,just(v))(x)
                                      by rewrite with x_eq_j|jk_false; .
	    }
	  }
	}
      }
    }
    case j_less_x {
      have not_x_less_j: not (x < j)
        by using less_implies_not_greater[j][x] with j_less_x;
      have not_jx: not (j = x)
        by using less_not_equal[j][x] with j_less_x;
      have not_xj: not (x = j)
        by (assume xj; using not_jx with symmetric xj);
      switch j < k {
        case true assume j_less_k_true {
          have j_less_k: j < k by (rewrite with j_less_k_true; .);
          have not_jk: not (j = k)
            by using less_not_equal[j][k] with j_less_k;
          apply insert in goal;
          rewrite with using false_is_false[k = j]
               with (assume kj; using not_jk with symmetric kj);
          have not_k_less_j: not (k < j)
               by using less_implies_not_greater[j][k] with j_less_k;
          rewrite with using false_is_false[k < j] with not_k_less_j;
          apply lookup, update in goal;
          rewrite with using false_is_false[x = j]
            with (assume xj; using not_jx with symmetric xj);
          have not_xj: not (x < j)
            by using less_implies_not_greater[j][x] with j_less_x;
          rewrite with using false_is_false[x < j] with not_xj;
          have BST_R: is_BST(R) by apply is_BST in prem;
          have IHR2: lookup(insert(R,k,v)) = update(lookup(R),k,just(v))
            by using IHR[k,v] with BST_R;
          rewrite with IHR2; apply update in goal;
          .
        }
        case false assume j_less_k_false {
          have not_jk: not (j < k)
            by (assume jk; have false by rewrite jk with j_less_k_false);
          apply lookup, update in goal;
          have lookupR: lookup(insert(tree_node(L,j,w,R),k,v))(x) = lookup(R)(x)
            by (apply insert, lookup in goal;
                switch k = j {
                  case true {
                    apply lookup in goal;
                    rewrite with using false_is_false[x = j] with not_xj;
                    rewrite with using false_is_false[x < j]
                                      with not_x_less_j;
                    .
                  }
                  case false assume kj_false {
                    have not_j_eq_k: not (j = k)
                       by (assume jk; rewrite (symmetric jk) with kj_false);
                    have k_less_j: k < j
                       by using trichotomy2[k, j] with (not_j_eq_k, not_jk);
                    rewrite with using true_is_true[k < j]
                           with k_less_j;
                    apply lookup in goal;
                    rewrite with (using false_is_false[x = j]
                                       with assume xj;
                                         using not_jx with symmetric xj);
                    rewrite with (using false_is_false[x < j]
                                      with not_x_less_j);
                    .
                  }
                });
          rewrite with lookupR;
          have x_neq_k: not (x = k)
            by (assume xk; using (rewrite not_jk with (symmetric xk))
                           with j_less_x);
          rewrite with x_neq_k;
          rewrite with (using false_is_false[x = j] with
            assume xj; (using not_jx with symmetric xj));
          rewrite with not_x_less_j;
          .
        }
      }
    }
  }
end

