union Nat {
  zero;
  suc(Nat);
}

function +(Nat,Nat) -> Nat {
  +(0, m) = m;
  +(suc(n), m) = suc(n + m);
}

function max(Nat,Nat) -> Nat {
  max(zero, n) = n;
  max(suc(m'), n) =
    switch n {
      case zero { suc(m') }
      case suc(n') { suc(max(m',n')) }
    };
}

theorem add_zero: all n:Nat. n + 0 = n
proof
  induction Nat
  case 0 {
    have 0 + 0 = 0 by apply + in goal; .
  }
  case suc(n') {
    equations
      suc(n') + 0 = suc(n' + 0) by apply + in goal; .
              ... = suc(n') by rewrite goal with IH; .
  }
end

theorem add_suc: all m:Nat. all n:Nat. m + suc(n) = suc(m + n)
proof
  induction Nat
  case 0 {
    arbitrary n : Nat;
    apply + in goal; .
  }
  case suc(n') {
    arbitrary n : Nat;
    have IHn: n' + suc(n) = suc(n' + n) by IH[n];
    have suc(n') + suc(n) = suc(suc(n') + n) by
    equations
    suc(n')+suc(n) = suc(n' + suc(n)) by apply + in goal; .
               ... = suc(suc(n' + n)) by rewrite goal with IH[n]; .
               ... = suc(suc(n') + n) by apply + in goal; .
  }
end

theorem add_one: all m:Nat. m + 1 = suc(m)
proof
  arbitrary m:Nat;
  equations
    m + 1 = suc(m + 0)      by add_suc[m][0]
      ... = suc(m)          by rewrite goal with add_zero[m]; .
end

theorem add_commute: all n:Nat. all m:Nat. n + m = m + n
proof
  induction Nat
  case 0 {
    arbitrary m : Nat;
    equations  0 + m = m       by apply + in goal; .
                 ... = m + 0   by symmetric add_zero[m]
  }
  case suc(n') {
    arbitrary m : Nat;
    equations
      suc(n') + m = suc(n' + m)       by apply + in goal; .
              ... = suc(m + n')       by rewrite goal with IH[m]; .
              ... = m + suc(n')       by symmetric add_suc[m][n']
  }
end

theorem add_assoc: all m:Nat. all n:Nat, o:Nat.
  (m + n) + o = m + (n + o)
proof
  induction Nat
  case 0 {
    arbitrary n:Nat, o:Nat;
    have (0 + n) + o = 0 + (n + o) by apply + in goal; .
  }
  case suc(m') {
    arbitrary n:Nat, o:Nat;
    equations
      (suc(m') + n) + o = suc((m' + n) + o) by apply + in goal; .
                    ... = suc(m' + (n + o))
                                   by rewrite goal with IH[n,o]; .
                    ... = suc(m') + (n + o) by apply + in goal; .
  }
end

theorem left_cancel: all x:Nat. all y:Nat, z:Nat.
  if x + y = x + z then y = z
proof
  induction Nat
  case 0 {
    arbitrary y:Nat, z:Nat;
    suppose prem: 0 + y = 0 + z;
    equations   y = 0 + y      by apply + in goal; .
              ... = 0 + z      by prem
              ... = z          by apply + in goal; .
  }
  case suc(x') {
    arbitrary y:Nat, z:Nat;
    suppose prem: suc(x') + y = suc(x') + z;
    have p1: suc(x' +  y) = suc(x' + z) by
      transitive have suc(x' +  y) = suc(x') + y by apply + in goal; .
      transitive prem apply + in goal; .;
    have p2: x' + y = x' + z by injective suc; p1;
    have IHyz: if x' + y = x' + z then y = z by IH[y,z];
    using IHyz with p2
  }
end

function pred(Nat) -> Nat {
  pred(0) = 0;
  pred(suc(n)) = n;
}

theorem pred_one: pred(suc(0)) = 0
proof
  apply pred in goal; .
end

function -(Nat,Nat) -> Nat {
  -(0, m) = 0;
  -(suc(n), m) = switch m {
                   case 0 { suc(n) }
                   case suc(m') { n - m' }
                 };
}

function sub_from(Nat,Nat) -> Nat {
  sub_from(0, m) = m;
  sub_from(suc(n), m) = sub_from(n, pred(m));
}

function diff(Nat,Nat) -> Nat {
  diff(0, m) = m;
  diff(suc(n'), m) = switch m {
                       case 0 { suc(n') }
                       case suc(m') { diff(n', m') }
                     };
}

theorem sub_one_one: 1 - 1 = 0
proof
  apply - in goal; .
end

function ≤(Nat,Nat) -> bool {
  ≤(0, m) = true;
  ≤(suc(n'), m) =
    switch m {
      case 0 { false }
      case suc(m') { n' ≤ m' }
    };
}

define < : fn Nat,Nat -> bool = λ x, y { suc(x) ≤ y }
define > : fn Nat,Nat -> bool = λ x, y { y < x }
define ≥ : fn Nat,Nat -> bool = λ x, y { y ≤ x }

theorem less_implies_less_equal:
  all x:Nat. all y:Nat.
  if x < y then x ≤ y
proof
  induction Nat
  case zero {
    arbitrary y:Nat;
    assume zy: 0 < y;
    apply ≤ in goal;
    .
  }
  case suc(x') {
    arbitrary y:Nat;
    assume sx_y: suc(x') < y;
    have ssx_y: suc(suc(x')) ≤ y by apply < in sx_y;
    switch y {
      case zero {
        have false by apply ≤ in (rewrite ssx_y with EQ)
      }
      case suc(y') {
        apply ≤ in goal;
	have ssx_sy: suc(suc(x')) ≤ suc(y') by rewrite ssx_y with EQ;
        have x_y: x' < y' by (apply <,≤ in goal; apply ≤ in ssx_sy);
	have x' ≤ y' by using IH[y'] with x_y
      }
    }
  }
end

theorem less_equal_refl: all n:Nat. n ≤ n
proof
  induction Nat
  case 0 { have 0 ≤ 0 by apply ≤ in goal; . }
  case suc(n') { have suc(n') ≤ suc(n') by apply ≤ in goal; IH }
end

theorem less_equal_trans: all m:Nat. all n:Nat, o:Nat.
  if m ≤ n and n ≤ o then m ≤ o
proof
  induction Nat
  case 0 {
    arbitrary n:Nat, o:Nat;
    suppose _;
    have 0 ≤ o by apply ≤ in goal; .
  }
  case suc(m') {
    arbitrary n:Nat, o:Nat;
    assume Prem : suc(m') ≤ n and n ≤ o;
    have sm_n: suc(m') ≤ n by Prem;
    have n_o: n ≤ o by Prem;
    switch n {
      case 0 {
        have sm_z: suc(m') ≤ 0 by rewrite sm_n with EQ;
        have false by apply ≤ in sm_z
      }
      case suc(n') {
        have sm_sn: suc(m') ≤ suc(n') by rewrite sm_n with EQ;
        have m_n: m' ≤ n' by apply ≤ in sm_sn;
        have sn_o: suc(n') ≤ o by rewrite n_o with EQ;
        switch o {
          case 0 {
            have sn_z: suc(n') ≤ 0 by rewrite sn_o with EQ;
            have false by apply ≤ in sn_z
          }
          case suc(o') {
            have sn_so: suc(n') ≤ suc(o') by rewrite sn_o with EQ;
            have n_o: n' ≤ o' by apply ≤ in sn_so;
	    apply ≤ in goal; 
            have m' ≤ o' by using IH[n',o'] with m_n, n_o
          }
        }
      }
    }
  }
end

theorem not_less_less_equal:
  all x: Nat. all y: Nat.
  if not (x < y) then y ≤ x
proof
  induction Nat
  case zero {
    arbitrary y: Nat;
    assume not_0_y: not (0 < y);
    switch y {
      case zero { apply ≤ in goal; . }
      case suc(y') {
        have false by using (rewrite not_0_y with EQ) with (apply <, ≤ in goal; .)
      }
    }
  }
  case suc(x') {
    arbitrary y: Nat;
    assume not_sx_y: not (suc(x') < y);
    switch y {
      case zero { apply ≤ in goal; . }
      case suc(y') {
        have not_x_y: not (x' < y')
	  by (assume x_y: x' < y';
	      have sx_sy: suc(x') < suc(y') by (apply <, ≤ in goal; apply <, ≤ in x_y);
	      have sx_y: suc(x') < y by (rewrite goal with EQ; sx_sy);
	      using not_sx_y with sx_y);
	apply ≤ in goal;
	have y' ≤ x' by using IH[y'] with not_x_y
      }
    }
  }
end

theorem less_implies_not_equal:
  all x:Nat. all y:Nat.
  if x < y then not (x = y)
proof
  induction Nat
  case zero {
    arbitrary y:Nat;
    assume z_less_y;
    assume z_eq_y;
    have false by apply <, ≤, in (rewrite z_less_y with (symmetric z_eq_y))
    }
  case suc(x') {
    arbitrary y:Nat;
    assume sx_less_y;
    assume xs_eq_y;
    switch y {
      case zero { have false by rewrite xs_eq_y with EQ }
      case suc(y') { ? }
    }
  }
end

theorem max_suc: all x:Nat. max(suc(x), x) = suc(max(x,x))
proof
  induction Nat
  case zero {
    apply max in goal;
    .
  }
  case suc(x') {
    equations
    max(suc(suc(x')),suc(x')) = suc(max(suc(x'),x'))
                                         by (apply max in goal; .)
    ... = suc(suc(max(x',x')))           by (rewrite goal with IH; .)
    ... = suc(max(suc(x'),suc(x')))      by (apply max in goal; .)
  }
end

theorem trichotomy:
  all x:Nat. all y:Nat.
  x < y  or  x = y  or  y < x
proof
  induction Nat
  case zero {
    arbitrary y:Nat;
    switch y {
      case zero { have 0 = 0 by reflexive }
      case suc(y') { have 0 < suc(y') by apply <,≤ in goal; . }
    }
  }
  case suc(x') {
    arbitrary y:Nat;
    switch y {
      case zero { have 0 < suc(x') by (apply <,≤ in goal; .) }
      case suc(y') {
        cases (have (x' < y' or x' = y' or y' < x') by IH[y'])
	case less { have suc(x') < suc(y') by apply <,≤ in goal; apply <,≤ in less }
	case eq { have suc(x') = suc(y') by rewrite goal with eq; . }
	case gtr { have suc(y') < suc(x') by (apply <,≤ in goal; apply <,≤ in gtr) }
      }
    }
  }
end
  
theorem trichotomy2:
  all y:Nat, x:Nat.
  if not (x = y) and not (x < y)
  then y < x
proof
  arbitrary y:Nat, x:Nat;
  assume prem;
  cases trichotomy[x][y]
  case less {
    have nxy: not (x < y) by prem;
    have false by using nxy with less
  }
  case eq {
    have neq: not (x = y) by prem;
    have false by using neq with eq
  }
  case greater {
    greater
  }
end

