union Nat {
  zero
  suc(Nat)
}

function operator +(Nat,Nat) -> Nat {
  operator +(0, m) = m
  operator +(suc(n), m) = suc(n + m)
}

function operator *(Nat,Nat) -> Nat {
  operator *(0, m) = 0
  operator *(suc(n), m) = m + (n * m)
}

function max(Nat,Nat) -> Nat {
  max(zero, n) = n
  max(suc(m'), n) =
    switch n {
      case zero { suc(m') }
      case suc(n') { suc(max(m',n')) }
    }
}

theorem add_zero: all n:Nat.  n + 0 = n
proof
  enable operator +
  induction Nat
  case 0 {
    conclude 0 + 0 = 0   by .
  }
  case suc(n') suppose IH {
    equations
      suc(n') + 0 = suc(n' + 0)  by .
              ... = suc(n')      by rewrite IH.
  }
end

theorem add_suc: all m:Nat. all n:Nat.  m + suc(n) = suc(m + n)
proof
  enable operator +
  induction Nat
  case 0 {
    arbitrary n : Nat
    conclude 0 + suc(n) = suc(0 + n)  by .
  }
  case suc(n') suppose IH {
    arbitrary n : Nat
    equations
      suc(n') + suc(n) = suc(n' + suc(n))  by .
                   ... = suc(suc(n' + n))  by rewrite IH[n].
                   ... = suc(suc(n') + n)  by .
  }
end

theorem add_one: all m:Nat.  m + 1 = suc(m)
proof
  arbitrary m:Nat
  equations
    m + 1 = suc(m + 0)  by add_suc[m][0]
      ... = suc(m)      by rewrite add_zero[m].
end

theorem add_commute: all n:Nat. all m:Nat.  n + m = m + n
proof
  enable operator +
  induction Nat
  case 0 {
    arbitrary m : Nat
    equations  0 + m = m      by .
                 ... = m + 0  by symmetric add_zero[m]
  }
  case suc(n') suppose IH {
    arbitrary m : Nat
    equations suc(n') + m = suc(n' + m)  by .
                      ... = suc(m + n')  by rewrite IH[m].
                      ... = m + suc(n')  by symmetric add_suc[m][n']
  }
end

theorem add_assoc: all m:Nat. all n:Nat, o:Nat.
  (m + n) + o = m + (n + o)
proof
  enable operator +
  induction Nat
  case 0 {
    arbitrary n:Nat, o:Nat
    have (0 + n) + o = 0 + (n + o)   by .
  }
  case suc(m') suppose IH {
    arbitrary n:Nat, o:Nat
    equations
      (suc(m') + n) + o = suc((m' + n) + o)  by .
                    ... = suc(m' + (n + o))  by rewrite IH[n,o].
                    ... = suc(m') + (n + o)  by .
  }
end

theorem left_cancel: all x:Nat. all y:Nat, z:Nat.
  if x + y = x + z then y = z
proof
  enable operator +
  induction Nat
  case 0 {
    arbitrary y:Nat, z:Nat
    suppose prem: 0 + y = 0 + z
    equations   y = 0 + y      by .
              ... = 0 + z      by prem
              ... = z          by .
  }
  case suc(x') suppose IH {
    arbitrary y:Nat, z:Nat
    suppose prem: suc(x') + y = suc(x') + z
    conclude y = z
      by (apply IH[y,z] to
         suffices x' + y = x' + z
         injective suc
         have suc(x' + y) = suc(x' + z)  by prem)
  }
end

function pred(Nat) -> Nat {
  pred(0) = 0
  pred(suc(n)) = n
}

theorem pred_one: pred(suc(0)) = 0
proof
  definition pred.
end

function operator -(Nat,Nat) -> Nat {
  operator -(0, m) = 0
  operator -(suc(n), m) =
    switch m {
      case 0 { suc(n) }
      case suc(m') { n - m' }
    }
}

function sub_from(Nat,Nat) -> Nat {
  sub_from(0, m) = m
  sub_from(suc(n), m) = sub_from(n, pred(m))
}

function diff(Nat,Nat) -> Nat {
  diff(0, m) = m
  diff(suc(n'), m) = switch m {
                       case 0 { suc(n') }
                       case suc(m') { diff(n', m') }
                     }
}

theorem sub_one_one: 1 - 1 = 0
proof
  definition operator -
  definition operator -.
end

union Pos {
  one
  succ(Pos)
}

import Option

function nat2pos(Nat) -> Option<Pos> {
  nat2pos(0) = none
  nat2pos(suc(n')) =
    switch nat2pos(n') {
      case none {
        just(one)
      }
      case just(p) {
        just(succ(p))
      }
    }
}

assert nat2pos(0) = none
assert nat2pos(1) = just(one)
assert nat2pos(2) = just(succ(one))
assert nat2pos(3) = just(succ(succ(one)))

/*
  From Agda.Builtin.Nat.

  To divide n by m, we use iterative subtraction, except that we only
  subtract 1 from n at a time.  We use j to keep track of how much of
  m has been subtracted from n. Each time j gets to one, we add one
  to the answer and reset j at m.
  
*/
function div_helper(Nat,Nat,Pos,Pos) -> Nat {
  div_helper(0, k, m, j) = k
  div_helper(suc(n'), k, m, j) =
    switch j {
      case one {
        div_helper(n', suc(k), m, m)
      }
      case succ(j') {
        div_helper(n', k, m, j')
      }
    }
}

function operator /(Nat,Pos) -> Nat {
  operator /(0, m) = 0
  operator /(suc(n'), m) = div_helper(suc(n'), 0, m, m)
}

assert default(after(nat2pos(1),λd{ 2 / d = 2}), false)
assert default(after(nat2pos(2),λd{ 4 / d = 2}), false)
assert default(after(nat2pos(2),λd{ 5 / d = 2}), false)
assert default(after(nat2pos(2),λd{ 6 / d = 3}), false)
assert default(after(nat2pos(3),λd{ 3 / d = 1}), false)
assert default(after(nat2pos(3),λd{ 9 / d = 3}), false)
assert default(after(nat2pos(3),λd{ 10 / d = 3}), false)

function operator ≤(Nat,Nat) -> bool {
  operator ≤(0, m) = true
  operator ≤(suc(n'), m) =
    switch m {
      case 0 { false }
      case suc(m') { n' ≤ m' }
    }
}

define operator < : fn Nat,Nat -> bool = λ x, y { suc(x) ≤ y }
define operator > : fn Nat,Nat -> bool = λ x, y { y < x }
define operator ≥ : fn Nat,Nat -> bool = λ x, y { y ≤ x }

theorem less_equal_implies_less_or_equal:
  all x:Nat. all y:Nat.
  if x ≤ y then x < y or x = y
proof
  induction Nat
  case 0 {
    arbitrary y:Nat
    switch y {
      case 0 {
        .
      }
      case suc(y') {
        suppose _
	definition {operator<, operator≤}.
      }
    }
  }
  case suc(x') suppose IH {
    arbitrary y:Nat
    suppose sx_le_y
    switch y {
      case 0 suppose yz {
        conclude false  by definition operator≤ in rewrite yz in sx_le_y
      }
      case suc(y') suppose y_sy {
        have x_le_y: x' ≤ y'
	  by definition operator≤ in rewrite y_sy in sx_le_y
	have xy_or_xy: x' < y' or x' = y'
	  by apply IH[y'] to x_le_y
	cases xy_or_xy
	case x_l_y {
	  have sx_l_sy: suc(x') < suc(y')
	    by enable {operator<, operator≤} x_l_y
          conclude (suc(x') < suc(y') or suc(x') = suc(y'))
  	    by sx_l_sy
	}
	case x_y {
	  have sx_sy: suc(x') = suc(y')
	    by rewrite x_y.
          conclude (suc(x') < suc(y') or suc(x') = suc(y'))
  	    by sx_sy
	}
      }
    }
  }
end

theorem less_implies_less_equal:
  all x:Nat. all y:Nat.
  if x < y then x ≤ y
proof
  induction Nat
  case zero {
    arbitrary y:Nat
    suppose zy: 0 < y
    definition operator ≤.
  }
  case suc(x') suppose IH {
    arbitrary y:Nat
    suppose sx_y: suc(x') < y
    have ssx_y: suc(suc(x')) ≤ y  by definition operator < in sx_y
    switch y {
      case zero suppose yz {
        conclude false  by definition operator ≤ in (rewrite yz in ssx_y)
      }
      case suc(y') suppose EQ : y = suc(y') {
        have ssx_sy: suc(suc(x')) ≤ suc(y')  by rewrite EQ in ssx_y
        have x_y: x' < y'  by definition operator < definition operator ≤ in ssx_sy
	suffices suc(x') ≤ suc(y')
        definition operator ≤	       
        conclude x' ≤ y'  by apply IH[y'] to x_y
      }
    }
  }
end

theorem less_equal_refl: all n:Nat. n ≤ n
proof
  enable operator ≤
  induction Nat
  case 0 { have 0 ≤ 0  by . }
  case suc(n') suppose IH { have suc(n') ≤ suc(n')  by IH }
end

theorem less_equal_antisymmetric:
  all x:Nat. all y:Nat. 
  if x ≤ y and y ≤ x
  then x = y
proof
  induction Nat
  case zero {
    arbitrary y:Nat
    suppose zy_yz: 0 ≤ y and y ≤ 0
    switch y {
      case zero { . }
      case suc(y') suppose y_suc {
        have sy_z: suc(y') ≤ 0 by rewrite y_suc in zy_yz
        conclude false by definition operator ≤ in sy_z
      }
    }
  }
  case suc(x') suppose IH {
    arbitrary y:Nat
    suppose sxy_ysx: suc(x') ≤ y and y ≤ suc(x')
    switch y {
      case zero suppose y_z {
        have sx_z: suc(x') ≤ 0 by rewrite y_z in sxy_ysx
        conclude false by definition operator ≤ in sx_z
      }
      case suc(y') suppose y_suc {
        enable operator ≤
        have x_le_y: x' ≤ y' by rewrite y_suc in sxy_ysx
        have y_le_x: y' ≤ x' by rewrite y_suc in sxy_ysx
        have x_y: x' = y' by (apply IH[y'] to x_le_y, y_le_x)
        conclude suc(x') = suc(y') by rewrite x_y.
      }
    }
  }
end

theorem less_equal_trans: all m:Nat. all n:Nat, o:Nat.
  if m ≤ n and n ≤ o then m ≤ o
proof
  enable operator ≤
  induction Nat
  case 0 {
    arbitrary n:Nat, o:Nat
    suppose _
    have 0 ≤ o  by .
  }
  case suc(m') suppose IH {
    arbitrary n:Nat, o:Nat
    suppose Prem: suc(m') ≤ n and n ≤ o
    have sm_n: suc(m') ≤ n  by Prem // bug
    have n_o: n ≤ o  by Prem
    switch n {
      case 0 suppose nz {
        have sm_z: suc(m') ≤ 0  by rewrite nz in sm_n
        have false  by sm_z
      }
      case suc(n') suppose ns {
        have sm_sn: suc(m') ≤ suc(n')  by rewrite ns in sm_n
        have m_n: m' ≤ n'  by sm_sn
        have sn_o: suc(n') ≤ o  by rewrite ns in n_o
        switch o {
          case 0 suppose oz {
            have sn_z: suc(n') ≤ 0  by rewrite oz in sn_o
            conclude false  by sn_z
          }
          case suc(o') suppose os {
            have sn_so: suc(n') ≤ suc(o')  by rewrite os in sn_o
            have n_o: n' ≤ o'  by sn_so
            definition operator ≤
            conclude m' ≤ o'  by apply IH[n',o'] to m_n, n_o
          }
        }
      }
    }
  }
end

theorem not_less_less_equal:
  all x: Nat. all y: Nat.
  if not (x < y) then y ≤ x
proof
  induction Nat
  case zero {
    arbitrary y: Nat
    suppose not_0_y: not (0 < y)
    switch y {
      case zero { definition operator ≤. }
      case suc(y') suppose ys {
        conclude false by apply (rewrite ys in not_0_y)
                      to (definition operator < definition {operator ≤,operator ≤}.)
      }
    }
  }
  case suc(x') suppose IH {
    arbitrary y: Nat
    suppose not_sx_y: not (suc(x') < y)
    switch y {
      case zero { definition operator ≤. }
      case suc(y') suppose ys {
        have not_x_y: not (x' < y')
          by (suppose x_y: x' < y'
            have sx_sy: suc(x') < suc(y')
              by definition operator <
	         definition operator ≤
		 (definition operator < in x_y)
            have sx_y: suc(x') < y by (rewrite ys sx_sy)
            apply not_sx_y to sx_y)
        definition operator ≤
	conclude y' ≤ x' by apply IH[y'] to not_x_y
      }
    }
  }
end

theorem less_irreflexive:  all x:Nat. not (x < x)
proof
  induction Nat
  case zero {
    suppose z_l_z: 0 < 0
    enable {operator <, operator ≤}
    conclude false by z_l_z
  }
  case suc(x') suppose IH: not (x' < x') {
    suppose sx_l_sx: suc(x') < suc(x')
    enable {operator <, operator ≤}
    have x_l_x: x' < x' by sx_l_sx
    conclude false by apply IH to x_l_x
  }
end

theorem less_not_greater_equal:
  all x:Nat. all y:Nat.
  if x < y then not (y ≤ x)
proof
  induction Nat
  case zero {
    arbitrary y : Nat
    suppose z_l_y: 0 < y
    suppose y_le_z: y ≤ 0
    switch y {
      case zero suppose y_z: y = 0 {
        definition {operator <, operator ≤}
        in (rewrite y_z in z_l_y)
      }
      case suc(y') suppose y_s: y = suc(y') {
        definition {operator ≤}
        in (rewrite y_s in y_le_z)
      }
    }
  }
  case suc(x') suppose IH {
    arbitrary y : Nat
    suppose sx_less_y
    suppose y_le_sx
    switch y {
      case zero suppose y_eq_zero {
        have false by (definition {operator <, operator ≤} in
                       (rewrite y_eq_zero in sx_less_y))
      }
      case suc(y') suppose ys {
        have x_less_y: x' < y' by
	  definition operator <
	  definition operator ≤ in
	  definition operator < in
	  rewrite ys in sx_less_y
        have y_le_x: y' ≤ x' by definition operator ≤ in rewrite ys in y_le_sx
        have false by apply (apply IH[y'] to x_less_y) to y_le_x
      }
    }
  }
end

theorem less_not_equal:
  all x:Nat. all y:Nat.
  if x < y then not (x = y)
proof
  arbitrary x:Nat arbitrary y:Nat
  suppose x_l_y: x < y
  suppose x_y: x = y
  have y_l_y: y < y by rewrite x_y in x_l_y
  conclude false by apply less_irreflexive[y] to y_l_y
end

theorem less_implies_not_less_equal:
  all x:Nat. all y:Nat.
  if x < y then not (y ≤ x)
proof
  induction Nat
  case zero {
    arbitrary y:Nat
    suppose y_pos
    suppose y_le_z
    switch y {
      case 0 suppose y_z {
        conclude false   by definition {operator <, operator≤} in
	                    rewrite y_z in y_pos
      }
      case suc(y') suppose y_sy {
        conclude false   by definition operator≤ in rewrite y_sy in y_le_z
      }
    }
  }
  case suc(x') suppose IH {
    arbitrary y:Nat
    suppose sx_l_y
    suppose y_le_sx
    switch y {
      case 0 suppose y_z {
        conclude false  by definition{operator<, operator≤} in
	                   rewrite y_z in sx_l_y
      }
      case suc(y') suppose y_sy {
	have x_l_y: x' < y'
	  by definition {operator<}
	     definition {operator ≤} in
	     definition {operator<} in rewrite y_sy in sx_l_y
        have y_le_x: y' ≤ x'
	  by definition operator≤ in rewrite y_sy in y_le_sx
	conclude false  by apply (apply IH[y'] to x_l_y) to y_le_x
      }
    }
  }
end


theorem less_implies_not_greater:
  all x:Nat. all y:Nat.
  if x < y then not (y < x)
proof
  induction Nat
  case zero {
    arbitrary y:Nat
    suppose zero_less_y
    suppose y_less_zero
    have false by (definition {operator <, operator ≤} in y_less_zero)
    }
  case suc(x') suppose IH {
    arbitrary y:Nat
    suppose sx_less_y
    suppose y_less_sx
    switch y {
      case zero suppose y_eq_zero {
        have false by (definition {operator <, operator ≤} in
                       (rewrite y_eq_zero in sx_less_y))
      }
      case suc(y') suppose ys {
        have x_less_y: x' < y' by
	  definition operator <
	  definition operator ≤ in definition operator < in
	  rewrite ys in sx_less_y
        have y_less_x: y' < x' by definition operator <
	  definition operator ≤ in definition operator < in
	  rewrite ys in y_less_sx
        have false by apply (apply IH[y'] to x_less_y) to y_less_x
      }
    }
  }
end


theorem max_suc: all x:Nat. max(suc(x), x) = suc(max(x,x))
proof
  induction Nat
  case zero {
    definition max.
  }
  case suc(x') suppose IH {
    equations
    max(suc(suc(x')),suc(x')) = suc(max(suc(x'),x'))
                                         by definition max definition max.
    ... = suc(suc(max(x',x')))           by rewrite IH.
    ... = suc(max(suc(x'),suc(x')))      by definition max.
  }
end

theorem max_suc2: all x:Nat, y:Nat. max(suc(x), suc(y)) = suc(max(x,y))
proof
  arbitrary x:Nat, y:Nat
  switch x {
    case 0 {
      suffices max(1,suc(y)) = suc(max(0,y))
      definition {max, max}.
    }
    case suc(x') {
      switch y {
	case 0 {
	  definition {max, max}.
	}
	case suc(y') {
	  definition {max, max}.
	}
      }
    }
  }
end

theorem max_greater_right: all y:Nat. all x:Nat. 
  y ≤ max(x, y)
proof
  induction Nat
  case 0 {
    arbitrary x:Nat
    definition operator ≤.
  }
  case suc(y') suppose IH {
    arbitrary x:Nat
    switch x {
      case 0 {
        definition max
        less_equal_refl[suc(y')]
      }
      case suc(x') {
        rewrite max_suc2[x',y']
	definition operator ≤
	conclude y' ≤ max(x', y') by IH[x']
      }
    }
  }
end

theorem max_greater_left: all x:Nat. all y:Nat. 
  x ≤ max(x, y)
proof
  induction Nat
  case 0 {
    arbitrary y:Nat
    definition operator ≤.
  }
  case suc(x') suppose IH {
    arbitrary y:Nat
    switch y {
      case 0 {
        suffices suc(x') ≤ max(suc(x'),0)
	definition max
	conclude suc(x') ≤ suc(x')  by less_equal_refl[suc(x')]
      }
      case suc(y') {
        definition {max, operator ≤}
        conclude x' ≤ max(x',y')  by IH[y']
      }
    }
  }
end

theorem max_is_left_or_right: all x:Nat. all y:Nat.
  max(x, y) = x or max(x, y) = y
proof
  induction Nat
  case 0 {
    arbitrary y:Nat
    definition max.
  }
  case suc(x') suppose IH {
    arbitrary y:Nat
    switch y {
      case 0 {
        definition max.
      }
      case suc(y') {
        definition max
	cases IH[y']
        case m_x: max(x',y') = x' {
	  suffices suc(max(x',y')) = suc(x')
	  rewrite m_x.
	}
	case m_y: max(x',y') = y' {
	  suffices suc(max(x',y')) = suc(y')
	  rewrite m_y.
	}
      }
    }
  }
end

theorem trichotomy:
  all x:Nat. all y:Nat.
  x < y  or  x = y  or  y < x
proof
  induction Nat
  case zero {
    arbitrary y:Nat
    switch y {
      case zero { have 0 = 0 by reflexive }
      case suc(y') {
        enable {operator <, operator ≤, operator ≤}
        have 0 < suc(y') by .
      }
    }
  }
  case suc(x') suppose IH {
    arbitrary y:Nat
    switch y {
      case zero {
        have 0 < suc(x')  by definition {operator ≤,operator ≤,operator <}.
      }
      case suc(y') {
        //enable operator <
        cases (have (x' < y' or x' = y' or y' < x') by IH[y'])
        case less { conclude suc(x') < suc(y')
	    by definition operator < definition operator ≤ 
	       definition operator < in less
	}
        case equal { conclude suc(x') = suc(y')  by rewrite equal . }
        case greater {
	  conclude suc(y') < suc(x')
	      by definition operator <
	         definition operator ≤
	         definition operator < in greater
	}
      }
    }
  }
end
  
theorem trichotomy2:
  all y:Nat, x:Nat.
  if not (x = y) and not (x < y)
  then y < x
proof
  arbitrary y:Nat, x:Nat
  suppose prem: not (x = y) and not (x < y)
  cases trichotomy[x][y]
  case less: x < y {
    have not_less: not (x < y)  by prem
    have false  by apply not_less to less
  }
  case equal: x = y {
    have not_equal: not (x = y)  by prem
    have false  by apply not_equal to equal
  }
  case greater: y < x {
    conclude y <  x by greater
  }
end

theorem positive_1_and_2: 0 ≤ 1 and 0 ≤ 2
proof
  have one_pos: 0 ≤ 1 by definition operator ≤.
  have two_pos: 0 ≤ 2 by definition operator ≤.
  conclude 0 ≤ 1 and 0 ≤ 2 by one_pos, two_pos
end

theorem positive_2: 0 ≤ 2
proof
  conclude 0 ≤ 2 by positive_1_and_2
end

theorem less_implies_less_equal:
  all x:Nat. all y:Nat.
  if x < y  then  x ≤ y
proof
  //enable {operator ≤, operator <}
  induction Nat
  case zero {
    arbitrary y:Nat
    suppose z_y: 0 < y
    conclude 0 ≤ y by definition operator ≤ .
  }
  case suc(x') suppose IH {
    arbitrary y:Nat
    switch y {
      case zero {
        definition {operator <, operator ≤}.
      }
      case suc(y') {
        suppose sx_sy: suc(x') < suc(y')
	enable {operator ≤, operator ≤, operator <}
	have x_y: x' < y' by sx_sy
        have x_le_y: x' ≤ y' by (apply IH[y'] to x_y)
        conclude suc(x') ≤ suc(y') by x_le_y
      }
    }
  }
end

theorem dichotomy:  all x:Nat, y:Nat.  x ≤ y  or  y < x
proof
  arbitrary x:Nat, y:Nat
  have tri: x < y or x = y or y < x by trichotomy[x][y]
  cases tri
  case x_l_y: x < y {
    have x_le_y: x ≤ y by apply less_implies_less_equal[x][y] to x_l_y
    conclude x ≤ y or y < x by x_le_y
  }
  case x_eq_y: x = y {
    have x_le_y: x ≤ y by rewrite x_eq_y less_equal_refl[y]
    conclude x ≤ y or y < x by x_le_y
  }
  case y_l_x: y < x {
    conclude x ≤ y or y < x by y_l_x
  }
end

theorem zero_or_positive: all x:Nat. x = 0 or 0 < x
proof
  arbitrary x:Nat
  switch x {
    case zero {
      conclude true or 0 < 0 by .
    }
    case suc(x') {
      have z_l_sx: 0 < suc(x')
          by definition {operator <, operator ≤, operator ≤}.
      conclude suc(x') = 0 or 0 < suc(x') by z_l_sx
    }
  }
end

theorem less_equal_add: all x:Nat. all y:Nat.
  x ≤ x + y
proof
  induction Nat
  case 0 {
    arbitrary y:Nat
    definition operator ≤.
  }
  case suc(x') suppose IH {
    arbitrary y:Nat
    definition {operator +, operator ≤}
    conclude x' ≤ x' + y  by IH[y]
  }
end

theorem dist_mult_add:
  all a:Nat. all x:Nat, y:Nat.
  a * (x + y) = a * x + a * y
proof
  induction Nat
  case zero {
    arbitrary x:Nat, y:Nat
    suffices 0 * (x + y) = 0 * x + 0 * y
    definition {operator *, operator +}.
  }
  case suc(a') suppose IH {
    arbitrary x:Nat, y:Nat
    suffices suc(a') * (x + y) = suc(a') * x + suc(a') * y
    definition operator *
    suffices x + y + a' * (x + y) = (x + a' * x) + (y + a' * y)
    equations
    x + y + a' * (x + y) = x + y + (a' * x + a' * y) by rewrite IH[x,y].
    ... = ((x + y) + a' * x) + a' * y by symmetric add_assoc[x+y][a'*x,a'*y]
    ... = (x + (y + a' * x)) + a' * y by rewrite add_assoc[x][y,a'*x].
    ... = (x + (a' * x + y)) + a' * y by rewrite add_commute[a'*x][y].
    ... = ((x + a' * x) + y) + a' * y by rewrite symmetric add_assoc[x][a'*x,y].
    ... = (x + a' * x) + (y + a' * y) by add_assoc[x+a'*x][y,a'*y]
  }
end

function is_even(Nat) -> bool {
  is_even(0) = true
  is_even(suc(n)) = is_odd(n)
}

function is_odd(Nat) -> bool {
  is_odd(0) = false
  is_odd(suc(n)) = is_even(n)
}

define Even : fn Nat -> bool = λ n { some m:Nat. n = 2 * m }
define Odd : fn Nat -> bool = λ n { some m:Nat. n = suc (2 * m) }

theorem addition_of_evens:
  all x:Nat, y:Nat.
  if Even(x) and Even(y) then Even(x + y)
proof
  arbitrary x:Nat, y:Nat
  suppose even_xy: Even(x) and Even(y)
  have even_x: some m:Nat. x = 2 * m by definition Even in even_xy
  have even_y: some m:Nat. y = 2 * m by definition Even in even_xy
  obtain a where x_2a: x = 2*a from even_x
  obtain b where y_2b: y = 2*b from even_y
  definition Even
  suffices some m:Nat. x + y = 2 * m
  choose a + b
  rewrite x_2a | y_2b
  conclude (2 * a) + (2 * b) = 2 * (a + b) by symmetric dist_mult_add[2][a,b]
end

theorem is_even_odd:
  all n:Nat.
  (if is_even(n) then Even(n))
  and (if is_odd(n) then Odd(n))
proof
  induction Nat
  case zero {
    have part1: if is_even(0) then Even(0)
      by suppose _
         have Even(0)
         by definition Even
            choose 0
            definition {operator *, operator *, operator *, operator +}.
   have part2: if is_odd(0) then Odd(0)
     by suppose zero_odd
        have false by definition is_odd in zero_odd
    part1, part2
  }
  case suc(n') suppose IH {
    have part1: (if is_even(suc(n')) then Even(suc(n'))) by
      (suppose suc_even: is_even(suc(n'))
       have odd_n: is_odd(n') by definition is_even in suc_even
       have Odd_n: Odd(n') by apply (conjunct 1 of IH) to odd_n
       obtain m where n_2m from definition Odd in Odd_n
       definition Even
       choose suc(m)
       rewrite n_2m
       definition {operator *, operator *, operator *, operator+}
       rewrite add_zero[m] | add_suc[m][m].)
    have part2: (if is_odd(suc(n')) then Odd(suc(n'))) by
      (suppose suc_odd: is_odd(suc(n'))
       have even_n: is_even(n') by definition is_odd in suc_odd
       have Even_n: Even(n') by apply (conjunct 0 of IH) to even_n
       obtain m where n_2m from definition Even in Even_n
       definition Odd
       choose m
       rewrite n_2m.)
    part1, part2
  }
end

theorem zero_le_zero: all x:Nat. if x ≤ 0 then x = 0
proof
  induction Nat
  case zero {
    suppose _
    .
  }
  case suc(x') {
    suppose prem: suc(x') ≤ 0
    conclude false by definition operator ≤ in prem
  }
end

function summation(Nat, Nat, fn Nat->Nat) -> Nat {
  summation(0, begin, f) = 0
  summation(suc(k), begin, f) = f(begin) + summation(k, suc(begin), f)
}

theorem summation_cong2: all k : Nat. all f : fn Nat->Nat, g : fn Nat->Nat, s : Nat, t : Nat. 
  if (all i:Nat. if i < k then f(s + i) = g(t + i))
  then summation(k, s, f) = summation(k, t, g)
proof
  induction Nat
  case zero {
    arbitrary f:fn(Nat) -> Nat,g:fn(Nat) -> Nat,s:Nat,t:Nat
    suppose f_g
    definition summation.
  }
  case suc(k') suppose IH {
    arbitrary f:fn(Nat) -> Nat,g:fn(Nat) -> Nat,s:Nat,t:Nat
    suppose f_g
    suffices summation(suc(k'),s,f) = summation(suc(k'),t,g)
    definition summation
    have f_g_s: f(s) = g(t) by
       rewrite add_zero[s] | add_zero[t] in
       (apply f_g[0] to definition {operator <, operator ≤, operator ≤}.)
    have IH': summation(k',suc(s),f) = summation(k',suc(t),g)
      by apply IH[f,g,suc(s),suc(t)] 
         to arbitrary i:Nat suppose i_k: i < k'
	    suffices f(suc(s) + i) = g(suc(t) + i)
	    have fsi_gtsi: f(s + suc(i)) = g(t + suc(i))
	      by apply f_g[suc(i)] to
	         enable {operator <, operator ≤, operator ≤} i_k
	    enable operator + rewrite add_suc[s][i] | add_suc[t][i] in fsi_gtsi
    rewrite f_g_s | IH'.
  }
end

theorem summation_cong: all k:Nat. all f : fn Nat->Nat, g : fn Nat->Nat, s :Nat. 
  if (all i:Nat. if s ≤ i and i < s + k then f(i) = g(i))
  then summation(k, s, f) = summation(k, s, g)
proof
  induction Nat
  case zero {
    arbitrary f : fn Nat->Nat, g : fn Nat->Nat, s :Nat
    suppose _
    definition summation.
  }
  case suc(k') suppose IH {
    arbitrary f : fn Nat->Nat, g : fn Nat->Nat, s :Nat
    suppose f_g: all i:Nat. if s ≤ i and i < s + suc(k') then f(i) = g(i)
    definition summation
    have f_g_s: f(s) = g(s) by
        (have s_s: s ≤ s by less_equal_refl[s]
	 have s_sk: s < s + suc(k') by (enable {operator <,operator ≤}
	                                rewrite add_suc[s][k']
 	                                less_equal_add[s][k'])
         apply f_g[s] to s_s, s_sk)
    have IH': summation(k',suc(s),f) = summation(k',suc(s),g)
                  by apply IH[f,g,suc(s)] to (arbitrary i:Nat suppose ss_i_and_i_ss_k
		                              have s_i: s ≤ i by
					         apply less_implies_less_equal[s][i]
					         to definition operator < ss_i_and_i_ss_k
			                      have i_s_k: i < s + suc(k') by
					         enable {operator <, operator +}
						 rewrite add_suc[s][k']
					         (conjunct 1 of ss_i_and_i_ss_k)
		                              conclude f(i) = g(i) by apply f_g[i] to s_i, i_s_k)
    rewrite f_g_s | IH'.
  }
end

theorem summation_suc: all k:Nat. all f : fn Nat->Nat, g : fn Nat->Nat, s :Nat. 
  if (all i:Nat. f(i) = g(suc(i)))
  then summation(k, s, f) = summation(k, suc(s), g)
proof
  induction Nat
  case zero {
    arbitrary f : fn Nat->Nat, g : fn Nat->Nat, s :Nat
    suppose _
    definition summation.
  }
  case suc(k') suppose IH {
    arbitrary f : fn Nat->Nat, g : fn Nat->Nat, s :Nat
    suppose f_g: all i:Nat. f(i) = g(suc(i))
    definition summation
    rewrite symmetric f_g[s]
    have IH': summation(k',suc(s),f) = summation(k',suc(suc(s)),g)
                 by apply IH[f,g,suc(s)] to f_g
    rewrite symmetric IH'.
  }
end

theorem summation_cong: all k:Nat. all f : fn Nat->Nat, g : fn Nat->Nat, s :Nat, t :Nat. 
  if (all i:Nat. f(s + i) = g(t + i))
  then summation(k, s, f) = summation(k, t, g)
proof
  induction Nat
  case zero {
    arbitrary f : fn Nat->Nat, g : fn Nat->Nat, s :Nat, t :Nat
    suppose _
    definition summation.
  }
  case suc(k') suppose IH {
    arbitrary f : fn Nat->Nat, g : fn Nat->Nat, s :Nat, t :Nat
    suppose f_g: all i:Nat. f(s + i) = g(t + i)
    definition summation
    have fs_gt: f(s) = g(t)   by rewrite add_zero[s] | add_zero[t] in f_g[0]
    have all_f_g: all i:Nat. f(suc(s) + i) = g(suc(t) + i)
      by arbitrary i:Nat
	 definition operator + 
	 rewrite add_suc[s][i] | add_suc[t][i] in f_g[suc(i)]
    equations
          f(s) + summation(k',suc(s),f)
        = g(t) + summation(k',suc(s),f)   by rewrite fs_gt.
    ... = g(t) + summation(k',suc(t),g)   by rewrite (apply IH[f,g,suc(s),suc(t)] to all_f_g).
  }
end

theorem summation_add:
  all a:Nat. all b:Nat, s:Nat, t:Nat, f:fn Nat->Nat, g:fn Nat->Nat, h:fn Nat->Nat.
  if (all i:Nat. if i < a then g(s + i) = f(s + i))
  and (all i:Nat. if i < b then h(t + i) = f(s + a + i))
  then summation(a + b, s, f) = summation(a, s, g) + summation(b, t, h)
proof
  induction Nat
  case zero {
    arbitrary b:Nat, s:Nat, t:Nat, f:fn Nat->Nat, g:fn Nat->Nat, h:fn Nat->Nat
    suppose g_f_and_h_f
    enable {operator +}
    definition {summation}
    conclude summation(b,s,f) = summation(b,t,h)
      by apply summation_cong2[b][f,h,s,t]
         to arbitrary i:Nat
	    suppose i_b: i < b
	    conclude f(s + i) = h(t + i)
	    by rewrite add_zero[s] in
	       symmetric (apply (conjunct 1 of g_f_and_h_f)[i] to i_b)
  }
  case suc(a') suppose IH {
    arbitrary b:Nat, s:Nat, t:Nat, f:fn Nat->Nat, g:fn Nat->Nat, h:fn Nat->Nat
    suppose g_f_and_h_f
    definition {operator +, summation}
    have fs_gs: f(s) = g(s) by symmetric
        rewrite add_zero[s] | add_zero[t]
	in apply (conjunct 0 of g_f_and_h_f)[0]
	   to definition {operator <, operator ≤, operator ≤}.
    have IH': summation(a' + b,suc(s),f)
            = summation(a',suc(s),g) + summation(b,t,h)
      by have p1: all i:Nat. (if i < a' then g(suc(s) + i) = f(suc(s) + i))
	   by arbitrary i:Nat suppose i_a: i < a'
	      enable {operator +, operator ≤}  rewrite add_suc[s][i] in
	      (apply (conjunct 0 of g_f_and_h_f)[suc(i)] to enable {operator <, operator ≤} i_a)
         have p2: all i:Nat. (if i < b then h(t + i) = f(suc(s) + a' + i))
	   by arbitrary i:Nat suppose i_b: i < b
	      enable {operator +} rewrite add_suc[s][a'] in
	      apply (conjunct 1 of g_f_and_h_f)[i] to i_b
         apply IH[b,suc(s),t,f,g,h] to p1, p2
    rewrite fs_gs | IH' | add_assoc[g(s)][summation(a',suc(s),g), summation(b,t,h)].
  }
end

function equal(Nat, Nat) -> bool {
  equal(0, n) =
    switch n {
      case 0 { true }
      case suc(n') { false }
    }
  equal(suc(m'), n) =
    switch n {
      case 0 { false }
      case suc(n') { equal(m', n') }
    }
}

theorem equal_refl: all n:Nat. equal(n,n)
proof
  induction Nat
  case 0 {
    definition equal.
  }
  case suc(n') suppose IH {
    definition equal
    IH
  }
end

theorem equal_complete: all m:Nat. all n:Nat.
  if (m = n) then equal(m, n)
proof
  induction Nat
  case 0 {
    arbitrary n:Nat
    switch n {
      case 0 { definition equal. }
      case suc(n') { . }
    }
  }
  case suc(m') {
    arbitrary n:Nat
    switch n {
      case 0 { . }
      case suc(n') {
        suppose sm_sn: suc(m') = suc(n')
	definition equal
	have m_n: m' = n' by injective suc sm_sn
	rewrite m_n
	equal_refl[n']
      }
    }
  }
end

theorem not_equal_not_eq: all m:Nat, n:Nat.
  if not equal(m, n) then not (m = n)
proof
  arbitrary m:Nat, n:Nat
  suppose not_m_n
  suppose m_n
  have eq_m_n: equal(m, n) by rewrite m_n equal_refl[n]
  apply not_m_n to eq_m_n
end

theorem equal_sound: all m:Nat. all n:Nat.
  if equal(m, n) then (m = n)
proof
  induction Nat
  case 0 {
    arbitrary n:Nat
    suppose eq
    switch n {
      case 0 { . }
      case suc(n') suppose n_sn {
        conclude false by definition equal in (rewrite n_sn in eq)
      }
    }
  }
  case suc(m') suppose IH {
    arbitrary n:Nat
    suppose eq: equal(suc(m'),n)
    switch n {
      case 0 suppose n_0 {
        conclude false by definition equal in rewrite n_0 in eq
      }
      case suc(n') suppose n_sn {
        have eq_mn: equal(m', n')
            by definition equal in rewrite n_sn in eq
        have m_n: m' = n'
            by apply IH[n'] to eq_mn
        conclude suc(m') = suc(n')
            by rewrite m_n.
      }
    }
  }
end

theorem add_to_zero: all n:Nat. all m:Nat.
  if n + m = 0
  then n = 0 and m = 0
proof
  induction Nat
  case 0 {
    arbitrary m:Nat
    suppose zmz
    have mz: m = 0
      by definition operator + in zmz
    rewrite mz.
  }
  case suc(n') suppose IH {
    arbitrary m:Nat
    suppose snmz: suc(n') + m = 0
    conclude false
        by definition operator + in snmz
  }
end

theorem not_less_equal_greater:
  all x:Nat, y:Nat.
  if not (x ≤ y) then y < x
proof
  arbitrary x:Nat, y:Nat
  suppose not_xy
  cases dichotomy[x,y]
  case x_le_y {
    apply not_xy to x_le_y
  }
  case y_l_x {
    y_l_x
  }
end

theorem less_equal_left_cancel: all x:Nat. all y:Nat, z:Nat.
  if x + y ≤ x + z then y ≤ z
proof
  induction Nat
  case 0 {
    arbitrary y:Nat, z:Nat
    suppose y_le_z: 0 + y ≤ 0 + z
    conclude y ≤ z
        by definition {operator+, operator≤} in y_le_z
  }
  case suc(x') suppose IH {
    arbitrary y:Nat, z:Nat
    suppose sx_y_le_sx_z: suc(x') + y ≤ suc(x') + z
    have x_y_le_x_z: x' + y ≤ x' + z
      by definition {operator +, operator ≤} in sx_y_le_sx_z
    conclude y ≤ z
      by apply IH[y,z] to x_y_le_x_z
  }
end

theorem less_left_cancel: all x:Nat, y:Nat, z:Nat.
  if x + y < x + z then y < z
proof
  arbitrary x:Nat, y:Nat, z:Nat
  definition {operator <}
  suppose sxy_xz
  have x_sy_le_xz: x + suc(y) ≤ x + z
    by rewrite add_suc[x][y]
       sxy_xz
  conclude suc(y) ≤ z
    by apply less_equal_left_cancel[x][suc(y), z] to x_sy_le_xz
end

function div2(Nat) -> Nat {
  div2(0) = 0
  div2(suc(n')) = div2_aux(n')
}

function div2_aux(Nat) -> Nat {
  div2_aux(0) = 0
  div2_aux(suc(n')) = suc(div2(n'))
}

assert div2(0) = 0
assert div2(1) = 0
assert div2(2) = 1
assert div2(3) = 1
assert div2(4) = 2
assert div2(5) = 2
assert div2(6) = 3
assert div2(7) = 3
assert div2(8) = 4
assert div2(9) = 4
assert div2(10) = 5

theorem div2_add_2: all n:Nat.  div2(suc(suc(n))) = suc(div2(n))
proof
  arbitrary n:Nat
  definition {div2, div2_aux}.
end

theorem div2_double: all n:Nat.
  div2(n + n) = n
proof
  induction Nat
  case 0 {
    definition {operator+, div2}.
  }
  case suc(n') suppose IH {
    definition {operator+}
    rewrite add_suc[n'][n']
    rewrite div2_add_2[n' + n']
    rewrite IH.
  }
end

theorem div2_times2: all n:Nat.
  div2(2 * n) = n
proof
  arbitrary n:Nat
  definition {operator*,operator*,operator*,operator+}
  rewrite add_zero[n]
  div2_double[n]
end

theorem div2_suc_double: all n:Nat.
  div2(suc(n + n)) = n
proof
  induction Nat
  case 0 {
    definition {operator+, div2, div2_aux}.
  }
  case suc(n') suppose IH {
    definition {operator+, div2, div2_aux}
    rewrite add_suc[n'][n']
    rewrite IH.
  }
end

theorem div2_suc_times2: all n:Nat.
  div2(suc(2 * n)) = n
proof
  arbitrary n:Nat
  definition {operator*,operator*,operator*,operator+}
  rewrite add_zero[n]
  div2_suc_double[n]
end

function pow2(Nat) -> Nat {
  pow2(0) = 1
  pow2(suc(n')) = 2 * pow2(n')
}

assert pow2(0) = 1
assert pow2(1) = 2
assert pow2(2) = 4
assert pow2(3) = 8
assert pow2(4) = 16

theorem positive_suc: all n:Nat.
  if 0 < n
  then some n':Nat. n = suc(n')
proof
  arbitrary n:Nat
  switch n {
    case 0 {
      suppose z_l_z: 0 < 0
      conclude false  by definition {operator<, operator≤} in z_l_z
    }
    case suc(n') {
      suppose z_l_sn: 0 < suc(n')
      choose n'.
    }
  }
end

theorem pow_positive: all n:Nat. 0 < pow2(n)
proof
  induction Nat
  case 0 {
    definition {pow2, operator<, operator≤}.
  }
  case suc(n') suppose IH {
    definition {pow2}
    obtain pn' where pn_s: pow2(n') = suc(pn')
        from apply positive_suc[pow2(n')] to IH
    rewrite pn_s
    definition {operator*,operator*,operator*}
    rewrite add_zero[suc(pn')]
    definition {operator+}
    rewrite add_suc[pn'][pn']
    definition {operator<, operator≤}.
  }
end

function iterate<T>(Nat, T, fn T -> T) -> T {
  iterate(0, init, f) = init
  iterate(suc(n), init, f) = f(iterate(n, init, f))
}