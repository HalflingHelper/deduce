// TODO: This is a temporary file with the lemmas 
// and proof of dist_mult_sub.
// These should be moved into Nat.pf

import Nat

// NOTE: These lemmas may be helpful in Nat.pf
lemma le_cong_add : all x : Nat. all y : Nat, z : Nat.
    if y <= z then x + y <= x + z
proof
    induction Nat
    case zero {
        arbitrary y:Nat, z:Nat
        suppose prem
        _definition operator+
        prem
    }
    case suc(n') suppose IH{
        arbitrary y:Nat, z:Nat
        suppose prem
        _definition {operator+, operator≤}
        apply IH[y, z] to prem
    }
end

lemma le_cong_mult: all n : Nat. all x : Nat, y : Nat.
    if x <= y then n * x <= n * y
proof
    induction Nat 
    case 0 {
        arbitrary x:Nat, y:Nat
        suppose prem: x <= y
        _rewrite zero_mult[x] | zero_mult[y]
        definition operator≤
    }
    case suc(n') suppose IH {
        arbitrary x:Nat, y:Nat
        suppose prem : x <= y
        _definition operator*
        have nx_le_ny: n' * x <= n' * y 
            by apply IH[x, y] to prem
        have nxx_le_nxy:  n' * x + x <= n' * x + y
            by apply le_cong_add[n' * x][x,y] to prem 
        have xnx_le_ynx : x + n' * x <= y + n' * x
            by rewrite add_commute[n' * x][x]
                     | add_commute[n' * x][y]
                     in nxx_le_nxy
        have ynx_le_yny :  y+ n'*x <= y+n'*y
            by apply le_cong_add[y][n'*x,n'*y] to nx_le_ny
        apply less_equal_trans[x+n'*x][y + n'*x, y + n'*y] to xnx_le_ynx, ynx_le_yny
    }
end

// TODO: This sucks, I don't need so many IHs, they can be switch
theorem temp : all x : Nat. all y:Nat. all z:Nat.
    (x - y) - z = x - (y + z)
proof
    induction Nat
    case zero {
        arbitrary y:Nat
        arbitrary z:Nat
        definition operator -
    }
    case suc(x') suppose IH{
        induction Nat
        case zero {
            arbitrary z : Nat
            rewrite sub_zero[suc(x')] | zero_add[z]
        }
        case suc(y') suppose IH' {
            induction Nat 
            case zero {
                rewrite sub_zero[suc(x') - suc(y')] | add_zero[suc(y')]
            }
            case suc(z') suppose IH'' {
                _definition operator+
                _definition operator-
                IH[y'][suc(z')]
            }
        }
    }
end

theorem sub_less_zero : all x : Nat. all y : Nat.
    if x <= y then x - y = 0
proof
    induction Nat 
    case zero {
        definition operator-
    }
    case suc(x') suppose IH {
        arbitrary y : Nat
        switch y {
            case zero {
                suppose sx_l_z
                apply zero_le_zero[suc(x')] to sx_l_z // Contradiction
            }
            case suc(y') {
                suppose prem
                _definition operator-
                have x_l_y: x' <= y' by definition operator<= in prem
                apply IH[y'] to x_l_y
            }
        }
    }
end


theorem dist_mult_sub : all x : Nat. all y : Nat, z : Nat.
    x * (y - z) = x * y - x * z
proof
    induction Nat
    case zero {
        arbitrary y:Nat, z:Nat
        _rewrite zero_mult[y-z] | zero_mult[y] | zero_mult[z]
        definition operator-
    }
    case suc(n') suppose IH {
        arbitrary y:Nat, z:Nat
        _definition operator*
        _rewrite IH[y, z]
        _rewrite add_commute[(y - z)][(n' * y - n' * z)]
        cases dichotomy[z, y]
        case z_le_y: z <= y {
            _rewrite apply sub_add_assoc[y][(n' * y - n' * z) ,z] to z_le_y
            have nz_le_ny : n'*z <=n' * y
                by apply le_cong_mult[n'][z, y] to z_le_y
            _rewrite add_commute[(n' * y - n' * z)][y]
            _rewrite apply sub_add_assoc[n'*y][y, n'*z] to nz_le_ny
            _rewrite temp[(y + n' * y)][n' * z][z]
            _rewrite add_commute[n' * z][z]
            .
        }
        case ylz: y < z {
            have y_le_z: y <= z by apply less_implies_less_equal[y][z] to ylz
            have ny_le_nz: n' * y <= n' * z by apply le_cong_mult[n'][y, z] to y_le_z
            have zny_le_znz : z + n'*y <= z + n'*z by apply le_cong_add[z][n'*y, n'*z] to ny_le_nz
            have nyy_le_nyz: n' * y + y <= n' * y + z by apply le_cong_add[n' *y][y, z] to y_le_z
            have yny_le_zny : y + n' * y <= z + n' * y 
                by rewrite add_commute[n'*y][y] | add_commute[n'*y][z] in nyy_le_nyz
            have yny_le_znz: y + n'*y <= z + n'*z
                by apply less_equal_trans[y + n' * y][z + n' * y,z + n' * z] to yny_le_zny, zny_le_znz
            _rewrite apply sub_less_zero[y][z] to y_le_z
                   | apply sub_less_zero[n'*y][n'*z] to ny_le_nz
                   | apply sub_less_zero[y+n'*y][z+n'*z] to yny_le_znz
            add_zero[0]
        }
    }
end
